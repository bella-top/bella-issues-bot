# 项目文件描述


- core/workflow_engine.py: 工作流引擎核心模块，协调版本管理、日志管理和AI交互，包含WorkflowEngine类，实现代码生成和聊天流程的自动切换和执行。

- client/README.md: WorkflowEngine客户端文档，详细介绍了两种工作模式（个人开发助手和GitHub自动化）、命令行参数、使用方法以及编程API，支持通过CLI或Python接口调用核心功能。

- core/git_manager.py: Git操作管理器，提供GitManager类处理仓库克隆、分支管理、提交、推送、回退等操作。支持版本回退和历史追踪，与VersionManager密切协作。

- client/cli.py: 命令行接口模块，提供解析命令行参数的功能，包含parse_args()、get_requirement_text()和build_config_from_args()函数，用于配置和运行WorkflowEngine。

- client/runner.py: 提供工作流引擎的编程API接口，方便在Python脚本中调用。主要包含run_workflow函数，接收多个参数如issue_id、requirement等，创建WorkflowEngineConfig并运行工作流引擎。为程序化使用提供简化接口。

- client/terminal.py: WorkflowEngine的终端入口点，提供run_workflow_from_terminal()函数，负责从命令行解析参数并运行工作流引擎，支持环境变量配置。

- pyproject.toml: 项目配置文件，定义包名为bella-issues-bot及其依赖。包含Poetry构建信息、Python版本要求、依赖包列表。定义命令行入口点为client.terminal模块。还包括代码质量工具配置如ruff和black。


# 文件内容



```
File: core/workflow_engine.py
1 import os
2 from dataclasses import dataclass
3 from typing import Optional
4 
5 from core.ai import AIConfig
6 from core.chat_processor import ChatProcessor, ChatProcessorConfig
7 from core.code_engineer import CodeEngineer, CodeEngineerConfig
8 from core.decision import DecisionProcess
9 from core.diff import Diff
10 from core.file_memory import FileMemory, FileMemoryConfig
11 from core.file_selector import FileSelector
12 from core.git_manager import GitManager, GitConfig, get_issues_branch_name
13 from core.log_manager import LogManager, LogConfig
14 from core.prompt_generator import PromptGenerator, PromptData
15 from core.version_manager import VersionManager
16 from log_config import get_logger
17 
18 logger = get_logger(__name__)
19 
20 @dataclass
21 class WorkflowEngineConfig:
22     project_dir: str
23     issue_id:int
24     core_model:str = "gpt-4o"
25     data_model:str = "gpt-4o"
26     core_template: float = 0.7
27     data_template: float = 0.7
28     max_retry: int = 3,
29     default_branch: str = "main"
30     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
31     base_url: Optional[str] = None
32     api_key: Optional[str] = None
33     github_remote_url: Optional[str] =None
34     github_token: Optional[str] = None
35 
36 
37 class WorkflowEngine:
38     CODE_TIMES = 0
39     CHAT_TIMES = 0
40     """
41     工作流引擎，协调版本管理、日志管理和AI交互
42     """
43     def __init__(self, config: WorkflowEngineConfig):
44         """
45         初始化工作流引擎
46         
47         Args:
48             config: 工作流配置
49         """
50         self.CODE_TIMES = 0
51         self.CHAT_TIMES = 0
52         self.config = config
53 
54         self.project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
55         
56         # 创建AI配置
57         self.core_ai_config = AIConfig(
58             model_name=config.core_model,
59             temperature=config.core_template,
60             base_url=config.base_url,
61             api_key=config.api_key
62         )
63         
64         self.data_ai_config = AIConfig(
65             model_name=config.data_model,
66             temperature=config.data_template,
67             base_url=config.base_url,
68             api_key=config.api_key
69         )
70         
71         # 创建Git配置
72         self.git_config = GitConfig(
73             repo_path=self.project_dir,
74             remote_url=config.github_remote_url,
75             auth_token=config.github_token,
76             default_branch=config.default_branch
77         )
78         
79         # 创建日志配置
80         self.log_config = LogConfig(
81             project_dir=self.project_dir,
82             issue_id=config.issue_id
83         )
84         
85         # 初始化管理器
86         self.log_manager = LogManager(config=self.log_config)
87         self.git_manager = GitManager(config=self.git_config)
88         self.version_manager = VersionManager(
89             issue_id=config.issue_id,
90             ai_config=self.core_ai_config,
91             log_manager=self.log_manager,
92             git_manager=self.git_manager
93         )
94         self.file_selector = FileSelector(
95             self.project_dir,
96             self.config.issue_id,
97             ai_config=self.core_ai_config
98         )
99         self.file_memory = FileMemory(
100             config=FileMemoryConfig(
101                 git_manager=self.git_manager,
102                 ai_config=self.core_ai_config,
103                 project_dir=self.project_dir
104             )
105         )
106         
107         # 初始化代码工程师
108         self.code_engineer_config = CodeEngineerConfig(
109             project_dir=self.project_dir,
110             ai_config=self.core_ai_config
111         )
112         self.engineer = CodeEngineer(
113             self.code_engineer_config,
114             self.log_manager,
115             Diff(self.data_ai_config)
116         )
117         
118         # 初始化聊天处理器
119         self.chat_processor = ChatProcessor(
120             ai_config=self.core_ai_config,
121             log_manager=self.log_manager,
122             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
123         )
124         
125         # 初始化决策环境
126         self.decision_env = DecisionProcess(
127             ai_config=self.core_ai_config,
128             version_manager=self.version_manager
129         )
130     
131     def process_requirement(self, user_requirement: str):
132         """
133         处理用户需求
134         
135         Args:
136             user_requirement: 用户需求
137 
138         """
139         # 重置到工作区
140         if self.config.mode == "bot":
141             self.git_manager.reset_to_issue_branch(self.config.issue_id)
142         # 先通过决策环境分析需求类型
143         decision_result = self.decision_env.analyze_requirement(user_requirement)
144         
145         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
146                     f"理由={decision_result.reasoning}")
147         
148         if decision_result.needs_code_modification:
149             # 执行代码修改流程
150             response = self._run_code_generation_workflow(user_requirement)
151         else:
152             # 执行对话流程
153             response = self._run_chat_workflow(user_requirement)
154         if self.config.mode == "bot" and self.config.github_remote_url and response:
155             self.git_manager.add_issue_comment(issue_number=self.config.issue_id, comment_text=response)
156     
157     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
158         """
159         执行代码生成流程，基于example_code_generate.py的逻辑
160         
161         Args:
162             user_requirement: 用户需求
163             
164         Returns:
165             str: 处理结果
166         """
167         logger.info("开始执行代码生成流程")
168 
169         # 确定当前版本
170         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
171 
172         # 初始化工作区
173         branch_name = self._init_env()
174 
175         # 生成提示词
176         user_prompt = self._get_user_prompt(requirement, history)
177 
178         # 根据提示词修改代码
179         success, response = self.engineer.process_prompt(prompt=user_prompt)
180         
181         # 提交更改
182         if success:
183             self.git_manager.commit(f"issues#{self.config.issue_id}-generate by Bella-Issues-Bot")
184             self.git_manager.push(branch=branch_name, force=True)
185             return response
186         else:
187             self.CODE_TIMES += 1
188             if self.CODE_TIMES >= self.config.max_retry:
189                 logger.error("code workflow超过最大重试次数")
190                 return self._run_chat_workflow(user_requirement)
191             else:
192                 return self._run_code_generation_workflow(user_requirement)
193     
194     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
195         """
196         执行聊天流程，基于example_chat_process.py的逻辑
197         
198         Args:
199             user_requirement: 用户需求
200             
201         Returns:
202             str: 处理结果
203         """
204         logger.info("开始执行聊天回复流程")
205 
206 
207         history = self.version_manager.get_formatted_history()
208         # 初始化工作区
209         branch_name = self._init_env()
210 
211         # 生成提示词
212         user_prompt = self._get_user_prompt(user_requirement, history)
213         
214         # 处理聊天请求
215         response = self.chat_processor.process_chat(user_prompt)
216 
217         if(response):
218             self.git_manager.commit(f"issues#{self.config.issue_id}-generate by Bella-Issues-Bot")
219             self.git_manager.push(branch=branch_name, force=True)
220             return response
221         else:
222             self.CHAT_TIMES += 1
223             if self.CHAT_TIMES >= self.config.max_retry:
224                 logger.error("chat workflow超过最大重试次数")
225                 return None
226             else:
227                 return self._run_chat_workflow(user_requirement)
228 
229     def _get_user_prompt(self, requirement: str, history: str) -> str:
230         # 选择文件
231         files = self.file_selector.select_files_for_requirement(requirement)
232         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
233 
234         # 准备提示词数据
235         data = PromptData(
236             requirement=requirement,
237             project_dir=self.project_dir,
238             steps=history,
239             files=files,
240             file_desc=descriptions
241         )
242 
243         # 生成提示词
244         return PromptGenerator.generatePrompt(data)
245 
246     def _init_env(self) -> str:
247         # 获取当前轮次
248         current_round = self.log_manager.get_current_round()
249 
250         # 获取分支名称
251         branch_name = get_issues_branch_name(self.config.issue_id, current_round)
252 
253         # 如果轮次大于1，增量更新上一轮修改的文件详细信息
254         if current_round > 1:
255             self.file_memory.update_file_details()
256         # 切换到适当的分支
257         self.git_manager.switch_branch(branch_name, True)
258         return branch_name
259
```




```
File: client/README.md
1 # Workflow 客户端
2 
3 一个强大的命令行接口和编程API，用于运行WorkflowEngine处理用户需求，支持个人开发助手模式和GitHub自动化工作流模式。
4 
5 ## 工作模式
6 
7 bella-issues-bot 支持两种主要工作模式：
8 
9 - **客户端模式 (client)**：默认模式，适合作为个人开发助手使用，每次运行时基于当前代码状态进行操作。
10 - **机器人模式 (bot)**：专为GitHub集成设计，会自动拉取最新分支状态，处理完成后自动提交更改并在Issues中回复处理结果。
11 ## 命令行使用方式（个人开发助手模式）
12 
13 你可以通过以下两种方式从命令行运行WorkflowEngine：
14 
15 ### 使用安装后的CLI命令
16 
17 ```bash
18 bella-issues-bot --issue-id 42 --requirement "创建一个README文件"
19 ```
20 
21 ### 直接使用Python模块
22 
23 ```bash
24 python -m client.terminal --issue-id 42 --requirement "创建一个README文件"
25 ```
26 
27 ### 命令行参数
28 
29 #### 基础参数
30 
31 - `--issue-id`：（必需）问题ID，用于跟踪和引用
32 - `--requirement` 或 `--requirement-file`：（必需）具体需求描述或包含需求的文件路径
33 - `--project-dir`：项目目录路径（默认：当前目录）
34 
35 #### AI模型配置
36 
37 - `--core-model`：核心AI操作使用的模型（默认：gpt-4o）
38 - `--data-model`：数据操作使用的模型（默认：gpt-4o）
39 - `--core-temperature`：核心模型的温度参数（默认：0.7）
40 - `--data-temperature`：数据模型的温度参数（默认：0.7）
41 
42 #### 工作流配置
43 
44 - `--mode`：工作模式，可选"client"或"bot"（默认：client）
45   - `client`：个人开发助手模式，基于当前代码状态工作
46   - `bot`：GitHub自动化模式，拉取最新分支，自动提交并回复Issues
47 - `--default-branch`：默认Git分支（默认：main）
48 - `--base-url`：API调用的基础URL
49 - `--api-key`：API密钥（也可以通过OPENAI_API_KEY环境变量设置）
50 - `--github-remote-url`：GitHub远程URL
51 - `--github-token`：GitHub令牌
52 
53 #### 执行控制
54 
55 - `--max-retry`：最大重试次数（默认：3）
56 
57 ### 简易脚本使用
58 
59 你也可以使用提供的脚本简化命令行调用：
60 
61 ```bash
62 ./scripts/run_bot.sh <问题ID> [需求文件路径]
63 ```
64 
65 ## 编程方式使用
66 
67 你也可以在Python代码中以编程方式使用客户端包：
68 
69 ```python
70 from client.runner import run_workflow
71 
72 run_workflow(
73     issue_id=42,
74     requirement="为项目创建一个README文件",
75     core_model="gpt-4o",
76     data_model="gpt-4o",
77     core_temperature=0.7,
78     data_temperature=0.7
79 )
80 ```
81 
82 ## 环境变量
83 
84 工具会读取以下环境变量：
85 
86 - `OPENAI_API_KEY`：OpenAI的API密钥
87 - `OPENAI_API_BASE`：OpenAI API的基础URL
88 - `GITHUB_TOKEN`：GitHub身份验证令牌
89
```




```
File: core/git_manager.py
1 import os
2 import shutil
3 from dataclasses import dataclass
4 from typing import Optional, List
5 from urllib.parse import urlparse, urlunparse
6 
7 import git
8 
9 from log_config import get_logger
10 
11 logger = get_logger(__name__)
12 
13 
14 @dataclass
15 class GitConfig:
16     """Git configuration parameters"""
17 
18     repo_path: str
19     remote_name: str = "origin"
20     default_branch: str = "main"
21     remote_url: Optional[str] = os.getenv("GIT_REMOTE")
22     auth_token: Optional[str] = os.getenv("GITHUB_TOKEN")
23 
24 
25 def get_issues_branch_name(issues_id: int, round: int) -> str:
26     return f"bella-bot-issues-{issues_id}-{round}"
27 
28 
29 class GitManager:
30     """Manages git operations including push, pull, branch creation and switching"""
31 
32     def __init__(self, config: GitConfig):
33         """Initialize GitManager with configuration"""
34         self.config = config
35         self.repo = None
36         self._ensure_repo()
37 
38     def _ensure_repo(self) -> None:
39         """Ensure git repository exists and is properly initialized"""
40         if not os.path.exists(self.config.repo_path):
41             if self.config.remote_url:
42                 self.clone()
43             else:
44                 raise ValueError(
45                     f"Repository path does not exist: {self.config.repo_path}"
46                 )
47         else:
48             try:
49                 self.repo = git.Repo(self.config.repo_path)
50                 # Set auth token for remote operations if provided
51                 if self.config.auth_token and self.config.remote_url:
52                     self._set_remote_with_auth()
53             except git.InvalidGitRepositoryError:
54                 if self.config.remote_url:
55                     self.clone()
56                 else:
57                     raise ValueError(
58                         f"Invalid git repository at: {self.config.repo_path}"
59                     )
60 
61     def _get_url_with_token(self, url: str) -> str:
62         """
63         Insert authentication token into git URL
64 
65         Args:
66             url: Original git URL
67 
68         Returns:
69             URL with authentication token
70         """
71         if not self.config.auth_token:
72             return url
73 
74         parsed = urlparse(url)
75 
76         # Handle different URL formats
77         if parsed.scheme in ["http", "https"]:
78             netloc = f"{self.config.auth_token}@{parsed.netloc}"
79             return urlunparse(
80                 (
81                     parsed.scheme,
82                     netloc,
83                     parsed.path,
84                     parsed.params,
85                     parsed.query,
86                     parsed.fragment,
87                 )
88             )
89         elif "@" in url and ":" in url and url.startswith("git@"):
90             # Handle SSH format: git@github.com:username/repo.git
91             return url  # Don't modify SSH URLs
92         else:
93             return url  # Return original if format is not recognized
94 
95     def _set_remote_with_auth(self) -> None:
96         """Configure remote with authentication token"""
97         if not self.repo or not self.config.auth_token or not self.config.remote_url:
98             return
99 
100         try:
101             # Get current remotes
102             remotes = list(self.repo.remotes)
103             remote_exists = any(
104                 remote.name == self.config.remote_name for remote in remotes
105             )
106 
107             # Prepare URL with token
108             url_with_token = self._get_url_with_token(self.config.remote_url)
109 
110             # Set or update remote
111             if remote_exists:
112                 self.repo.git.remote("set-url", self.config.remote_name, url_with_token)
113             else:
114                 self.repo.git.remote("add", self.config.remote_name, url_with_token)
115 
116             logger.info(
117                 f"Configured remote '{self.config.remote_name}' with authentication"
118             )
119         except git.GitCommandError as e:
120             logger.error(f"Failed to configure remote with authentication: {str(e)}")
121             raise
122 
123     def clone(self) -> None:
124         """
125         Clone the repository specified in config
126 
127         Raises:
128             ValueError: If remote_url is not set in config
129             git.GitCommandError: If clone operation fails
130         """
131         if not self.config.remote_url:
132             raise ValueError("Remote URL must be set to clone a repository")
133 
134         self._clone_repo()
135 
136     def _clone_repo(self, branch: Optional[str] = None) -> None:
137         """
138         Internal method to perform the clone operation
139 
140         Args:
141             branch: Branch to checkout after cloning
142         """
143         try:
144             # Prepare parent directory if it doesn't exist
145             parent_dir = os.path.dirname(self.config.repo_path)
146             if parent_dir and not os.path.exists(parent_dir):
147                 os.makedirs(parent_dir)
148 
149             # Remove target directory if it exists
150             if os.path.exists(self.config.repo_path):
151                 shutil.rmtree(self.config.repo_path)
152 
153             # Prepare URL with token if provided
154             clone_url = self._get_url_with_token(self.config.remote_url)
155 
156             # Clone options
157             clone_args = {
158                 "url": clone_url,
159                 "to_path": self.config.repo_path,
160             }
161 
162             # Add branch if specified
163             if branch:
164                 clone_args["branch"] = branch
165 
166             # Clone the repository
167             self.repo = git.Repo.clone_from(**clone_args)
168 
169             logger.info(f"Successfully cloned repository to {self.config.repo_path}")
170 
171             # Configure remote with auth token if provided
172             if self.config.auth_token:
173                 self._set_remote_with_auth()
174 
175         except git.GitCommandError as e:
176             logger.error(f"Failed to clone repository: {str(e)}")
177             # Clean up if clone failed
178             if os.path.exists(self.config.repo_path):
179                 shutil.rmtree(self.config.repo_path)
180             raise
181 
182     def pull(self, branch: Optional[str] = None) -> None:
183         """
184         Pull changes from remote repository
185 
186         Args:
187             branch: Branch to pull from. If None, pulls current branch
188         """
189         try:
190             if branch:
191                 self.repo.git.pull(self.config.remote_name, branch)
192             else:
193                 self.repo.git.pull()
194             logger.info(
195                 f"Successfully pulled changes from {branch or 'current branch'}"
196             )
197         except git.GitCommandError as e:
198             logger.error(f"Failed to pull changes: {str(e)}")
199             raise
200 
201     def push(
202         self,
203         branch: Optional[str] = None,
204         force: bool = False,
205         set_upstream: bool = True,
206     ) -> None:
207         """
208         Push changes to remote repository
209 
210         Args:
211             branch: Branch to push. If None, pushes current branch
212             force: Whether to force push
213             set_upstream: Whether to set upstream branch if it doesn't exist
214         """
215         try:
216             # 确保远程 URL 包含认证令牌
217             if self.config.auth_token:
218                 self._set_remote_with_auth()
219 
220             # 如果没有指定分支，获取当前分支
221             current_branch = branch or self.get_current_branch()
222 
223             # 执行推送操作
224             if force:
225                 if set_upstream:
226                     self.repo.git.push(
227                         "-f", "--set-upstream", self.config.remote_name, current_branch
228                     )
229                 else:
230                     if branch:
231                         self.repo.git.push("-f", self.config.remote_name, branch)
232                     else:
233                         self.repo.git.push("-f")
234             else:
235                 if set_upstream:
236                     self.repo.git.push(
237                         "--set-upstream", self.config.remote_name, current_branch
238                     )
239                 else:
240                     if branch:
241                         self.repo.git.push(self.config.remote_name, branch)
242                     else:
243                         self.repo.git.push()
244 
245             logger.info(f"Successfully pushed changes to {current_branch}")
246         except git.GitCommandError as e:
247             logger.error(f"Failed to push changes: {str(e)}")
248             raise
249 
250     def create_branch(
251         self, branch_name: str, start_point: Optional[str] = None
252     ) -> None:
253         """
254         Create a new branch
255 
256         Args:
257             branch_name: Name of the new branch
258             start_point: Branch/commit to create branch from. If None, uses current HEAD
259         """
260         try:
261             if start_point:
262                 self.repo.git.branch(branch_name, start_point)
263             else:
264                 self.repo.git.branch(branch_name)
265             logger.info(f"Successfully created branch: {branch_name}")
266         except git.GitCommandError as e:
267             logger.error(f"Failed to create branch: {str(e)}")
268             raise
269 
270     def switch_branch(self, branch_name: str, create: bool = False) -> None:
271         """
272         Switch to specified branch
273 
274         Args:
275             branch_name: Name of the branch to switch to
276             create: Create branch if it doesn't exist
277         """
278         try:
279             if create:
280                 try:
281                     self.repo.git.checkout("-b", branch_name)
282                 except:
283                     self.repo.git.checkout(branch_name)
284             else:
285                 self.repo.git.checkout(branch_name)
286             logger.info(f"Successfully switched to branch: {branch_name}")
287         except git.GitCommandError as e:
288             logger.error(f"Failed to switch branch: {str(e)}")
289             raise
290 
291     def delete_branch(self, branch_name: str, force: bool = False) -> None:
292         """
293         Delete specified branch
294 
295         Args:
296             branch_name: Name of the branch to delete
297             force: Force delete even if branch not fully merged
298         """
299         try:
300             if force:
301                 self.repo.git.branch("-D", branch_name)
302             else:
303                 self.repo.git.branch("-d", branch_name)
304             logger.info(f"Successfully deleted branch: {branch_name}")
305         except git.GitCommandError as e:
306             logger.error(f"Failed to delete branch: {str(e)}")
307             raise
308 
309     def get_current_branch(self) -> str:
310         """Get name of current branch"""
311         return self.repo.active_branch.name
312 
313     def list_branches(self, remote: bool = False) -> List[str]:
314         """
315         List all branches
316 
317         Args:
318             remote: Whether to list remote branches instead of local
319 
320         Returns:
321             List of branch names
322         """
323         if remote:
324             return [ref.name for ref in self.repo.remote().refs]
325         return [branch.name for branch in self.repo.heads]
326 
327     def get_current_commit_id(self) -> str:
328         """获取当前提交的 ID"""
329         try:
330             return self.repo.head.commit.hexsha
331         except Exception as e:
332             logger.error(f"获取当前提交 ID 失败: {str(e)}")
333             return ""
334 
335     def get_changed_files(self, old_commit: str, new_commit: str) -> List[str]:
336         """
337         获取两个提交之间变更的文件列表
338 
339         Args:
340             old_commit: 旧提交的 ID
341             new_commit: 新提交的 ID
342 
343         Returns:
344             变更的文件路径列表
345         """
346         try:
347             # 获取提交对象
348             old = self.repo.commit(old_commit)
349             new = self.repo.commit(new_commit)
350 
351             # 获取差异
352             diff_index = old.diff(new)
353 
354             # 收集所有变更的文件
355             changed_files = set()
356 
357             # 添加修改的文件
358             for diff in diff_index.iter_change_type("M"):
359                 if not self.is_ignore(diff.a_path):
360                     changed_files.add(diff.a_path)
361 
362             # 添加增加的文件
363             for diff in diff_index.iter_change_type("A"):
364                 if not self.is_ignore(diff.b_path):
365                     changed_files.add(diff.b_path)
366 
367             # 添加删除的文件
368             for diff in diff_index.iter_change_type("D"):
369                 if not self.is_ignore(diff.b_path):
370                     changed_files.add(diff.a_path)
371 
372             return list(changed_files)
373         except Exception as e:
374             logger.error(f"获取变更文件列表失败: {str(e)}")
375             return []
376 
377     def is_ignore(self, path: str) -> bool:
378         # 检查文件名是否以点开头
379         file_name = os.path.basename(path)
380         if file_name.startswith("."):
381             return True
382         # 检查路径中是否包含以点开头的目录
383         path_parts = path.split(os.path.sep)
384         for part in path_parts:
385             # 跳过空字符串（可能出现在路径开头）
386             if not part:
387                 continue
388             # 如果目录名以点开头，则忽略
389             if part.startswith("."):
390                 return True
391 
392         # 如果不满足任何忽略条件，则不忽略
393         return False
394 
395     def delete_local_repository(self, remove_git_config: bool = False) -> None:
396         """
397         删除本地代码仓库和可选的全局 git 配置
398 
399         Args:
400             remove_git_config: 是否同时删除与此仓库相关的全局 git 配置
401 
402         Raises:
403             ValueError: 如果仓库路径不存在
404             OSError: 如果删除操作失败
405         """
406         if not os.path.exists(self.config.repo_path):
407             logger.warning(f"仓库路径不存在，无需删除: {self.config.repo_path}")
408             return
409 
410         try:
411             # 关闭仓库连接以释放文件锁
412             if self.repo:
413                 self.repo.close()
414                 self.repo = None
415 
416             # 删除本地仓库目录
417             shutil.rmtree(self.config.repo_path)
418             logger.info(f"成功删除本地仓库: {self.config.repo_path}")
419 
420             # 可选：删除全局 git 配置中与此仓库相关的条目
421             if remove_git_config:
422                 self._remove_git_config()
423 
424         except (OSError, shutil.Error) as e:
425             logger.error(f"删除本地仓库失败: {str(e)}")
426             raise
427 
428     def _remove_git_config(self) -> None:
429         """
430         从全局 git 配置中删除与当前仓库相关的配置
431 
432         这包括：
433         - 与远程仓库 URL 相关的凭证
434         - 特定于此仓库的用户配置
435         """
436         try:
437             # 获取仓库的规范路径
438             repo_path = os.path.abspath(self.config.repo_path)
439             repo_name = os.path.basename(repo_path)
440 
441             # 尝试从 git 配置中删除与此仓库相关的条目
442             if self.config.remote_url:
443                 # 解析远程 URL 以获取主机名
444                 parsed = urlparse(self.config.remote_url)
445                 if parsed.netloc:
446                     # 尝试删除凭证
447                     try:
448                         git.cmd.Git().execute(
449                             ["git", "credential", "reject"],
450                             input=f"url={self.config.remote_url}\n\n",
451                         )
452                         logger.info(f"已尝试从凭证存储中删除 {parsed.netloc} 的凭证")
453                     except git.GitCommandError:
454                         logger.debug("凭证删除操作未成功，可能没有存储凭证")
455 
456             # 尝试删除仓库特定的配置（如果有）
457             try:
458                 git.cmd.Git().execute(
459                     [
460                         "git",
461                         "config",
462                         "--global",
463                         "--remove-section",
464                         f"remote.{repo_name}",
465                     ]
466                 )
467                 logger.info(f"已删除全局 git 配置中的 remote.{repo_name} 部分")
468             except git.GitCommandError:
469                 logger.debug(f"全局配置中没有 remote.{repo_name} 部分")
470 
471             logger.info("已完成 git 配置清理")
472 
473         except Exception as e:
474             logger.warning(f"清理 git 配置时出错: {str(e)}")
475             # 不抛出异常，因为这是次要操作
476 
477     def add_issue_comment(self, issue_number: int, comment_text: str) -> bool:
478         """
479         在 GitHub 仓库的指定 Issue 下添加评论
480 
481         Args:
482             issue_number: Issue 编号
483             comment_text: 评论内容
484 
485         Returns:
486             bool: 操作是否成功
487 
488         Raises:
489             ValueError: 如果未配置认证令牌或远程 URL
490             Exception: 如果添加评论过程中发生其他错误
491         """
492         try:
493             # 检查必要的配置
494             if not self.config.auth_token:
495                 raise ValueError("添加 Issue 评论需要认证令牌 (auth_token)")
496 
497             if not self.config.remote_url:
498                 raise ValueError("添加 Issue 评论需要远程仓库 URL (remote_url)")
499 
500             # 导入 PyGithub
501             try:
502                 from github import Github
503             except ImportError:
504                 raise ImportError("添加 Issue 评论需要安装 PyGithub 库: pip install PyGithub")
505 
506             # 解析仓库所有者和名称
507             parsed_url = urlparse(self.config.remote_url)
508             path_parts = parsed_url.path.strip("/").split("/")
509 
510             if len(path_parts) < 2 or not all(path_parts[:2]):
511                 raise ValueError(f"无法从 URL 解析仓库所有者和名称: {self.config.remote_url}")
512 
513             owner = path_parts[0]
514             repo_name = path_parts[1]
515             if repo_name.endswith(".git"):
516                 repo_name = repo_name[:-4]  # 移除 .git 后缀
517 
518             # 初始化 GitHub 客户端
519             g = Github(self.config.auth_token)
520 
521             # 获取仓库和 Issue
522             repo = g.get_repo(f"{owner}/{repo_name}")
523             issue = repo.get_issue(issue_number)
524 
525             # 添加评论
526             comment = issue.create_comment(comment_text)
527 
528             logger.info(f"成功在 Issue #{issue_number} 下添加评论 (ID: {comment.id})")
529             return True
530 
531         except Exception as e:
532             logger.error(f"添加 Issue 评论失败: {str(e)}")
533             raise
534 
535     def commit(
536         self, message: str, add_all: bool = True, files: Optional[List[str]] = None
537     ) -> str:
538         """
539         创建一个新的提交
540 
541         Args:
542             message: 提交信息
543             add_all: 是否添加所有变更的文件，默认为 True
544             files: 要添加的特定文件列表，如果 add_all 为 True 则忽略此参数
545 
546         Returns:
547             str: 新提交的 SHA 哈希值
548 
549         Raises:
550             git.GitCommandError: 如果 Git 操作失败
551         """
552         try:
553             # 添加文件到暂存区
554             if add_all:
555                 self.repo.git.add(A=True)
556             elif files:
557                 for file in files:
558                     self.repo.git.add(file)
559 
560             # 创建提交
561             commit = self.repo.index.commit(message)
562             logger.info(f"成功创建提交: {commit.hexsha[:7]} - {message}")
563 
564             return commit.hexsha
565         except git.GitCommandError as e:
566             logger.error(f"创建提交失败: {str(e)}")
567             raise
568 
569     def reset_to(self, target_branch: str) -> bool:
570         """
571         将当前分支重置到远程目标分支的状态
572 
573         Args:
574             target_branch: 目标分支名称
575 
576         Returns:
577             bool: 操作是否成功
578         """
579         try:
580             # 获取远程分支
581             remote_branches = self.list_branches(remote=True)
582 
583             # 检查目标分支是否存在于远端
584             if target_branch not in remote_branches:
585                 logger.warning(f"目标分支 {target_branch} 不存在于远端")
586                 return False
587             
588             # 切换到目标分支，如果不存在则创建
589             logger.info(f"切换到分支: {target_branch}")
590             self.switch_branch(target_branch, create=True)
591             
592             # 拉取最新代码
593             logger.info(f"拉取远程分支: {target_branch} 的最新代码")
594             self.pull()
595             
596             # 强制重置到远程分支状态
597             remote_name = self.config.remote_name
598             logger.info(f"重置到远程分支: {remote_name}/{target_branch}")
599             self.repo.git.reset(f"{remote_name}/{target_branch}", hard=True)
600 
601             logger.info(f"成功重置到版本: {target_branch}")
602             return True
603         except git.GitCommandError as e:
604             logger.error(f"重置到分支 {target_branch} 失败: {str(e)}")
605             return False
606         except Exception as e:
607             logger.error(f"重置过程中发生未知错误: {str(e)}")
608             return False
609 
610     def reset_to_issue_branch(self, issue_id: int) -> str:
611         """
612         拉取指定issue对应的最新分支并切换到该分支
613         如果该issue还未创建过分支，则切换到默认分支
614 
615         Args:
616             issue_id: Issue编号
617 
618         Returns:
619             str: 成功切换到的分支名称
620 
621         Raises:
622             git.GitCommandError: 如果Git操作失败
623         """
624         try:
625             # 确保远程仓库信息是最新的
626             self.repo.git.fetch(self.config.remote_name)
627             logger.info(f"成功获取远程仓库信息")
628 
629             # 获取所有远程分支
630             remote_branches = self.repo.git.branch("-r").splitlines()
631             remote_branches = [branch.strip() for branch in remote_branches]
632 
633             # 查找与指定issue相关的分支
634             issue_branches = []
635             for branch in remote_branches:
636                 # 移除远程名称前缀
637                 branch_name = branch.split("/", 1)[-1] if "/" in branch else branch
638                 # 检查是否是该issue的分支
639                 if f"bella-bot-issues-{issue_id}-" in branch_name:
640                     issue_branches.append(branch_name)
641             remote_name = self.config.remote_name
642             if issue_branches:
643                 # 按照轮次排序，获取最新的分支
644                 issue_branches.sort(key=lambda x: int(x.split("-")[-1]) if x.split("-")[-1].isdigit() else 0, reverse=True)
645                 latest_branch = issue_branches[0]
646                 # 切换到最新分支
647                 self.switch_branch(latest_branch, create=True)
648                 self.pull()
649                 logger.info(f"重置到远程分支: {remote_name}/{latest_branch}")
650                 self.repo.git.reset(f"{remote_name}/{latest_branch}", hard=True)
651                 logger.info(f"成功切换到issue #{issue_id}的最新分支: {latest_branch}")
652                 return latest_branch
653             else:
654                 # 如果没有找到相关分支，切换到默认分支
655                 self.switch_branch(self.config.default_branch)
656                 self.pull()
657                 logger.info(f"重置到远程分支: {remote_name}/{self.config.default_branch}")
658                 self.repo.git.reset(f"{remote_name}/{self.config.default_branch}", hard=True)
659                 logger.info(f"未找到issue #{issue_id}的分支，已切换到默认分支: {self.config.default_branch}")
660                 return self.config.default_branch
661         except git.GitCommandError as e:
662             logger.error(f"切换到issue分支时出错: {str(e)}")
663             raise
664
```




```
File: client/cli.py
1 """
2 Command-line interface for the WorkflowEngine.
3 Provides functionality to parse command-line arguments and run the engine.
4 """
5 
6 import argparse
7 import os
8 import sys
9 from typing import Optional, Dict, Any
10 
11 
12 def parse_args() -> argparse.Namespace:
13     """Parse command-line arguments for the WorkflowEngine."""
14     parser = argparse.ArgumentParser(
15         description="Run the WorkflowEngine to process user requirements"
16     )
17 
18     # Required arguments
19     parser.add_argument(
20         "--project-dir", 
21         type=str, 
22         default=os.path.abspath(os.getcwd()),
23         help="Path to the project directory (default: current directory)"
24     )
25     parser.add_argument(
26         "--issue-id", 
27         type=int, 
28         required=True,
29         help="The ID of the issue being processed"
30     )
31     parser.add_argument(
32         "--requirement", 
33         type=str, 
34         help="The user requirement text"
35     )
36     parser.add_argument(
37         "--requirement-file", 
38         type=str, 
39         help="Path to file containing the user requirement"
40     )
41 
42     # Optional arguments for WorkflowEngineConfig
43     parser.add_argument(
44         "--core-model", 
45         type=str, 
46         default="gpt-4o",
47         help="Model to use for core AI operations"
48     )
49     parser.add_argument(
50         "--data-model", 
51         type=str, 
52         default="gpt-4o",
53         help="Model to use for data operations"
54     )
55     parser.add_argument(
56         "--core-temperature", 
57         type=float, 
58         default=0.7,
59         help="Temperature for core model"
60     )
61     parser.add_argument(
62         "--data-temperature", 
63         type=float, 
64         default=0.7,
65         help="Temperature for data model"
66     )
67     parser.add_argument(
68         "--max-retry", 
69         type=int, 
70         default=3,
71         help="Maximum number of retry attempts"
72     )
73     parser.add_argument(
74         "--default-branch", 
75         type=str, 
76         default="main",
77         help="Default branch name"
78     )
79     parser.add_argument(
80         "--mode", 
81         type=str, 
82         choices=["client", "bot"],
83         default="client",
84         help="Operation mode: 'client' or 'bot'"
85     )
86     parser.add_argument(
87         "--base-url", 
88         type=str, 
89         help="Base URL for API calls"
90     )
91     parser.add_argument(
92         "--api-key", 
93         type=str, 
94         help="API key for authentication"
95     )
96     parser.add_argument(
97         "--github-remote-url", 
98         type=str, 
99         help="GitHub remote repository URL"
100     )
101     parser.add_argument(
102         "--github-token", 
103         type=str, 
104         help="GitHub authentication token"
105     )
106     
107     return parser.parse_args()
108 
109 
110 def get_requirement_text(args: argparse.Namespace) -> Optional[str]:
111     """Get requirement text from arguments or file."""
112     if args.requirement:
113         return args.requirement
114     elif args.requirement_file:
115         try:
116             with open(args.requirement_file, 'r', encoding='utf-8') as file:
117                 return file.read()
118         except IOError as e:
119             print(f"Error reading requirement file: {e}", file=sys.stderr)
120             return None
121     else:
122         print("No requirement specified. Use --requirement or --requirement-file", file=sys.stderr)
123         return None
124 
125 
126 def build_config_from_args(args: argparse.Namespace) -> Dict[str, Any]:
127     """Build WorkflowEngineConfig parameters from command line arguments."""
128     config_params = {
129         "project_dir": args.project_dir,
130         "issue_id": args.issue_id,
131         "core_model": args.core_model,
132         "data_model": args.data_model,
133         "core_template": args.core_temperature,  # Note: using template to match original param name
134         "data_template": args.data_temperature,  # Note: using template to match original param name
135         "max_retry": args.max_retry,
136         "default_branch": args.default_branch,
137         "mode": args.mode,
138     }
139     
140     # Add optional parameters if they're specified
141     if args.base_url:
142         config_params["base_url"] = args.base_url
143     if args.api_key:
144         config_params["api_key"] = args.api_key
145     if args.github_remote_url:
146         config_params["github_remote_url"] = args.github_remote_url
147     if args.github_token:
148         config_params["github_token"] = args.github_token
149         
150     return config_params
151
```




```
File: client/runner.py
1 """
2 Programmatic API for running the WorkflowEngine.
3 Provides a simplified interface for use in Python scripts.
4 """
5 
6 import os
7 from typing import Optional, Dict, Any, Union
8 
9 from dotenv import load_dotenv
10 
11 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
12 
13 
14 def run_workflow(
15     issue_id: int,
16     requirement: str,
17     project_dir: Optional[str] = None,
18     core_model: str = "gpt-4o",
19     data_model: str = "gpt-4o",
20     core_temperature: float = 0.7,
21     data_temperature: float = 0.7,
22     max_retry: int = 3,
23     default_branch: str = "main",
24     mode: str = "client",
25     base_url: Optional[str] = None,
26     api_key: Optional[str] = None,
27     github_remote_url: Optional[str] = None,
28     github_token: Optional[str] = None,
29     **kwargs: Dict[str, Any]
30 ) -> None:
31     """Run the WorkflowEngine with the given configuration."""
32     # Load environment variables
33     load_dotenv()
34     
35     # Use current directory if no project_dir specified
36     if project_dir is None:
37         project_dir = os.getcwd()
38     
39     # Create config with provided parameters
40     config = WorkflowEngineConfig(
41         project_dir=project_dir, issue_id=issue_id, core_model=core_model,
42         data_model=data_model, core_template=core_temperature, data_template=data_temperature,
43         max_retry=max_retry, default_branch=default_branch, mode=mode,
44         base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
45         github_token=github_token, **kwargs
46     )
47     
48     # Run the workflow engine
49     engine = WorkflowEngine(config)
50     engine.process_requirement(requirement)
51
```




```
File: client/terminal.py
1 """
2 Terminal entrypoint for the WorkflowEngine.
3 Provides functionality to run the engine from terminal with command-line arguments.
4 """
5 import logging
6 import os
7 import sys
8 from dotenv import load_dotenv
9 
10 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
11 from client.cli import parse_args, get_requirement_text, build_config_from_args
12 from log_config import setup_logging
13 
14 
15 def run_workflow_from_terminal():
16     """
17     Main entry point for running the workflow engine from terminal.
18     Parses command line arguments and runs the workflow engine.
19     """
20     # Load environment variables from .env file if present
21     load_dotenv()
22     
23     # Parse command line arguments
24     args = parse_args()
25     
26     # Get requirement text
27     requirement = get_requirement_text(args)
28     if not requirement:
29         sys.exit(1)
30     
31     # Build config from arguments
32     config_params = build_config_from_args(args)
33     
34     # Try to get API key from environment if not provided as argument
35     if "api_key" not in config_params and os.environ.get("OPENAI_API_KEY"):
36         config_params["api_key"] = os.environ.get("OPENAI_API_KEY")
37         
38     # Create the workflow engine config
39     config = WorkflowEngineConfig(**config_params)
40     
41     # Initialize and run the workflow engine
42     engine = WorkflowEngine(config)
43     engine.process_requirement(requirement)
44 
45 
46 if __name__ == "__main__":
47     setup_logging(log_level=logging.INFO)
48     run_workflow_from_terminal()
49
```




```
File: pyproject.toml
1 [tool.poetry]
2 name = "bella-issues-bot"
3 version = "0.1.0"
4 description = ""
5 authors = [""]
6 license = "MIT"
7 readme = "README.md"
8 homepage = ""
9 repository = ""
10 documentation = ""
11 classifiers = [
12   "Development Status :: 4 - Beta",
13   "Topic :: Scientific/Engineering :: Artificial Intelligence",
14 ]
15 
16 [build-system]
17 requires = ["poetry-core>=1.0.0"]
18 build-backend = "poetry.core.masonry.api"
19 
20 [tool.poetry.dependencies]
21 python = ">=3.10,<3.13"
22 gitpython = "^3.1.40"
23 PyGithub = "^2.1.1"
24 langchain = ">=0.3.0,<0.4.0"
25 langchain-openai = ">=0.1.0"
26 langchain-core = ">=0.3.0,<0.4.0"
27 langchain-community = ">=0.3.0,<0.4.0"
28 python-dotenv = "^1.0.0"
29 pydantic = "^2.5.0"
30 openai = "^1.3.5"
31 pytest = "^7.4.0"
32 pathspec = ">=0.9.0"
33 toml = ">=0.10.2"
34 typing-extensions = ">=4.0.0"
35 jinja2 = ">=3.1.0,<4.0.0"
36 colorlog = ">=6.8.0,<7.0.0"
37 colorama = ">=0.4.4"
38 argparse = ">=1.4.0"
39 pyyaml = ">=6.0"
40 
41 [tool.poetry.scripts]
42 bella-issues-bot = 'client.terminal:run_workflow_from_terminal'
43 
44 [tool.ruff]
45 select = ["F", "E", "W", "I001"]
46 show-fixes = false
47 target-version = "py310"
48 task-tags = ["TODO", "FIXME"]
49 extend-ignore = ["E501", "E722"]
50 
51 [tool.black]
52 target-version = ["py310"]
53 
54 [tool.ruff.isort]
55 known-first-party = []
56 known-third-party = []
57 section-order = [
58   "future",
59   "standard-library",
60   "third-party",
61   "first-party",
62   "local-folder",
63 ]
64 combine-as-imports = true
65 split-on-trailing-comma = false
66 lines-between-types = 1
67
```




# 历史执行信息

【round_1】
requirement: 
创建一个 client包，提供终端启动方法，创建WorkflowEngine处理用户需求。WorkflowEngineConfig的参数都可以通过命令行传入。
    使用方式，参照example_workflow.py
agent_response: 
I'll create a client package that provides a command-line interface to create and run the WorkflowEngine with configurable parameters. Let's start by analyzing the requirements and planning our implementation.

First, I'll need to:
1. Create a client package with appropriate structure
2. Implement argument parsing for all WorkflowEngineConfig parameters
3. Create a CLI entry point to run the WorkflowEngine
4. Update pyproject.toml to include the new CLI command

Let's start with the implementation:

```diff
--- /dev/null
+++ client/__init__.py
@@ -0,0 +1 @@
+"""Client package for running the WorkflowEngine from the command line."""
```

```diff
--- /dev/null
+++ client/cli.py
@@ -0,0 +1,142 @@
+"""
+Command-line interface for the WorkflowEngine.
+Provides functionality to parse command-line arguments and run the engine.
+"""
+
+import argparse
+import os
+import sys
+from typing import Optional
+
+from dotenv import load_dotenv
+
+from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
+
+
+def parse_args():
+    """Parse command-line arguments for the WorkflowEngine."""
+    parser = argparse.ArgumentParser(
+        description="Run the WorkflowEngine to process user requirements"
+    )
+
+    # Required arguments
+    parser.add_argument(
+        "--project-dir", 
+        type=str, 
+        default=os.path.abspath(os.path.join(os.path.dirname(__file__), "../.")),
+        help="Path to the project directory"
+    )
+    parser.add_argument(
+        "--issue-id", 
+        type=int, 
+        required=True,
+        help="The ID of the issue being processed"
+    )
+    parser.add_argument(
+        "--requirement", 
+        type=str, 
+        help="The user requirement text"
+    )
+    parser.add_argument(
+        "--requirement-file", 
+        type=str, 
+        help="Path to file containing the user requirement"
+    )
+
+    # Optional arguments for WorkflowEngineConfig
+    parser.add_argument(
+        "--core-model", 
+        type=str, 
+        default="gpt-4o",
+        help="Model to use for core AI operations"
+    )
+    parser.add_argument(
+        "--data-model", 
+        type=str, 
+        default="gpt-4o",
+        help="Model to use for data operations"
+    )
+    parser.add_argument(
+        "--core-temperature", 
+        type=float, 
+        default=0.7,
+        help="Temperature for core model"
+    )
+    parser.add_argument(
+        "--data-temperature", 
+        type=float, 
+        default=0.7,
+        help="Temperature for data model"
+    )
+    parser.add_argument(
+        "--max-retry", 
+        type=int, 
+        default=3,
+        help="Maximum number of retry attempts"
+    )
+    parser.add_argument(
+        "--default-branch", 
+        type=str, 
+        default="main",
+        help="Default branch name"
+    )
+    parser.add_argument(
+        "--mode", 
+        type=str, 
+        choices=["client", "bot"],
+        default="client",
+        help="Operation mode: 'client' or 'bot'"
+    )
+    parser.add_argument(
+        "--base-url", 
+        type=str, 
+        help="Base URL for API calls"
+    )
+    parser.add_argument(
+        "--api-key", 
+        type=str, 
+        help="API key for authentication"
+    )
+    parser.add_argument(
+        "--github-remote-url", 
+        type=str, 
+        help="GitHub remote repository URL"
+    )
+    parser.add_argument(
+        "--github-token", 
+        type=str, 
+        help="GitHub authentication token"
+    )
+    
+    return parser.parse_args()
+
+
+def get_requirement_text(args) -> Optional[str]:
+    """Get requirement text from arguments or file."""
+    if args.requirement:
+        return args.requirement
+    elif args.requirement_file:
+        try:
+            with open(args.requirement_file, 'r', encoding='utf-8') as file:
+                return file.read()
+        except IOError as e:
+            print(f"Error reading requirement file: {e}", file=sys.stderr)
+            return None
+    else:
+        print("No requirement specified. Use --requirement or --requirement-file", file=sys.stderr)
+        return None
+
+
+def main():
+    """Main entry point for the CLI."""
+    # Load environment variables
+    load_dotenv()
+    
+    args = parse_args()
+    
+    # Create WorkflowEngineConfig from arguments
+    config = WorkflowEngineConfig(
+        project_dir=args.project_dir,
+        issue_id=args.issue_id,
+        core_model=args.core_model,
+        data_model=args.data_model,
+        core_template=args.core_temperature,
+        data_template=args.data_temperature,
+        max_retry=args.max_retry,
+        default_branch=args.default_branch,
+        mode=args.mode,
+        base_url=args.base_url or os.getenv("OPENAI_API_BASE"),
+        api_key=args.api_key or os.getenv("OPENAI_API_KEY"),
+        github_remote_url=args.github_remote_url or os.getenv("GITHUB_REMOTE_URL"),
+        github_token=args.github_token or os.getenv("GITHUB_TOKEN")
+    )
+    
+    # Get the requirement text
+    requirement = get_requirement_text(args)
+    if requirement is None:
+        sys.exit(1)
+    
+    # Initialize and run WorkflowEngine
+    workflow_engine = WorkflowEngine(config)
+    workflow_engine.process_requirement(requirement)
+
+
+if __name__ == "__main__":
+    main()
```

```diff
--- /dev/null
+++ client/runner.py
@@ -0,0 +1,44 @@
+"""
+Programmatic API for running the WorkflowEngine.
+Provides a simplified interface for use in Python scripts.
+"""
+
+import os
+from typing import Optional
+
+from dotenv import load_dotenv
+
+from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
+
+
+def run_workflow(
+    issue_id: int,
+    requirement: str,
+    project_dir: Optional[str] = None,
+    core_model: str = "gpt-4o",
+    data_model: str = "gpt-4o",
+    core_temperature: float = 0.7,
+    data_temperature: float = 0.7,
+    **kwargs
+) -> None:
+    """
+    Run the WorkflowEngine with the given configuration.
+    
+    Args:
+        issue_id (int): The ID of the issue to process
+        requirement (str): The requirement text to process
+        project_dir (Optional[str]): Path to the project directory
+        core_model (str): Model name for core operations
+        data_model (str): Model name for data operations
+        core_temperature (float): Temperature for core model
+        data_temperature (float): Temperature for data model
+        **kwargs: Additional parameters for WorkflowEngineConfig
+    """
+    # Load environment variables
+    load_dotenv()
+    
+    if project_dir is None:
+        project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../"))
+    
+    config = WorkflowEngineConfig(project_dir=project_dir, issue_id=issue_id, core_model=core_model,
+                                 data_model=data_model, core_template=core_temperature, data_template=data_temperature, **kwargs)
+    WorkflowEngine(config).process_requirement(requirement)
```

Now let's update the pyproject.toml file to include the CLI command:

```diff
--- pyproject.toml
+++ pyproject.toml
@@ -36,7 +36,7 @@
 colorlog = ">=6.8.0,<7.0.0"
 
 [tool.poetry.scripts]
-bella-issuses-bot = ''
+bella-issues-bot = 'client.cli:main'
 
 [tool.ruff]
 select = ["F", "E", "W", "I001"]
```

Let's create a simple example usage script:

```diff
--- /dev/null
+++ examples/run_from_cli.py
@@ -0,0 +1,18 @@
+"""
+Example showing how to run the workflow using the client runner API.
+"""
+
+from client.runner import run_workflow
+
+# Example requirement
+requirement = """
+Create a simple README file with project description and usage instructions.
+"""
+
+# Run the workflow
+run_workflow(
+    issue_id=7,
+    requirement=requirement,
+    core_temperature=0.8,
+    data_temperature=0.7
+)
```

Let's fix the issue with the WorkflowEngine increment operator:

```diff
--- core/workflow_engine.py
+++ core/workflow_engine.py
@@ -184,7 +184,8 @@
             self.git_manager.push(branch=branch_name, force=True)
             return response
         else:
-            if ++self.CODE_TIMES >= self.config.max_retry:
+            self.CODE_TIMES += 1
+            if self.CODE_TIMES >= self.config.max_retry:
                 logger.error("code workflow超过最大重试次数")
                 return self._run_chat_workflow(user_requirement)
             else:
@@ -218,7 +219,8 @@
             self.git_manager.push(branch=branch_name, force=True)
             return response
         else:
-            if ++self.CHAT_TIMES >= self.config.max_retry:
+            self.CHAT_TIMES += 1
+            if self.CHAT_TIMES >= self.config.max_retry:
                 logger.error("chat workflow超过最大重试次数")
                 return None
             else:
```

Now let's add a README to document how to use the CLI:

```diff
--- /dev/null
+++ client/README.md
@@ -0,0 +1,61 @@
+# Bella Issues Bot Client
+
+This package provides a command-line interface and programmatic API for running the WorkflowEngine to process user requirements.
+
+## Command-Line Usage
+
+You can run the WorkflowEngine from the command line using the `bella-issues-bot` command. Here's an example:
+
+```bash
+bella-issues-bot --issue-id 42 --requirement "Create a README file for the project."
+```
+
+### Command-Line Arguments
+
+The following arguments are supported:
+
+#### Required Arguments
+- `--issue-id`: The ID of the issue being processed
+- One of:
+  - `--requirement`: The user requirement text
+  - `--requirement-file`: Path to a file containing the user requirement
+
+#### Optional Arguments
+- `--project-dir`: Path to the project directory (default: current directory)
+- `--core-model`: Model to use for core AI operations (default: gpt-4o)
+- `--data-model`: Model to use for data operations (default: gpt-4o)
+- `--core-temperature`: Temperature for core model (default: 0.7)
+- `--data-temperature`: Temperature for data model (default: 0.7)
+- `--max-retry`: Maximum number of retry attempts (default: 3)
+- `--default-branch`: Default branch name (default: main)
+- `--mode`: Operation mode: 'client' or 'bot' (default: client)
+- `--base-url`: Base URL for API calls
+- `--api-key`: API key for authentication
+- `--github-remote-url`: GitHub remote repository URL
+- `--github-token`: GitHub authentication token
+
+## Programmatic API
+
+You can also use the client package programmatically in your Python code:
+
+```python
+from client.runner import run_workflow
+
+run_workflow(
+    issue_id=42,
+    requirement="Create a README file for the project.",
+    core_model="gpt-4o",
+    data_model="gpt-4o",
+    core_temperature=0.7,
+    data_temperature=0.7
+)
+```
+
+## Environment Variables
+
+The client package will read the following environment variables if not specified as command-line arguments:
+
+- `OPENAI_API_KEY`: API key for OpenAI
+- `OPENAI_API_BASE`: Base URL for OpenAI API
+- `GITHUB_REMOTE_URL`: GitHub remote repository URL
+- `GITHUB_TOKEN`: GitHub authentication token
```

Let's create a simple shell script to make it easier to run the CLI:

```diff
--- /dev/null
+++ scripts/run_bot.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+# Script to run the bella-issues-bot CLI with basic parameters
+
+# Check if issue-id is provided
+if [ -z "$1" ]; then
+    echo "Usage: $0 <issue-id> [requirement-file]"
+    exit 1
+fi
+
+python -m client.cli --issue-id "$1" ${2:+--requirement-file "$2"}
```

This concludes a fully working implementation. I've created:

1. A client package with:
   - CLI module for command-line interface
   - Runner module for programmatic API
   - README with documentation

2. Updated pyproject.toml to include the CLI script

3. Fixed bugs in WorkflowEngine (increment operations)

4. Added example usage scripts and helper shell script

The implementation allows users to create and run WorkflowEngine instances from the command line with all WorkflowEngineConfig parameters configurable via command-line arguments or environment variables. The code follows the pattern shown in example_workflow.py but provides much more flexibility in configuration.

【round_2】
requirement: 
你的改动没有生效重新改
agent_response: 
I'll review the issue and implement a proper client package with a terminal launch method for the WorkflowEngine. Let me start from scratch to ensure the changes work correctly.

First, I'll analyze what we need:

1. Create a client package that provides terminal startup methods
2. Enable WorkflowEngineConfig parameters to be passed through command line
3. Follow the usage pattern from example_workflow.py

Let's implement this properly:

```diff
--- /dev/null
+++ client/__init__.py
@@ -0,0 +1,1 @@
+"""Client package for running the WorkflowEngine from the terminal."""
```

```diff
--- /dev/null
+++ client/cli.py
@@ -0,0 +1,131 @@
+"""
+Command-line interface for the WorkflowEngine.
+Provides functionality to parse command-line arguments and run the engine.
+"""
+
+import argparse
+import os
+import sys
+from typing import Optional, Dict, Any
+
+from dotenv import load_dotenv
+
+from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
+
+
+def parse_args() -> argparse.Namespace:
+    """Parse command-line arguments for the WorkflowEngine."""
+    parser = argparse.ArgumentParser(
+        description="Run the WorkflowEngine to process user requirements"
+    )
+
+    # Required arguments
+    parser.add_argument(
+        "--project-dir", 
+        type=str, 
+        default=os.path.abspath(os.getcwd()),
+        help="Path to the project directory (default: current directory)"
+    )
+    parser.add_argument(
+        "--issue-id", 
+        type=int, 
+        required=True,
+        help="The ID of the issue being processed"
+    )
+    parser.add_argument(
+        "--requirement", 
+        type=str, 
+        help="The user requirement text"
+    )
+    parser.add_argument(
+        "--requirement-file", 
+        type=str, 
+        help="Path to file containing the user requirement"
+    )
+
+    # Optional arguments for WorkflowEngineConfig
+    parser.add_argument(
+        "--core-model", 
+        type=str, 
+        default="gpt-4o",
+        help="Model to use for core AI operations"
+    )
+    parser.add_argument(
+        "--data-model", 
+        type=str, 
+        default="gpt-4o",
+        help="Model to use for data operations"
+    )
+    parser.add_argument(
+        "--core-temperature", 
+        type=float, 
+        default=0.7,
+        help="Temperature for core model"
+    )
+    parser.add_argument(
+        "--data-temperature", 
+        type=float, 
+        default=0.7,
+        help="Temperature for data model"
+    )
+    parser.add_argument(
+        "--max-retry", 
+        type=int, 
+        default=3,
+        help="Maximum number of retry attempts"
+    )
+    parser.add_argument(
+        "--default-branch", 
+        type=str, 
+        default="main",
+        help="Default branch name"
+    )
+    parser.add_argument(
+        "--mode", 
+        type=str, 
+        choices=["client", "bot"],
+        default="client",
+        help="Operation mode: 'client' or 'bot'"
+    )
+    parser.add_argument(
+        "--base-url", 
+        type=str, 
+        help="Base URL for API calls"
+    )
+    parser.add_argument(
+        "--api-key", 
+        type=str, 
+        help="API key for authentication"
+    )
+    parser.add_argument(
+        "--github-remote-url", 
+        type=str, 
+        help="GitHub remote repository URL"
+    )
+    parser.add_argument(
+        "--github-token", 
+        type=str, 
+        help="GitHub authentication token"
+    )
+    
+    return parser.parse_args()
+
+
+def get_requirement_text(args: argparse.Namespace) -> Optional[str]:
+    """Get requirement text from arguments or file."""
+    if args.requirement:
+        return args.requirement
+    elif args.requirement_file:
+        try:
+            with open(args.requirement_file, 'r', encoding='utf-8') as file:
+                return file.read()
+        except IOError as e:
+            print(f"Error reading requirement file: {e}", file=sys.stderr)
+            return None
+    else:
+        print("No requirement specified. Use --requirement or --requirement-file", file=sys.stderr)
+        return None
+
+
+def build_config_from_args(args: argparse.Namespace) -> Dict[str, Any]:
+    """Build WorkflowEngineConfig parameters from command line arguments."""
+    config_params = {
+        "project_dir": args.project_dir,
+        "issue_id": args.issue_id,
+        "core_model": args.core_model,
+        "data_model": args.data_model,
+        "core_template": args.core_temperature,  # Note: using template to match original param name
+        "data_template": args.data_temperature,  # Note: using template to match original param name
+        "max_retry": args.max_retry,
+        "default_branch": args.default_branch,
+        "mode": args.mode,
+    }
+    
+    # Add optional parameters if they're specified
+    if args.base_url:
+        config_params["base_url"] = args.base_url
+    if args.api_key:
+        config_params["api_key"] = args.api_key
+    if args.github_remote_url:
+        config_params["github_remote_url"] = args.github_remote_url
+    if args.github_token:
+        config_params["github_token"] = args.github_token
+        
+    return config_params
```

```diff
--- /dev/null
+++ client/terminal.py
@@ -0,0 +1,45 @@
+"""
+Terminal entrypoint for the WorkflowEngine.
+Provides functionality to run the engine from terminal with command-line arguments.
+"""
+
+import os
+import sys
+from dotenv import load_dotenv
+
+from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
+from client.cli import parse_args, get_requirement_text, build_config_from_args
+
+
+def run_workflow_from_terminal():
+    """
+    Main entry point for running the workflow engine from terminal.
+    Parses command line arguments and runs the workflow engine.
+    """
+    # Load environment variables from .env file if present
+    load_dotenv()
+    
+    # Parse command line arguments
+    args = parse_args()
+    
+    # Get requirement text
+    requirement = get_requirement_text(args)
+    if not requirement:
+        sys.exit(1)
+    
+    # Build config from arguments
+    config_params = build_config_from_args(args)
+    
+    # Try to get API key from environment if not provided as argument
+    if "api_key" not in config_params and os.environ.get("OPENAI_API_KEY"):
+        config_params["api_key"] = os.environ.get("OPENAI_API_KEY")
+        
+    # Create the workflow engine config
+    config = WorkflowEngineConfig(**config_params)
+    
+    # Initialize and run the workflow engine
+    engine = WorkflowEngine(config)
+    engine.process_requirement(requirement)
+
+
+if __name__ == "__main__":
+    run_workflow_from_terminal()
```

```diff
--- /dev/null
+++ client/runner.py
@@ -0,0 +1,46 @@
+"""
+Programmatic API for running the WorkflowEngine.
+Provides a simplified interface for use in Python scripts.
+"""
+
+import os
+from typing import Optional, Dict, Any, Union
+
+from dotenv import load_dotenv
+
+from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
+
+
+def run_workflow(
+    issue_id: int,
+    requirement: str,
+    project_dir: Optional[str] = None,
+    core_model: str = "gpt-4o",
+    data_model: str = "gpt-4o",
+    core_temperature: float = 0.7,
+    data_temperature: float = 0.7,
+    max_retry: int = 3,
+    default_branch: str = "main",
+    mode: str = "client",
+    base_url: Optional[str] = None,
+    api_key: Optional[str] = None,
+    github_remote_url: Optional[str] = None,
+    github_token: Optional[str] = None,
+    **kwargs: Dict[str, Any]
+) -> None:
+    """Run the WorkflowEngine with the given configuration."""
+    # Load environment variables
+    load_dotenv()
+    
+    # Use current directory if no project_dir specified
+    if project_dir is None:
+        project_dir = os.getcwd()
+    
+    # Create config with provided parameters
+    config = WorkflowEngineConfig(
+        project_dir=project_dir, issue_id=issue_id, core_model=core_model,
+        data_model=data_model, core_template=core_temperature, data_template=data_temperature,
+        max_retry=max_retry, default_branch=default_branch, mode=mode,
+        base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
+        github_token=github_token, **kwargs
+    )
+    
+    # Run the workflow engine
+    engine = WorkflowEngine(config)
+    engine.process_requirement(requirement)
```

Now let's create an example file that shows the usage pattern:

```diff
--- /dev/null
+++ examples/example_terminal.py
@@ -0,0 +1,23 @@
+"""
+Example showing how to run the workflow from both terminal and programmatically.
+
+To run from terminal:
+python -m client.terminal --issue-id 42 --requirement "Create a README file"
+
+Or programmatically as shown below:
+"""
+
+from client.runner import run_workflow
+
+
+def example_run():
+    """Example of running the workflow programmatically."""
+    requirement = """
+    Create a simple README file with project description and setup instructions.
+    """
+    
+    run_workflow(issue_id=42, requirement=requirement)
+
+
+if __name__ == "__main__":
+    example_run()
```

Now, let's update the pyproject.toml to include our new CLI entry point:

```diff
--- pyproject.toml
+++ pyproject.toml
@@ -36,7 +36,7 @@
 colorlog = ">=6.8.0,<7.0.0"
 
 [tool.poetry.scripts]
-bella-issuses-bot = ''
+bella-issues-bot = 'client.terminal:run_workflow_from_terminal'
 
 [tool.ruff]
 select = ["F", "E", "W", "I001"]
```

Finally, let's create a simple README for the client package:

```diff
--- /dev/null
+++ client/README.md
@@ -0,0 +1,59 @@
+# Workflow Client
+
+A command-line interface and programmatic API for running the WorkflowEngine to process user requirements.
+
+## Command-Line Usage
+
+You can run the WorkflowEngine from the command line in two ways:
+
+### Using the installed CLI command
+
+```bash
+bella-issues-bot --issue-id 42 --requirement "Create a README file"
+```
+
+### Using the Python module directly
+
+```bash
+python -m client.terminal --issue-id 42 --requirement "Create a README file"
+```
+
+### Command-Line Arguments
+
+- `--issue-id`: (Required) The ID of the issue being processed
+- `--requirement` or `--requirement-file`: (Required) The user requirement text or path to file containing it
+- `--project-dir`: Path to the project directory (default: current directory)
+- `--core-model`: Model name for core operations (default: gpt-4o)
+- `--data-model`: Model name for data operations (default: gpt-4o)
+- `--core-temperature`: Temperature for core model (default: 0.7)
+- `--data-temperature`: Temperature for data model (default: 0.7)
+- `--max-retry`: Maximum retries (default: 3)
+- `--default-branch`: Default git branch (default: main)
+- `--mode`: Operation mode: client or bot (default: client)
+- `--base-url`: Base URL for API calls
+- `--api-key`: API key (can also be set via OPENAI_API_KEY environment variable)
+- `--github-remote-url`: GitHub remote URL
+- `--github-token`: GitHub token
+
+## Programmatic Usage
+
+You can also use the client package programmatically in your Python code:
+
+```python
+from client.runner import run_workflow
+
+run_workflow(
+    issue_id=42,
+    requirement="Create a README file for the project",
+    core_model="gpt-4o",
+    data_model="gpt-4o",
+    core_temperature=0.7,
+    data_temperature=0.7
+)
+```
+
+## Environment Variables
+
+- `OPENAI_API_KEY`: API key for OpenAI
+- `OPENAI_API_BASE`: Base URL for OpenAI API
+- `GITHUB_TOKEN`: GitHub authentication token
```

Let's also create a requirements.txt file for the client package:

```diff
--- /dev/null
+++ requirements.txt
@@ -0,0 +1,5 @@
+openai>=1.0.0
+python-dotenv>=0.19.0
+colorama>=0.4.4
+argparse>=1.4.0
+pyyaml>=6.0
```

This concludes a fully working implementation. I've created a complete client package with:

1. A CLI interface that can be used from terminal
2. A programmatic API for use in Python scripts
3. Complete parsing of command-line arguments for all WorkflowEngineConfig parameters
4. Example usage showing how to run the engine from both terminal and programmatically
5. An entry point registered in pyproject.toml for easy CLI access
6. Documentation in README.md explaining how to use the client package

This implementation should now correctly provide terminal launch methods for the WorkflowEngine while ensuring that all WorkflowEngineConfig parameters can be passed via command line arguments.

【round_3】
requirement: 
把两个read.me 写清楚，分别介绍这个项目和cli启动方式。使用中文。
agent_response: 
我理解需求是要完善两个README.md文件（项目根目录的README.md和client/README.md），用中文清晰地介绍项目和CLI启动方式。根据提供的文件信息，我将为这两个文件编写内容。

以下是我为两个README.md文件准备的内容：

### 项目根目录 README.md:

```markdown
# bella-issues-bot

## 项目简介

bella-issues-bot 是一个基于人工智能的代码开发助手，能够根据用户需求自动分析、生成和修改代码。该工具通过对项目结构的深入理解，可以帮助开发者快速实现功能需求，提高开发效率。

## 主要功能

- 需求分析：自动理解和分解用户的功能需求
- 代码生成：根据需求生成符合项目风格的代码
- 版本管理：与Git集成，支持分支创建和代码提交
- GitHub集成：支持与GitHub仓库交互

## 安装方法

使用pip安装：

```bash
pip install bella-issues-bot
```

## 使用方法

bella-issues-bot 提供了命令行界面和编程API两种使用方式：

### 命令行使用

```bash
bella-issues-bot --issue-id <问题ID> --requirement "你的需求描述"
```

更多高级选项和详细使用说明，请参考[客户端文档](./client/README.md)。

### 编程API使用

```python
from client.runner import run_workflow

run_workflow(
    issue_id=42,
    requirement="创建一个简单的README文件",
    core_temperature=0.7
)
```

## 配置环境变量

工具会读取以下环境变量：

- `OPENAI_API_KEY`: OpenAI API密钥
- `OPENAI_API_BASE`: OpenAI API基础URL
- `GITHUB_REMOTE_URL`: GitHub远程仓库URL
- `GITHUB_TOKEN`: GitHub身份验证令牌

## 示例

可以在[examples](./examples/)目录下找到使用示例。
```

### client/README.md:

```markdown
# Workflow 客户端

一个用于运行WorkflowEngine处理用户需求的命令行接口和编程API。

## 命令行使用方式

你可以通过以下两种方式从命令行运行WorkflowEngine：

### 使用安装后的CLI命令

```bash
bella-issues-bot --issue-id 42 --requirement "创建一个README文件"
```

### 直接使用Python模块

```bash
python -m client.terminal --issue-id 42 --requirement "创建一个README文件"
```

### 命令行参数

- `--issue-id`：（必需）正在处理的问题ID
- `--requirement` 或 `--requirement-file`：（必需）用户需求文本或包含需求的文件路径
- `--project-dir`：项目目录路径（默认：当前目录）
- `--core-model`：核心AI操作使用的模型（默认：gpt-4o）
- `--data-model`：数据操作使用的模型（默认：gpt-4o）
- `--core-temperature`：核心模型的温度参数（默认：0.7）
- `--data-temperature`：数据模型的温度参数（默认：0.7）
- `--max-retry`：最大重试次数（默认：3）
- `--default-branch`：默认Git分支（默认：main）
- `--mode`：操作模式：client或bot（默认：client）
- `--base-url`：API调用的基础URL
- `--api-key`：API密钥（也可以通过OPENAI_API_KEY环境变量设置）
- `--github-remote-url`：GitHub远程URL
- `--github-token`：GitHub令牌

### 简易脚本使用

你也可以使用提供的脚本简化命令行调用：

```bash
./scripts/run_bot.sh <问题ID> [需求文件路径]
```

## 编程方式使用

你也可以在Python代码中以编程方式使用客户端包：

```python
from client.runner import run_workflow

run_workflow(
    issue_id=42,
    requirement="为项目创建一个README文件",
    core_model="gpt-4o",
    data_model="gpt-4o",
    core_temperature=0.7,
    data_temperature=0.7
)
```

## 环境变量

工具会读取以下环境变量：

- `OPENAI_API_KEY`：OpenAI的API密钥
- `OPENAI_API_BASE`：OpenAI API的基础URL
- `GITHUB_TOKEN`：GitHub身份验证令牌
```

这两个README文件分别介绍了项目的整体情况和命令行工具的具体使用方法，使用中文编写，便于中文用户理解和使用。

【round_4】
requirement: 
修改一下read.me，要详细介绍一下既能作为日常辅助编码工具，也能通过Github工作流集成到github repo上使用，只要有人提issues可以全自动处理，给出修改建议和代码实现。
agent_response: 
I'll update both README files to highlight the dual functionality of bella-issues-bot as both a daily coding assistant and an automated GitHub workflow solution.

Let's start by modifying the main README.md and then the client README.md file:

```diff
--- README.md
+++ README.md
@@ -2,11 +2,14 @@
 
 ## 项目简介
 
-bella-issues-bot 是一个基于人工智能的代码开发助手，能够根据用户需求自动分析、生成和修改代码。该工具通过对项目结构的深入理解，可以帮助开发者快速实现功能需求，提高开发效率。
+bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：
+
+1. **个人开发助手模式**：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。
+2. **GitHub自动化模式**：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。
+
+通过对项目结构的深入理解和强大的代码生成能力，bella-issues-bot 能够显著提高开发效率，减少重复工作，让您专注于更有创造性的任务。
 
 ## 主要功能
 
 - 需求分析：自动理解和分解用户的功能需求
@@ -14,6 +17,15 @@
 - 版本管理：与Git集成，支持分支创建和代码提交
 - GitHub集成：支持与GitHub仓库交互
 
+### 个人开发模式特性
+
+- 实时代码生成：根据描述快速生成代码片段或完整功能
+- 智能问答：针对代码库回答技术问题，提供解释和建议
+
+### GitHub自动化模式特性
+
+- Issues自动处理：监听新Issues，自动分析需求并生成解决方案
+- 代码审查：审查提交的代码，提出优化建议
 ## 安装方法
 
 使用pip安装：
@@ -24,7 +36,11 @@
 
 ## 使用方法
 
-bella-issues-bot 提供了命令行界面和编程API两种使用方式：
+bella-issues-bot 提供了多种使用方式：
+
+### 个人开发模式
+
+在日常开发中，您可以通过命令行界面或编程API使用bella-issues-bot：
 
 ### 命令行使用
 
@@ -43,6 +59,23 @@
 )
 ```
 
+### GitHub自动化模式
+
+要在GitHub仓库中集成bella-issues-bot，需要按照以下步骤设置：
+
+1. **配置GitHub Actions**：在项目的`.github/workflows`目录下创建工作流配置文件。
+
+```yaml
+name: Bella Issues Bot
+on:
+  issues:
+    types: [opened, edited]
+
+jobs:
+  process-issue:
+    # 具体配置内容请参阅详细文档
+```
+
+2. **设置必要的密钥**：在GitHub仓库设置中添加必要的Secrets，如`OPENAI_API_KEY`。
 ## 配置环境变量
 
 工具会读取以下环境变量：
@@ -51,6 +84,7 @@
 - `OPENAI_API_BASE`: OpenAI API基础URL
 - `GITHUB_REMOTE_URL`: GitHub远程仓库URL
 - `GITHUB_TOKEN`: GitHub身份验证令牌
+- `BELLA_BOT_MODE`: 运行模式，可设置为"client"(默认)或"bot"
 
 ## 示例
 
```

Now let's update the client README to provide more detailed information:

```diff
--- client/README.md
+++ client/README.md
@@ -1,8 +1,14 @@
 # Workflow 客户端
 
-一个用于运行WorkflowEngine处理用户需求的命令行接口和编程API。
+一个强大的命令行接口和编程API，用于运行WorkflowEngine处理用户需求，支持个人开发助手模式和GitHub自动化工作流模式。
 
-## 命令行使用方式
+## 工作模式
+
+bella-issues-bot 支持两种主要工作模式：
+
+- **客户端模式 (client)**：默认模式，适合作为个人开发助手使用，每次运行时基于当前代码状态进行操作。
+- **机器人模式 (bot)**：专为GitHub集成设计，会自动拉取最新分支状态，处理完成后自动提交更改并在Issues中回复处理结果。
+## 命令行使用方式（个人开发助手模式）
 
 你可以通过以下两种方式从命令行运行WorkflowEngine：
 
@@ -18,14 +24,23 @@
 
 ### 命令行参数
 
-- `--issue-id`：（必需）正在处理的问题ID
-- `--requirement` 或 `--requirement-file`：（必需）用户需求文本或包含需求的文件路径
+#### 基础参数
+
+- `--issue-id`：（必需）问题ID，用于跟踪和引用
+- `--requirement` 或 `--requirement-file`：（必需）具体需求描述或包含需求的文件路径
 - `--project-dir`：项目目录路径（默认：当前目录）
+
+#### AI模型配置
+
 - `--core-model`：核心AI操作使用的模型（默认：gpt-4o）
 - `--data-model`：数据操作使用的模型（默认：gpt-4o）
 - `--core-temperature`：核心模型的温度参数（默认：0.7）
 - `--data-temperature`：数据模型的温度参数（默认：0.7）
-- `--max-retry`：最大重试次数（默认：3）
+
+#### 工作流配置
+
+- `--mode`：工作模式，可选"client"或"bot"（默认：client）
+  - `client`：个人开发助手模式，基于当前代码状态工作
+  - `bot`：GitHub自动化模式，拉取最新分支，自动提交并回复Issues
 - `--default-branch`：默认Git分支（默认：main）
 - `--mode`：操作模式：client或bot（默认：client）
 - `--base-url`：API调用的基础URL
@@ -33,12 +48,21 @@
 - `--github-remote-url`：GitHub远程URL
 - `--github-token`：GitHub令牌
 
+#### 执行控制
+
+- `--max-retry`：最大重试次数（默认：3）
+
 ### 简易脚本使用
 
 你也可以使用提供的脚本简化命令行调用：
 
 ```bash
 ./scripts/run_bot.sh <问题ID> [需求文件路径]
+```
+
+### GitHub工作流集成示例
+
+```bash
+bella-issues-bot --issue-id 123 --requirement-file issue_content.txt --mode bot --github-remote-url https://github.com/user/repo.git --github-token $GITHUB_TOKEN
 ```
 
 ## 编程方式使用
@@ -58,6 +82,19 @@
 )
 ```
 
+## GitHub自动化模式配置
+
+要在GitHub Actions中设置自动响应Issues，可以创建如下工作流配置：
+
+1. 在项目的`.github/workflows`目录下创建`bella-bot.yml`文件
+2. 配置工作流以监听Issues事件
+3. 设置必要的Secret（如`OPENAI_API_KEY`）
+4. 工作流将自动:
+   - 分析Issues内容
+   - 生成解决方案
+   - 实现代码变更
+   - 创建新分支并提交代码
+   - 在Issues下回复实现结果
 ## 环境变量
 
 工具会读取以下环境变量：
```

Let's also update the scripts/run_bot.sh file to better reflect its purpose:

```diff
--- scripts/run_bot.sh
+++ scripts/run_bot.sh
@@ -1,12 +1,17 @@
 #!/bin/bash
 
-# Script to run the bella-issues-bot CLI with basic parameters
+# 启动bella-issues-bot的帮助脚本
+# 此脚本简化了命令行参数的输入，便于快速使用
 
-# Check if issue-id is provided
+# 检查是否提供了issue-id参数
 if [ -z "$1" ]; then
-    echo "Usage: $0 <issue-id> [requirement-file]"
+    echo "使用方法: $0 <issue-id> [需求文件路径]"
+    echo ""
+    echo "示例:"
+    echo "  $0 42 ./requirements.txt  # 使用文件中的需求"
+    echo "  $0 42                    # 将会要求您输入需求"
     exit 1
 fi
 
-python -m client.cli --issue-id "$1" ${2:+--requirement-file "$2"}
+python -m client.terminal --issue-id "$1" ${2:+--requirement-file "$2"}
```

This concludes a fully working implementation. The updated READMEs now provide detailed information about both the personal development assistant mode and the GitHub integration workflow mode, highlighting the bot's dual functionality and explaining how to use each mode effectively.

=========================以上【历史执行记录】内容为历史执行过程，所有代码改动均已经生效========================================


# 用户需求


    - **客户端模式 (client)**：默认模式，适合作为个人开发助手使用，每次运行时基于project_dir目录下的当前代码状态进行操作。
    - **机器人模式 (bot)**：专为GitHub集成设计，会在project_dir目录下创建临时目录作为project_dir，自动拉取issues对应的最新分支状态，处理完成后自动提交更改并在Issues中回复处理结果，并且删除当前工作区。
    这个功能还没实现，在workflow_engine.py中实现
    