
# 项目文件描述


- core/diff.py: 实现了处理文件差异(diff)的Diff类，用于使用AI模型智能解析和应用代码变更。该类包含parse_diffs_from_text、process_diffs、_replace_file等核心方法，能从各种格式的diff信息中提取变更并生成新文件内容，与AIAssistant交互完成文件更新操作。


# 文件内容



```
File: core/diff.py
1 import logging
2 import os
3 import re
4 from typing import List, Tuple
5 
6 from langchain_core.tools import StructuredTool
7 from pydantic import BaseModel, Field
8 
9 from ai import AIAssistant, AIConfig
10 
11 logger = logging.getLogger(__name__)
12 
13 
14 class Diff:
15     """处理文件差异的类，使用 AI 模型生成新文件内容"""
16     
17     def __init__(self, ai_config: AIConfig):
18         """
19         初始化 Diff 类
20         
21         Args:
22             ai_config: AI 配置
23         """
24         # 保存 AI 配置
25         self.ai_config = ai_config
26         
27         # 保存原始系统提示词
28         self.original_sys_prompt = ai_config.sys_prompt
29         
30         # 设置处理 diff 的系统提示词
31         ai_config.sys_prompt = self._get_diff_system_prompt()
32         
33         # 初始化工具列表
34         self.tools = [self._create_replace_file_tool()]
35         
36         # 创建 AI 助手
37         self.ai_assistant = AIAssistant(config=ai_config, tools=self.tools)
38     
39     def __del__(self):
40         """析构函数，恢复原始系统提示词"""
41         self.ai_config.sys_prompt = self.original_sys_prompt
42 
43     @staticmethod
44     def parse_diffs_from_text(text: str) -> List[Tuple[str, str, str]]:
45         """
46         从文本中提取所有文件修改信息
47 
48         Args:
49             text: 包含文件修改信息的文本
50 
51         Returns:
52             List[Tuple[str, str, str]]: 解析后的文件信息列表，每个元素为 (原文件路径, 新文件路径, diff内容)
53         """
54         diffs = []
55         last_file_path = None  # 记录前一个文件的路径
56         
57         logger.info(f"开始解析文本中的 diff 信息，文本长度: {len(text)}")
58         
59         # 提取所有 ```diff 代码块
60         diff_blocks = re.findall(r'```diff\s+(.*?)```', text, re.DOTALL)
61         
62         for diff_block in diff_blocks:
63             # 尝试从 diff 块中提取文件路径
64             file_paths = re.findall(r'(?:---|\+\+\+)\s+(?:a/|b/)?([^
	]+)', diff_block)
65             
66             if len(file_paths) >= 2:
67                 file_path_pre = file_paths[0]
68                 file_path_post = file_paths[1]
69                 last_file_path = file_path_post  # 更新最后使用的文件路径
70             elif len(file_paths) == 1:
71                 file_path_pre = file_paths[0]
72                 file_path_post = file_paths[0]
73                 last_file_path = file_path_post  # 更新最后使用的文件路径
74             else:
75                 # 如果没有找到文件路径，尝试其他格式
76                 git_diff_match = re.search(r'diff --git a/(.*?) b/(.*?)[
]', diff_block)
77                 if git_diff_match:
78                     file_path_pre = git_diff_match.group(1)
79                     file_path_post = git_diff_match.group(2)
80                     last_file_path = file_path_post  # 更新最后使用的文件路径
81                 elif last_file_path:
82                     # 如果没有找到文件路径，但有前一个文件的路径，则使用前一个文件的路径
83                     logger.info(f"未找到文件路径，使用前一个文件的路径: {last_file_path}")
84                     file_path_pre = last_file_path
85                     file_path_post = last_file_path
86                 else:
87                     # 如果仍然没有找到，使用默认名称
88                     logger.warning(f"无法从 diff 块中提取文件路径，使用默认名称")
89                     file_path_pre = "unknown_file.txt"
90                     file_path_post = "unknown_file.txt"
91                     last_file_path = file_path_post  # 更新最后使用的文件路径
92             
93             logger.info(f"找到 diff: {file_path_pre} -> {file_path_post}")
94             diffs.append((file_path_pre, file_path_post, diff_block))
95         
96         # 如果没有找到 diff 块，尝试提取文件路径和内容
97         if not diffs:
98             # 尝试提取文件路径和内容
99             file_blocks = re.findall(r'```(?:.*?)
(?:# )?(?:File|文件):\s*([^
]+)
(.*?)```', text, re.DOTALL)
100             
101             for file_path, file_content in file_blocks:
102                 file_path = file_path.strip()
103                 logger.info(f"找到文件内容: {file_path}")
104                 last_file_path = file_path  # 更新最后使用的文件路径
105                 diffs.append((file_path, file_path, file_content))
106         
107         # 如果仍然没有找到，尝试匹配任何代码块
108         if not diffs:
109             code_blocks = re.findall(r'```(?:.*?)
(.*?)```', text, re.DOTALL)
110             
111             for i, content in enumerate(code_blocks):
112                 # 尝试从内容中提取文件路径
113                 file_path_match = re.search(r'(?:File|文件):\s*([^
]+)', content)
114                 if file_path_match:
115                     file_path = file_path_match.group(1).strip()
116                     logger.info(f"从代码块内容中提取到文件路径: {file_path}")
117                     last_file_path = file_path  # 更新最后使用的文件路径
118                     diffs.append((file_path, file_path, content))
119                 elif last_file_path:
120                     # 如果没有找到文件路径，但有前一个文件的路径，则使用前一个文件的路径
121                     logger.info(f"未从代码块中提取到文件路径，使用前一个文件的路径: {last_file_path}")
122                     diffs.append((last_file_path, last_file_path, content))
123                 else:
124                     logger.warning(f"找到代码块但无法提取文件路径，将使用默认文件名: code_block_{i}.txt")
125                     file_path = f"code_block_{i}.txt"
126                     last_file_path = file_path  # 更新最后使用的文件路径
127                     diffs.append((file_path, file_path, content))
128         
129         if not diffs:
130             logger.warning("未找到任何有效的 diff 或文件内容")
131             # 打印文本的前200个字符，帮助调试
132             logger.debug(f"文本前200个字符: {text[:200]}")
133         else:
134             logger.info(f"共找到 {len(diffs)} 个文件修改信息")
135         
136         return diffs
137 
138     def process_diffs(self, diffs: List[Tuple[str, str, str]], project_dir: str) -> List[str]:
139         """
140         处理 diff 列表，使用 AI 模型生成新文件内容
141 
142         Args:
143             diffs: 解析后的文件信息列表，每个元素为 (原文件路径, 新文件路径, diff内容)
144             project_dir: 项目根目录
145 
146         Returns:
147             List[str]: 处理失败的文件列表
148         """
149         failed_files = []
150         
151         for file_path_pre, file_path_post, content_or_diff in diffs:
152             try:
153                 full_path_pre = os.path.join(project_dir, file_path_pre)
154                 full_path_post = os.path.join(project_dir, file_path_post)
155                 
156                 # 检查是否是新文件
157                 is_new_file = file_path_pre == "/dev/null" or not os.path.exists(full_path_pre)
158                 
159                 if is_new_file:
160                     # 对于新文件，直接使用内容创建
161                     if content_or_diff.startswith("diff ") or content_or_diff.startswith("--- ") or content_or_diff.startswith("+++ ") or "
@@" in content_or_diff:
162                         # 如果是 diff 格式，需要让模型生成完整内容
163                         prompt = f"""
164                         我需要根据以下 diff 信息创建一个新文件。
165                         
166                         diff 信息：
167                         ```
168                         {content_or_diff}
169                         ```
170                         
171                         请生成完整的文件内容，然后使用 replace_file 工具将内容写入文件 {full_path_post}。
172                         """
173                     else:
174                         # 如果已经是完整内容，直接使用
175                         prompt = f"""
176                         请使用 replace_file 工具将以下内容写入文件 {full_path_post}：
177                         
178                         ```
179                         {content_or_diff}
180                         ```
181                         """
182                 else:
183                     # 对于现有文件，读取原内容，让模型生成新内容
184                     try:
185                         with open(full_path_pre, "r", encoding="utf-8") as f:
186                             original_content = f.read()
187                         
188                         prompt = f"""
189                         我需要根据 diff 信息修改一个文件。原文件内容如下：
190                         ```
191                         {original_content}
192                         ```
193                         
194                         diff 信息如下：
195                         ```
196                         {content_or_diff}
197                         ```
198                         
199                         请根据原文件内容和 diff 信息，生成修改后的完整文件内容，然后使用 replace_file 工具将内容写入文件 {full_path_post}。
200                         """
201                     except Exception as e:
202                         logger.error(f"读取原文件失败: {str(e)}")
203                         failed_files.append(file_path_post)
204                         continue
205                 
206                 # 调用 AI 模型处理
207                 response = self.ai_assistant.generate_response(prompt, use_tools=True)
208                 
209                 # 检查响应中是否包含成功信息
210                 if "文件已更新:" not in response:
211                     logger.warning(f"文件处理可能失败: {file_path_post}, 响应: {response}")
212                     failed_files.append(file_path_post)
213                 else:
214                     logger.info(f"处理文件成功: {file_path_post}")
215             except Exception as e:
216                 logger.error(f"处理文件失败: {str(e)}")
217                 failed_files.append(file_path_post)
218         
219         return failed_files
220 
221     def _replace_file(self, file_path: str, content: str) -> str:
222         """
223         替换或创建UTF-8编码的文本文件
224         支持自动创建不存在的目录结构
225         """
226         try:
227             os.makedirs(os.path.dirname(file_path), exist_ok=True)
228             with open(file_path, "w", encoding="utf-8") as f:
229                 f.write(content)
230             return f"文件已更新: {file_path}"
231         except UnicodeEncodeError:
232             return "错误：内容包含非UTF-8字符"
233         except Exception as e:
234             return f"操作失败: {str(e)}"
235 
236 
237     class _ReplaceFileSchema(BaseModel):
238         file_path: str = Field(
239             ...,
240             example="/data/config.json",
241             description="文件绝对路径，支持自动创建父目录"
242         )
243         content: str = Field(
244             ...,
245             example="""
246     def calculate_sum(a, b):
247         return a + b
248     
249     if __name__ == '__main__':
250         print(calculate_sum(3, 5))
251     """,
252             description="UTF-8编码的文本内容，最大支持10MB"
253         )
254 
255     def _create_replace_file_tool(self) -> StructuredTool:
256         """创建替换文件内容的工具"""
257         return StructuredTool.from_function(
258             func=self._replace_file,
259             name="replace_file",
260             description="替换或创建文件内容。输入应为文件路径和文件内容。",
261             args_schema=self._ReplaceFileSchema,
262             return_direct=True,
263         )
264 
265 
266     def _get_diff_system_prompt(self) -> str:
267         """
268         获取处理 diff 的系统提示词
269 
270         Returns:
271             str: 系统提示词
272         """
273         return """你是一个专业的代码工程师助手，擅长根据 diff 信息修改文件。
274     
275     你将收到原始文件内容和 diff 信息，需要生成修改后的完整文件内容。
276     
277     使用以下工具来完成任务：
278     1. replace_file: 用于替换或创建文件内容
279     
280     处理步骤：
281     1. 分析原始文件内容和 diff 信息
282     2. 生成修改后的完整文件内容
283     3. 使用 replace_file 工具将内容写入文件
284     
285     注意事项：
286     - 确保生成的文件内容是完整的，包含所有必要的代码
287     - 一定不可以删除原文件中的未修改内容
288     - 不要添加额外的注释或标记
289     - 只修改 diff 中指定的部分，保持其他部分不变
290     - 如果是新文件，直接生成完整的文件内容
291     """
```




# 用户需求


    diff.py中加一个静态方法，提取text中所有diff块，包含```diff ```的标识，一起提取出来
    