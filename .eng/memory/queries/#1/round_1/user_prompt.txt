# 项目文件描述


- core/file_memory.py: 文件记忆管理模块，负责存储和更新文件描述信息。FileMemory类通过AI为项目文件生成描述并跟踪变更，支持批量处理和失败重试机制。

- core/log_manager.py: 管理代码生成日志的存储和检索。包含LogManager类，用于存档系统提示词、用户提示词、AI响应等内容，支持按issue和轮次组织日志。提供archive_logs和get_issue_log_entries等方法，记录代码生成过程。

- core/workflow_engine.py: 工作流引擎模块，作为系统核心协调各组件工作。实现WorkflowEngine类，根据用户需求决策执行代码生成或聊天流程，管理环境初始化和清理，支持客户端和bot两种工作模式。


# 文件内容



```
File: core/file_memory.py
1 import json
2 import os
3 import time
4 from dataclasses import dataclass
5 from typing import Dict, List
6 
7 from dotenv import load_dotenv
8 from langchain.tools import Tool
9 
10 from core.ai import AIAssistant, AIConfig
11 from core.file_fetcher import FileFetcher
12 from core.git_manager import GitManager, GitConfig
13 from core.log_config import get_logger
14 
15 logger = get_logger(__name__)
16 
17 
18 @dataclass
19 class FileMemoryConfig:
20     """配置文件记忆管理"""
21     project_dir: str
22     ai_config: AIConfig
23     git_manager: GitManager
24 
25 
26 class FileMemory:
27     """管理文件描述的记忆"""
28 
29     MEMORY_DIR = ".eng/memory"
30     FILE_DETAILS_PATH = f"{MEMORY_DIR}/file_details.txt"
31     GIT_ID_FILE = f"{MEMORY_DIR}/git_id"
32     MAX_RETRIES = 3    # 最大重试次数
33     RETRY_DELAY = 30    # 重试延迟（秒）
34     # 每批次最大行数和字符数限制
35     MAX_LINES_PER_BATCH = 10000  # 最大行数
36     MAX_CHARS_PER_BATCH = 100000  # 最大字符数，约为 100KB
37     MAX_FILES_PER_BATCH = 100  # 每批次最多处理的文件数
38 
39     def __init__(self, config: FileMemoryConfig):
40         self.config = config
41         self.memory_path = os.path.join(config.project_dir, self.FILE_DETAILS_PATH)
42         self.git_id_path = os.path.join(config.project_dir, self.GIT_ID_FILE)
43 
44         # 初始化 AI 助手
45         self.ai_assistant = AIAssistant(config=self.config.ai_config, tools=[self._create_batch_description_tool()])
46 
47         # 初始化 Git 管理器
48         self.git_manager = self.config.git_manager
49 
50         # 确保内存目录存在
51         os.makedirs(os.path.dirname(self.memory_path), exist_ok=True)
52 
53     def _ensure_directories(self):
54         """确保必要的目录存在"""
55         memory_dir = os.path.join(self.config.project_dir, self.MEMORY_DIR)
56         os.makedirs(memory_dir, exist_ok=True)
57 
58     def _get_failed_files_path(self) -> str:
59         """获取失败文件记录的路径"""
60         return os.path.join(self.config.project_dir, self.MEMORY_DIR, "failed_files.json")
61 
62     def _read_failed_files(self) -> List[str]:
63         """读取处理失败的文件列表"""
64         failed_files_path = self._get_failed_files_path()
65         if os.path.exists(failed_files_path):
66             try:
67                 with open(failed_files_path, 'r', encoding='utf-8') as f:
68                     return json.load(f)
69             except Exception as e:
70                 logger.error(f"读取失败文件列表出错: {str(e)}")
71         return []
72 
73     def _write_failed_files(self, failed_files: List[str]) -> None:
74         """写入处理失败的文件列表"""
75         failed_files_path = self._get_failed_files_path()
76         try:
77             with open(failed_files_path, 'w', encoding='utf-8') as f:
78                 json.dump(failed_files, f, ensure_ascii=False, indent=2)
79         except Exception as e:
80             logger.error(f"写入失败文件列表出错: {str(e)}")
81 
82     def _create_batch_description_tool(self) -> Tool:
83         """创建批量生成文件描述的工具"""
84         from langchain.tools import Tool
85         
86         def process_file_descriptions(file_descriptions: str) -> Dict[str, str]:
87             """
88             处理文件描述列表
89             
90             Args:
91                 file_descriptions: JSON格式的文件描述列表，格式为 [{"fileName": "path/to/file.py", "desc": "文件描述"}]
92                 
93             Returns:
94                 Dict[str, str]: 文件路径到描述的映射
95             """
96             try:
97                 descriptions = {}
98                 file_list = json.loads(file_descriptions)
99                 
100                 if not isinstance(file_list, list):
101                     logger.error("错误：输入必须是一个列表")
102                     return descriptions
103                 
104                 # 处理结果
105                 for item in file_list:
106                     if isinstance(item, dict) and "fileName" in item and "desc" in item:
107                         descriptions[item["fileName"]] = item["desc"]
108                     else:
109                         logger.warning(f"跳过无效的文件描述项: {item}")
110                 
111                 logger.info(f"成功处理了 {len(descriptions)} 个文件描述")
112                 return descriptions
113             except json.JSONDecodeError:
114                 logger.error("错误：输入不是有效的 JSON 格式")
115                 return {}
116             except Exception as e:
117                 logger.error(f"处理文件描述时出错: {str(e)}")
118                 return {}
119         
120         return Tool(
121             name="process_file_descriptions",
122             description="处理文件描述列表，输入必须是JSON格式的列表，每个元素包含fileName和desc字段",
123             func=process_file_descriptions,
124             return_direct=True
125         )
126 
127     def _generate_batch_file_descriptions(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
128         """
129         批量生成文件描述
130         
131         Args:
132             files_with_content: 包含文件路径和内容的列表，格式为 [{"filepath": "path/to/file.py", "content": "..."}]
133             
134         Returns:
135             Dict[str, str]: 文件路径到描述的映射
136         """
137         # 构建提示词
138         files_text = ""
139         for i, file_info in enumerate(files_with_content):
140             files_text += f"\n--- 文件 {i+1}: {file_info['filepath']} ---\n{file_info['content']}\n"
141         
142         prompt = f"""
143 请分析以下多个代码文件，并为每个文件生成一个简短的中文描述（每个不超过100字）。
144 描述应该包含：
145 1. 文件的主要功能
146 2. 包含的关键类或函数
147 3. 与其他文件的主要交互（如果明显的话）
148 
149 {files_text}
150 
151 请使用process_file_descriptions工具返回结果，输入必须是一个JSON格式的列表，每个元素包含fileName和desc字段。
152 例如：
153 [
154   {{"fileName": "path/to/file1.py", "desc": "这个文件实现了..."}},
155   {{"fileName": "path/to/file2.py", "desc": "这个文件定义了..."}}
156 ]
157 
158 请确保每个文件都有对应的描述，并且描述准确反映文件的功能和内容。
159 """
160         
161         # 尝试生成描述，最多重试MAX_RETRIES次
162         descriptions = {}
163         failed_files = []
164         file_paths = [file_info["filepath"] for file_info in files_with_content]
165         
166         for attempt in range(self.MAX_RETRIES):
167             try:
168                 logger.info(f"尝试批量生成文件描述（第{attempt+1}次尝试）")
169                 
170                 # 使用工具生成描述
171                 descriptions = self.ai_assistant.generate_response(prompt, use_tools=True)
172                 
173                 # 如果返回的不是字典，可能是字符串响应
174                 if not isinstance(descriptions, dict):
175                     logger.error(f"工具返回了非预期的结果类型: {type(descriptions)}")
176                     descriptions = {}
177                 
178                 # 检查是否所有文件都有描述
179                 missing_files = [
180                     file_path for file_path in file_paths
181                     if file_path not in descriptions
182                 ]
183                 
184                 if missing_files:
185                     failed_files.extend(missing_files)
186                     logger.warning(f"以下文件未能生成描述: {missing_files}")
187                 
188                 # 如果有成功处理的文件，则返回结果
189                 if descriptions:
190                     return descriptions
191             
192             except Exception as e:
193                 logger.error(f"批量生成文件描述失败（第{attempt+1}次尝试）: {str(e)}")
194             
195             # 如果不是最后一次尝试，则等待后重试
196             if attempt < self.MAX_RETRIES - 1:
197                 logger.info(f"等待 {self.RETRY_DELAY} 秒后重试...")
198                 time.sleep(self.RETRY_DELAY)
199         
200         # 所有尝试都失败，记录失败的文件
201         self._update_failed_files(file_paths)
202         
203         # 返回空结果
204         return descriptions
205 
206     def _update_failed_files(self, new_failed_files: List[str]) -> None:
207         """更新失败文件列表"""
208         if not new_failed_files:
209             return
210             
211         # 读取现有失败文件列表
212         existing_failed_files = self._read_failed_files()
213         
214         # 合并并去重
215         all_failed_files = list(set(existing_failed_files + new_failed_files))
216         
217         # 写入更新后的列表
218         self._write_failed_files(all_failed_files)
219         logger.info(f"更新了失败文件列表，共 {len(all_failed_files)} 个文件")
220 
221     def process_failed_files(self) -> Dict[str, str]:
222         """处理之前失败的文件"""
223         failed_files = self._read_failed_files()
224         if not failed_files:
225             logger.info("没有需要处理的失败文件")
226             return {}
227             
228         logger.info(f"开始处理 {len(failed_files)} 个失败文件")
229         
230         # 准备文件内容
231         files_with_content = []
232         for filepath in failed_files:
233             content = self._get_file_content(filepath)
234             if content.strip():  # 跳过空文件
235                 files_with_content.append({"filepath": filepath, "content": content})
236         
237         # 按批次处理文件
238         descriptions = self._process_files_in_batches(files_with_content)
239         
240         # 更新失败文件列表
241         if descriptions:
242             # 找出成功处理的文件
243             processed_files = list(descriptions.keys())
244             # 更新失败文件列表
245             new_failed_files = [f for f in failed_files if f not in processed_files]
246             self._write_failed_files(new_failed_files)
247             
248             logger.info(f"成功处理了 {len(processed_files)} 个之前失败的文件，还有 {len(new_failed_files)} 个文件失败")
249         
250         return descriptions
251 
252 
253     def _get_file_content(self, filepath: str) -> str:
254         """获取文件内容"""
255         try:
256             full_path = os.path.join(self.config.project_dir, filepath)
257             with open(full_path, "r", encoding="utf-8") as f:
258                 return f.read()
259         except Exception as e:
260             logger.error(f"读取文件 {filepath} 失败: {str(e)}")
261             return ""
262 
263     def _process_files_in_batches(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
264         """将文件分批处理"""
265         all_descriptions = {}
266         current_batch = []
267         current_lines = 0
268         current_size = 0
269 
270         
271         for file_info in files_with_content:
272             content = file_info["content"]
273             lines = len(content.splitlines())
274             chars = len(content)
275             
276             if lines == 0:
277                 continue
278                 
279             # 检查是否需要开始新批次
280             # 如果当前批次已满或添加此文件会超出限制，则处理当前批次并开始新批次
281             if (current_batch and (
282                 len(current_batch) >= self.MAX_FILES_PER_BATCH or
283                 current_lines + lines > self.MAX_LINES_PER_BATCH or
284                 current_size + chars > self.MAX_CHARS_PER_BATCH
285             )):
286                 # 处理当前批次
287                 logger.info(f"处理批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
288                 batch_descriptions = self._generate_batch_file_descriptions(current_batch)
289                 all_descriptions.update(batch_descriptions)
290                 
291                 # 重置批次
292                 current_batch = [file_info]
293                 current_lines = lines
294                 current_size = chars
295             else:
296                 current_batch.append(file_info)
297                 current_lines += lines
298                 current_size += chars
299         
300         # 处理最后一个批次
301         if current_batch:
302             logger.info(f"处理最后一个批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
303             batch_descriptions = self._generate_batch_file_descriptions(current_batch)
304             all_descriptions.update(batch_descriptions)
305         
306         return all_descriptions
307 
308     def _process_files_chunk(self, files: List[str]) -> Dict[str, str]:
309         """处理一组文件，生成描述"""
310         # 准备文件内容
311         files_with_content = []
312         for filepath in files:
313             content = self._get_file_content(filepath)
314             if content.strip():  # 跳过空文件
315                 files_with_content.append({"filepath": filepath, "content": content})
316         
317         # 按批次处理文件
318         return self._process_files_in_batches(files_with_content)
319 
320     def _read_git_id(self) -> str:
321         """读取保存的 Git ID"""
322         if not os.path.exists(self.git_id_path):
323             return ""
324         with open(self.git_id_path, "r") as f:
325             return f.read().strip()
326 
327     def _write_git_id(self, git_id: str) -> None:
328         """写入当前 Git ID"""
329         with open(self.git_id_path, "w") as f:
330             f.write(git_id)
331 
332     def _read_file_details(self) -> Dict[str, str]:
333         """读取文件描述信息"""
334         if not os.path.exists(self.memory_path):
335             return {}
336 
337         details = {}
338         with open(self.memory_path, "r", encoding="utf-8") as f:
339             for line in f:
340                 if ":" in line:
341                     filename, description = line.strip().split(":", 1)
342                     details[filename] = description
343         return details
344 
345     def _write_file_details(self, details: Dict[str, str]) -> None:
346         """写入文件描述信息"""
347         with open(self.memory_path, "w", encoding="utf-8") as f:
348             for filename, description in sorted(details.items()):
349                 f.write(f"{filename}:{description}\n")
350 
351     def update_file_details(self) -> None:
352         """更新文件描述信息"""
353         # 获取当前的 Git ID
354         current_git_id = self.git_manager.get_current_commit_id()
355         saved_git_id = self._read_git_id()
356 
357         # 获取所有文件
358         all_files = FileFetcher.get_all_files_without_ignore(self.config.project_dir)
359 
360         # 读取现有描述
361         existing_details = self._read_file_details()
362 
363         if saved_git_id:
364             # 获取变更的文件
365             changed_files = set(
366                 self.git_manager.get_changed_files(saved_git_id, current_git_id)
367             ) & all_files
368             new_files = all_files - set(existing_details.keys())
369             files_to_process = list(changed_files | new_files)
370 
371 
372             # 删除不存在的文件的描述
373             existing_details = {
374                 k: v for k, v in existing_details.items() if k in all_files
375             }
376         else:
377             # 首次运行，处理所有文件
378             files_to_process = list(all_files)
379 
380         # 处理需要更新的文件
381         if files_to_process:
382             new_descriptions = self._process_files_chunk(files_to_process)
383             existing_details.update(new_descriptions)
384 
385         # 保存结果
386         self._write_file_details(existing_details)
387         self._write_git_id(current_git_id)
388 
389     @classmethod
390     def get_file_descriptions(cls, project_dir: str) -> Dict[str, str]:
391         """获取文件描述的静态方法"""
392         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
393 
394         if not os.path.exists(memory_path):
395             return {}
396 
397         try:
398             descriptions = {}
399             with open(memory_path, "r", encoding="utf-8") as f:
400                 for line in f:
401                     if ":" in line:
402                         filename, description = line.strip().split(":", 1)
403                         descriptions[filename] = description
404             return descriptions
405         except Exception as e:
406             logger.error(f"读取文件描述失败: {str(e)}")
407             return {}
408 
409     @classmethod
410     def get_selected_file_descriptions(cls, project_dir: str, files: List[str]) -> Dict[str, str]:
411         """获取文件描述的静态方法"""
412         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
413 
414         if not os.path.exists(memory_path):
415             return {}
416         try:
417             descriptions = {}
418             with open(memory_path, "r", encoding="utf-8") as f:
419                 for line in f:
420                     if ":" in line:
421                         filename, description = line.strip().split(":", 1)
422                         if filename in files:
423                             descriptions[filename] = description
424             return descriptions
425         except Exception as e:
426             logger.error(f"读取文件描述失败: {str(e)}")
427             return {}
428 
429 if __name__ == "__main__":
430     load_dotenv()
431     project_dir = "../."
432     memory = FileMemory(
433         FileMemoryConfig(
434             ai_config=AIConfig(temperature=1, model_name="claude-3.7-sonnet"),
435             git_manager=GitManager(config=GitConfig(project_dir))
436         )
437     )
438 
439     memory.update_file_details()
440
```




```
File: core/log_manager.py
1 import datetime
2 import os
3 import json
4 import shutil
5 from dataclasses import dataclass, field
6 from typing import List, Optional
7 from pydantic import BaseModel
8 
9 from core.diff import DiffInfo
10 from core.log_config import get_logger
11 
12 logger = get_logger(__name__)
13 
14 @dataclass
15 class LogConfig:
16     """日志管理配置"""
17 
18     project_dir: str
19     issue_id: int
20     mode: str = "client" # ["client", "bot"]
21 
22 
23 class LogEntry(BaseModel):
24     """存储单次代码生成日志的数据类"""
25     issue_id: int
26     round_num: int
27     sys_prompt: str
28     prompt: str
29     response: str
30     timestamp: str = datetime.datetime.now().isoformat()
31     log_path: str = ""
32     modified_files: List[DiffInfo] = []
33 
34 
35 class LogManager:
36     """管理代码生成日志的存档和检索"""
37     base_dir: str = ".eng"
38     logs_base_dir: str = "memory"
39     rollback_dir: str = "rollback"
40 
41     def __init__(self, config: LogConfig):
42         """
43         初始化日志管理器
44 
45         Args:
46             config: LogConfig实例，包含必要的配置信息
47         """
48         self.config = config
49         self.issue_id = self.config.issue_id
50 
51         
52         # 根据模式选择存储目录
53         if self.config.mode == "bot":
54             logs_dir = "issues"
55         else:
56             logs_dir = "queries"
57             
58         # 构建完整的日志存储路径
59         self.logs_path = os.path.join(
60             self.config.project_dir, 
61             self.base_dir,
62             self.logs_base_dir,
63             logs_dir)
64         self.issues_path = os.path.join(
65             self.logs_path, "#" + str(self.issue_id)
66         )
67 
68         self.rollback_path = os.path.join(
69             self.logs_path, "#" + str(self.issue_id), self.rollback_dir
70         )
71 
72         # 初始化当前轮次
73         self.current_round = self._get_next_round()
74 
75         # 确保必要的目录存在
76         os.makedirs(self.issues_path, exist_ok=True)
77         os.makedirs(self.rollback_path, exist_ok=True)
78 
79         # 定义日志文件名常量
80         self.SYS_PROMPT_FILE = "system_prompt.txt"
81         self.USER_PROMPT_FILE = "user_prompt.txt"
82         self.AI_RESPONSE_FILE = "ai_response.txt"
83         self.TIMESTAMP_FILE = "timestamp.txt"
84         self.MODIFIED_FILES_FILE = "modified_files.txt"
85 
86     def archive_logs(self, sys_prompt: str, prompt: str, response: str, diff_infos: List[DiffInfo] = None) -> str:
87         """
88         将代码生成日志存档到指定的目录
89 
90         Args:
91             diff_infos: 文件的修改信息
92             sys_prompt: 系统提示词
93             prompt: 用户提示词
94             response: AI响应
95 
96         Returns:
97             str: 存档目录的路径
98         """
99         # 获取下一个轮次号
100 
101         round_num = self.current_round
102 
103         # 获取当前时间戳
104         timestamp = datetime.datetime.now().isoformat()
105         
106         # 创建轮次目录
107         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
108         os.makedirs(round_dir, exist_ok=True)
109         
110         # 保存系统提示词
111         with open(os.path.join(round_dir, self.SYS_PROMPT_FILE), "w", encoding="utf-8") as f:
112             f.write(sys_prompt)
113         
114         # 保存用户提示词
115         with open(os.path.join(round_dir, self.USER_PROMPT_FILE), "w", encoding="utf-8") as f:
116             f.write(prompt)
117         
118         # 保存AI响应
119         with open(os.path.join(round_dir, self.AI_RESPONSE_FILE), "w", encoding="utf-8") as f:
120             f.write(response)
121             
122         # 保存时间戳
123         with open(os.path.join(round_dir, self.TIMESTAMP_FILE), "w", encoding="utf-8") as f:
124             f.write(timestamp)
125 
126         # 保存修改的文件列表
127         if diff_infos:
128             # 使用 Pydantic 的 dict 方法进行序列化
129             diff_dicts = [diff.dict() for diff in diff_infos]
130                 
131             # 序列化为 JSON 并保存
132             with open(os.path.join(round_dir, self.MODIFIED_FILES_FILE), "w", encoding="utf-8") as f:
133                 json.dump(diff_dicts, f, ensure_ascii=False, indent=2)
134             logger.info(f"保存了 {len(diff_infos)} 个修改的文件记录")
135         
136         # 记录日志
137         logger.info(f"已将日志存档至: {round_dir}")
138         
139         # 返回存档目录的路径
140         return round_dir
141 
142     def _get_next_round(self) -> int:
143         """
144         获取下一个轮次号
145 
146         Returns:
147             int: 下一个轮次号
148         """
149         issue_path = self.issues_path
150         if not os.path.exists(issue_path):
151             return 1
152 
153         existing_rounds = [
154             int(d[6:])
155             for d in os.listdir(issue_path)
156             if os.path.isdir(os.path.join(issue_path, d)) and (d[6:]).isdigit()
157         ]
158 
159         return max(existing_rounds, default=0) + 1
160 
161     def get_current_round(self) -> int:
162         return self.current_round
163         
164     def get_issue_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
165         """
166         获取当前issue的所有轮次的日志条目
167 
168         Returns:
169             List[LogEntry]: 日志条目列表，按轮次排序
170         """
171         
172         log_entries = []
173 
174         issue_dir = self.issues_path
175         # 遍历所有轮次目录
176         for dir_name in os.listdir(issue_dir):
177             if not dir_name.startswith("round_"):
178                 continue
179                 
180             try:
181                 round_num = int(dir_name[6:])  # 提取轮次号
182                 round_dir = os.path.join(issue_dir, dir_name)
183                 
184                 # 读取系统提示词
185                 sys_prompt_path = os.path.join(round_dir, self.SYS_PROMPT_FILE)
186                 with open(sys_prompt_path, "r", encoding="utf-8") as f:
187                     sys_prompt = f.read()
188                 
189                 # 读取用户提示词
190                 user_prompt_path = os.path.join(round_dir, self.USER_PROMPT_FILE)
191                 with open(user_prompt_path, "r", encoding="utf-8") as f:
192                     prompt = f.read()
193                 
194                 # 读取AI响应
195                 ai_response_path = os.path.join(round_dir, self.AI_RESPONSE_FILE)
196                 with open(ai_response_path, "r", encoding="utf-8") as f:
197                     response = f.read()
198                     
199                 # 读取修改的文件列表(如果存在)
200                 modified_files = []
201                 if include_diff:
202                     modified_files_path = os.path.join(round_dir, self.MODIFIED_FILES_FILE)
203                     if os.path.exists(modified_files_path):
204                         try:
205                             with open(modified_files_path, "r", encoding="utf-8") as f:
206                                 diff_dicts = json.load(f)
207                                 
208                                 # 将字典转换回 DiffInfo 对象
209                                 modified_files = [DiffInfo(**diff_dict) for diff_dict in diff_dicts]
210                         except Exception as e:
211                             logger.error(f"读取修改文件列表失败: {str(e)}")
212                     
213                 # 读取时间戳
214                 timestamp_path = os.path.join(round_dir, self.TIMESTAMP_FILE)
215                 timestamp = datetime.datetime.now().isoformat()  # 默认当前时间
216                 if os.path.exists(timestamp_path):
217                     try:
218                         with open(timestamp_path, "r", encoding="utf-8") as f:
219                             timestamp = f.read().strip()
220                     except Exception as e:
221                         logger.error(f"读取时间戳失败: {str(e)}")
222                 
223                 # 创建并添加LogEntry对象
224                 entry = LogEntry(issue_id=self.issue_id, round_num=round_num,
225                                  sys_prompt=sys_prompt, prompt=prompt, 
226                                  response=response, timestamp=timestamp, log_path=round_dir,
227                                  modified_files=modified_files)
228                 log_entries.append(entry)
229             except Exception as e:
230                 logger.error(f"读取轮次 {dir_name} 的日志失败: {str(e)}")
231         
232         # 按轮次号排序
233         return sorted(log_entries, key=lambda entry: entry.round_num)
234     
235     def get_issue_round_log_entry(self, round_num: int, include_diff: bool = False) -> Optional[LogEntry]:
236         """
237         获取特定轮次的日志条目
238 
239         Args:
240             round_num: 轮次号
241             include_diff: 是否包含修改信息
242 
243         Returns:
244             Optional[LogEntry]: 指定轮次的日志条目，如果不存在则返回None
245         """
246         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
247         
248         if not os.path.exists(round_dir):
249             logger.warning(f"Issue #{self.issue_id} 的轮次 {round_num} 不存在")
250             return None
251             
252         try:
253             # 直接使用现有方法获取所有轮次，然后过滤出指定轮次
254             all_entries = self.get_issue_log_entries(include_diff)
255             return next((entry for entry in all_entries if entry.round_num == round_num), None)
256         except Exception as e:
257             logger.error(f"获取 Issue #{self.issue_id} 轮次 {round_num} 的日志失败: {str(e)}")
258             return None
259             
260     def rollback_logs(self, target_round: int) -> bool:
261         """
262         将目标轮次之后的日志移至回滚目录
263         
264         Args:
265             target_round: 保留到的轮次，之后的轮次会被移到回滚目录
266             
267         Returns:
268             bool: 操作是否成功
269         """
270         try:
271             # 确保回滚目录存在
272             os.makedirs(self.rollback_path, exist_ok=True)
273             
274             # 获取所有轮次目录
275             round_dirs = [d for d in os.listdir(self.issues_path) 
276                          if os.path.isdir(os.path.join(self.issues_path, d)) 
277                          and d.startswith("round_")]
278             
279             # 筛选出需要回滚的轮次目录
280             rounds_to_rollback = []
281             for dir_name in round_dirs:
282                 try:
283                     round_num = int(dir_name[6:])  # 提取轮次号
284                     if round_num > target_round:
285                         rounds_to_rollback.append((round_num, dir_name))
286                 except ValueError:
287                     continue
288             
289             # 按轮次号排序
290             rounds_to_rollback.sort(key=lambda x: x[0])
291             
292             if not rounds_to_rollback:
293                 logger.info(f"没有轮次需要回滚")
294                 return True
295                 
296             # 移动轮次日志到回滚目录
297             for round_num, dir_name in rounds_to_rollback:
298                 source_path = os.path.join(self.issues_path, dir_name)
299                 dest_path = os.path.join(self.rollback_path, dir_name)
300                 
301                 # 如果目标路径已存在，先删除
302                 if os.path.exists(dest_path):
303                     shutil.rmtree(dest_path)
304                     
305                 # 移动目录
306                 shutil.move(source_path, dest_path)
307                 logger.info(f"已将轮次 {round_num} 的日志移至回滚目录: {dest_path}")
308             
309             # 更新当前轮次
310             self.current_round = self._get_next_round()
311             return True
312             
313         except Exception as e:
314             logger.error(f"回滚日志失败: {str(e)}")
315             return False
316     
317     def get_rollback_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
318         """
319         获取已回滚的所有轮次的日志条目
320 
321         Args:
322             include_diff: 是否包含diff信息
323 
324         Returns:
325             List[LogEntry]: 回滚的日志条目列表，按轮次排序
326         """
327         try:
328             # 如果回滚目录不存在，返回空列表
329             if not os.path.exists(self.rollback_path):
330                 return []
331                 
332             # 临时保存当前issues_path
333             original_path = self.issues_path
334             
335             # 将issues_path指向rollback_path，复用get_issue_log_entries方法
336             self.issues_path = self.rollback_path
337             
338             # 获取回滚目录中的日志条目
339             rollback_entries = self.get_issue_log_entries(include_diff)
340             
341             # 恢复issues_path
342             self.issues_path = original_path
343             
344             return rollback_entries
345         except Exception as e:
346             logger.error(f"获取回滚日志条目失败: {str(e)}")
347             return []
348 
349 if __name__ == "__main__":
350     config = LogConfig("..", 1)
351     log_manager = LogManager(config)
352
```




```
File: core/workflow_engine.py
1 import os
2 import shutil
3 import tempfile
4 import uuid
5 from dataclasses import dataclass
6 from typing import Optional
7 
8 from core.ai import AIConfig
9 from core.chat_processor import ChatProcessor, ChatProcessorConfig
10 from core.code_engineer import CodeEngineer, CodeEngineerConfig
11 from core.decision import DecisionProcess
12 from core.diff import Diff
13 from core.file_memory import FileMemory, FileMemoryConfig
14 from core.file_selector import FileSelector
15 from core.git_manager import GitManager, GitConfig
16 from core.log_config import get_logger
17 from core.log_manager import LogManager, LogConfig
18 from core.prompt_generator import PromptGenerator, PromptData
19 from core.version_manager import VersionManager
20 
21 logger = get_logger(__name__)
22 
23 @dataclass
24 class WorkflowEngineConfig:
25     project_dir: str
26     issue_id:int
27     core_model:str = "gpt-4o"
28     data_model:str = "gpt-4o"
29     core_template: float = 0.7
30     data_template: float = 0.7
31     max_retry: int = 3,
32     default_branch: str = "main"
33     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
34     base_url: Optional[str] = None
35     api_key: Optional[str] = None
36     github_remote_url: Optional[str] =None
37     github_token: Optional[str] = None
38 
39 
40 class WorkflowEngine:
41     CODE_TIMES = 0
42     CHAT_TIMES = 0
43     """
44     工作流引擎，协调版本管理、日志管理和AI交互
45     """
46     def __init__(self, config: WorkflowEngineConfig):
47         """
48         初始化工作流引擎
49         
50         Args:
51             config: 工作流配置
52         """
53         self.CODE_TIMES = 0
54         self.CHAT_TIMES = 0
55         # 存储原始配置
56         self.original_config = config
57         
58         # 根据模式设置工作目录
59         if config.mode == "bot":
60             # 创建临时目录作为工作区
61             self.temp_dir = os.path.join(
62                 tempfile.gettempdir(), 
63                 f"bella-bot-{config.issue_id}-{str(uuid.uuid4())[:8]}"
64             )
65             os.makedirs(self.temp_dir, exist_ok=True)
66             # 更新配置以使用临时目录
67             self.config = WorkflowEngineConfig(
68                 project_dir=self.temp_dir,
69                 **{k: v for k, v in vars(config).items() if k != 'project_dir'}
70             )
71             logger.info(f"Bot模式：创建临时工作目录 {self.temp_dir}")
72         else:
73             # 客户端模式直接使用指定的目录
74             self.config = config
75             self.temp_dir = None
76 
77         self.project_dir = os.path.abspath(self.config.project_dir)
78         # 创建AI配置
79         self.core_ai_config = AIConfig(
80             model_name=config.core_model,
81             temperature=config.core_template,
82             base_url=config.base_url,
83             api_key=config.api_key
84         )
85         
86         self.data_ai_config = AIConfig(
87             model_name=config.data_model,
88             temperature=config.data_template,
89             base_url=config.base_url,
90             api_key=config.api_key
91         )
92         
93         # 创建Git配置
94         self.git_config = GitConfig(
95             repo_path=self.project_dir,
96             remote_url=config.github_remote_url or os.getenv("GIT_REMOTE"),
97             auth_token=config.github_token or os.getenv("GITHUB_TOKEN"),
98             default_branch=config.default_branch
99         )
100         
101         # 创建日志配置
102         self.log_config = LogConfig(
103             project_dir=self.project_dir,
104             issue_id=config.issue_id,
105             mode=config.mode
106         )
107         
108         # 初始化管理器
109         self.git_manager = GitManager(config=self.git_config)
110         self.log_manager = LogManager(config=self.log_config)
111         self.file_memory = FileMemory(
112             config=FileMemoryConfig(
113                 git_manager=self.git_manager,
114                 ai_config=self.core_ai_config,
115                 project_dir=self.project_dir
116             )
117         )
118         self.version_manager = VersionManager(
119             issue_id=config.issue_id,
120             ai_config=self.core_ai_config,
121             log_manager=self.log_manager,
122             git_manager=self.git_manager,
123             file_memory=self.file_memory
124         )
125         self.file_selector = FileSelector(
126             self.project_dir,
127             self.config.issue_id,
128             ai_config=self.core_ai_config
129         )
130 
131         # 初始化代码工程师
132         self.code_engineer_config = CodeEngineerConfig(
133             project_dir=self.project_dir,
134             ai_config=self.core_ai_config
135         )
136         self.engineer = CodeEngineer(
137             self.code_engineer_config,
138             self.log_manager,
139             Diff(self.data_ai_config)
140         )
141         
142         # 初始化聊天处理器
143         self.chat_processor = ChatProcessor(
144             ai_config=self.core_ai_config,
145             log_manager=self.log_manager,
146             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
147         )
148         
149         # 初始化决策环境
150         self.decision_env = DecisionProcess(
151             ai_config=self.core_ai_config,
152             version_manager=self.version_manager
153         )
154     
155     def process_requirement(self, user_requirement: str) -> Optional[str]:
156         """
157         处理用户需求
158         
159         Args:
160             user_requirement: 用户需求
161 
162         Returns:
163             str: 处理结果的响应文本
164         """
165         try:
166             # 初始化环境
167             self._setup_environment()
168             
169             response = self._process_requirement_internal(user_requirement)
170             
171             # 如果是bot模式，在结束时清理临时目录
172             if self.config.mode == "bot":
173                 self._cleanup_environment()
174             
175             return response
176         except Exception as e:
177             logger.error(f"处理需求时发生错误: {str(e)}")
178             raise
179 
180     def _setup_environment(self) -> None:
181         """
182         根据模式设置工作环境
183         """
184         if self.config.mode == "bot":
185             try:
186                 # 重置到issue对应的分支
187                 self.git_manager.reset_to_issue_branch(self.config.issue_id)
188                 logger.info(f"成功初始化Bot模式环境，工作目录: {self.temp_dir}")
189             except Exception as e:
190                 logger.error(f"初始化Bot模式环境失败: {str(e)}")
191                 self._cleanup_environment()
192                 raise
193         current_round = self.log_manager.get_current_round()
194 
195         # 如果轮次大于1，增量更新上一轮修改的文件详细信息
196         if self.file_memory and current_round > 1:
197             self.file_memory.update_file_details()
198             logger.info("已更新文件详细信息")
199         
200     def _cleanup_environment(self) -> None:
201         """
202         清理工作环境，删除临时目录
203         """
204         if self.config.mode == "bot" and self.temp_dir and os.path.exists(self.temp_dir):
205             try:
206                 # 关闭git仓库连接
207                 if hasattr(self, 'git_manager') and self.git_manager:
208                     self.git_manager.delete_local_repository()
209                 
210                 # 删除临时目录
211                 shutil.rmtree(self.temp_dir, ignore_errors=True)
212                 logger.info(f"已清理临时工作目录: {self.temp_dir}")
213             except Exception as e:
214                 logger.warning(f"清理临时目录时出错: {str(e)}")
215                 # 即使清理失败也不抛出异常，让主流程继续
216 
217     def _process_requirement_internal(self, user_requirement: str) -> Optional[str]:
218         """
219         内部处理需求的方法
220         
221         Args:
222             user_requirement: 用户需求
223             
224         Returns:
225             str: 处理结果
226         """
227         # 先通过决策环境分析需求类型
228         decision_result = self.decision_env.analyze_requirement(user_requirement)
229         
230         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
231                     f"理由={decision_result.reasoning}")
232         
233         if decision_result.needs_code_modification:
234             # 执行代码修改流程
235             # 创建或获取分支名，用于提交
236             branch_name = f"bella-bot-issues-{self.config.issue_id}"
237             response = self._run_code_generation_workflow(user_requirement)
238         else: 
239             # 执行对话流程
240             response = self._run_chat_workflow(user_requirement)
241         
242         # 如果是Bot模式且有GitHub配置，自动回复到issue
243         if self.config.mode == "bot":
244             try:
245                 self.version_manager.finalize_changes(mode=self.config.mode, branch_name=branch_name, issue_id=self.config.issue_id, comment_text=response)
246                 logger.info(f"更改已经推送到远端，并添加了Issue评论")
247             except Exception as e:
248                 logger.error(f"添加Issue评论时出错: {str(e)}")
249                 
250         return response
251     
252     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
253         """
254         执行代码生成流程，基于example_code_generate.py的逻辑
255         
256         Args:
257             user_requirement: 用户需求
258             
259         Returns:
260             str: 处理结果
261         """
262         logger.info("开始执行代码生成流程")
263 
264         # 确定当前版本
265         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
266 
267         # 生成提示词
268         user_prompt = self._get_user_prompt(requirement, history)
269 
270         # 根据提示词修改代码
271         success, response = self.engineer.process_prompt(prompt=user_prompt)
272 
273         # 提交更改
274         if success:
275             return response
276         else:
277             self.CODE_TIMES += 1
278             if self.CODE_TIMES >= self.config.max_retry:
279                 logger.error("code workflow超过最大重试次数")
280                 return self._run_chat_workflow(user_requirement)
281             else:
282                 return self._run_code_generation_workflow(user_requirement)
283     
284     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
285         """
286         执行聊天流程，基于example_chat_process.py的逻辑
287         
288         Args:
289             user_requirement: 用户需求
290             
291         Returns:
292             str: 处理结果
293         """
294         logger.info("开始执行聊天回复流程")
295 
296         history = self.version_manager.get_formatted_history()
297 
298         # 生成提示词
299         user_prompt = self._get_user_prompt(user_requirement, history)
300         
301         # 处理聊天请求
302         response = self.chat_processor.process_chat(user_prompt)
303 
304         if(response):
305             return response
306         else:
307             self.CHAT_TIMES += 1
308             if self.CHAT_TIMES >= self.config.max_retry:
309                 logger.error("chat workflow超过最大重试次数")
310                 return None
311             else:
312                 return self._run_chat_workflow(user_requirement)
313 
314     def _get_user_prompt(self, requirement: str, history: str) -> str:
315         # 选择文件
316         files = self.file_selector.select_files_for_requirement(requirement)
317         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
318 
319         # 准备提示词数据
320         data = PromptData(
321             requirement=requirement,
322             project_dir=self.project_dir,
323             steps=history,
324             files=files,
325             file_desc=descriptions
326         )
327 
328         # 生成提示词
329         return PromptGenerator.generatePrompt(data)
330
```




# 历史执行信息

=========================以上【历史执行记录】内容为历史执行过程，所有代码改动均已经生效========================================
=========================经过分析后续的历史执行过程不符合用户需求，已经回滚，不在此展示============================


# 用户需求


    目前的FileMemory只能根据git提交记录修改。改为可以根据LogManager取前一次round的新增文件，做增量修改
    