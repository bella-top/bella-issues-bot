# 项目文件描述


- README.md: 项目主文档，介绍bella-issues-bot工具的功能、特性、安装方法和使用场景。该工具支持个人开发助手和GitHub自动化两种工作模式，可通过命令行或编程API使用。

- client/README.md: 客户端使用说明文档，介绍Workflow客户端的功能、工作模式、命令行参数和使用方法。详细说明了客户端和机器人两种模式，以及如何通过CLI和编程方式使用该工具。

- core/log_manager.py: 管理代码生成日志的存储和检索。包含LogManager类，用于存档系统提示词、用户提示词、AI响应等内容，支持按issue和轮次组织日志。提供archive_logs和get_issue_log_entries等方法，记录代码生成过程。

- core/version_manager.py: 版本管理模块，负责代码生成的版本控制、历史追踪和回退功能。包含VersionInfo数据类和VersionManager类，实现版本信息提取、历史记录格式化、需求分析和版本回退等功能。与AI助手、Git管理器和日志管理器交互，提供版本控制工具。

- core/file_memory.py: 文件记忆管理模块，负责存储和更新文件描述信息。FileMemory类通过AI为项目文件生成描述并跟踪变更，支持批量处理和失败重试机制。

- core/workflow_engine.py: 工作流引擎模块，作为系统核心协调各组件工作。实现WorkflowEngine类，根据用户需求决策执行代码生成或聊天流程，管理环境初始化和清理，支持客户端和bot两种工作模式。

- core/log_config.py: 日志配置模块，提供统一的日志设置功能。实现了setup_logging和get_logger函数，配置彩色控制台输出和文件日志记录，支持日志轮换。

- scripts/run_bot.sh: 便捷启动脚本，简化了命令行参数输入。检查参数并调用Python客户端模块，支持从文件读取需求或交互式输入需求。

- client/terminal.py: 工作流引擎的终端入口点，提供命令行接口。实现run_workflow_from_terminal函数解析命令行参数、加载配置并运行工作流引擎。

- client/runner.py: 工作流引擎的编程接口模块，提供run_workflow函数简化在Python脚本中调用工作流引擎的过程，处理配置参数和环境变量加载。

- client/cli.py: 命令行接口模块，提供解析命令行参数的功能，包含parse_args()、get_requirement_text()和build_config_from_args()函数，用于配置和运行WorkflowEngine。


# 文件内容



```
File: README.md
1 # bella-issues-bot
2 
3 ## 项目简介
4 
5 bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：
6 
7 1. **个人开发助手模式**：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。
8 2. **GitHub自动化模式**：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。
9 
10 通过对项目结构的深入理解和强大的代码生成能力，bella-issues-bot 能够显著提高开发效率，减少重复工作，让您专注于更有创造性的任务。
11 
12 ## 主要功能
13 
14 - 需求分析：自动理解和分解用户的功能需求
15 - 代码生成：根据需求生成符合项目风格的代码
16 - 版本管理：与Git集成，支持分支创建和代码提交
17 - GitHub集成：支持与GitHub仓库交互
18 
19 ### 个人开发模式特性
20 
21 - 实时代码生成：根据描述快速生成代码片段或完整功能
22 - 智能问答：针对代码库回答技术问题，提供解释和建议
23 
24 ### GitHub自动化模式特性
25 
26 - Issues自动处理：监听新Issues，自动分析需求并生成解决方案
27 - 代码审查：审查提交的代码，提出优化建议
28 
29 ## 安装方法
30 
31 使用pip安装：
32 
33 ```bash
34 pip install bella-issues-bot
35 ```
36 
37 ## 使用方法
38 
39 bella-issues-bot 提供了多种使用方式：
40 
41 ### 个人开发模式
42 
43 在日常开发中，您可以通过命令行界面或编程API使用bella-issues-bot：
44 
45 ### 命令行使用
46 
47 ```bash
48 bella-issues-bot --issue-id <问题ID> --requirement "你的需求描述"
49 ```
50 
51 更多高级选项和详细使用说明，请参考[客户端文档](./client/README.md)。
52 
53 ### 编程API使用
54 
55 ```python
56 from client.runner import run_workflow
57 
58 run_workflow(
59     issue_id=42,
60     requirement="创建一个简单的README文件",
61     core_temperature=0.7
62 )
63 ```
64 
65 ## 配置环境变量
66 
67 工具会读取以下环境变量：
68 
69 - `OPENAI_API_KEY`: OpenAI API密钥
70 - `OPENAI_API_BASE`: OpenAI API基础URL
71 - `GITHUB_REMOTE_URL`: GitHub远程仓库URL
72 - `GITHUB_TOKEN`: GitHub身份验证令牌
73 
74 ## 示例
75 
76 可以在[examples](./examples/)目录下找到使用示例。
77
```




```
File: client/README.md
1 # Workflow 客户端
2 
3 一个强大的命令行接口和编程API，用于运行WorkflowEngine处理用户需求，支持个人开发助手模式和GitHub自动化工作流模式。
4 
5 ## 工作模式
6 
7 bella-issues-bot 支持两种主要工作模式：
8 
9 - **客户端模式 (client)**：默认模式，适合作为个人开发助手使用，每次运行时基于project_dir目录下的当前代码状态进行操作。
10 - **机器人模式 (bot)**：专为GitHub集成设计，会在project_dir目录下创建临时目录作为工作区，自动拉取issues对应的最新分支状态，处理完成后自动提交更改并在Issues中回复处理结果，最后清理临时工作区。
11 ## 命令行使用方式（个人开发助手模式）
12 
13 你可以通过以下两种方式从命令行运行WorkflowEngine：
14 
15 ### 使用安装后的CLI命令
16 
17 ```bash
18 bella-issues-bot --issue-id 42 --requirement "创建一个README文件"
19 ```
20 
21 ### 直接使用Python模块
22 
23 ```bash
24 python -m client.terminal --issue-id 42 --requirement "创建一个README文件"
25 ```
26 
27 ### 命令行参数
28 
29 #### 基础参数
30 
31 - `--issue-id`：（必需）问题ID，用于跟踪和引用
32 - `--requirement` 或 `--requirement-file`：（必需）具体需求描述或包含需求的文件路径
33 - `--project-dir`：项目目录路径（默认：当前目录）
34 
35 #### AI模型配置
36 
37 - `--core-model`：核心AI操作使用的模型（默认：gpt-4o）
38 - `--data-model`：数据操作使用的模型（默认：gpt-4o）
39 - `--core-temperature`：核心模型的温度参数（默认：0.7）
40 - `--data-temperature`：数据模型的温度参数（默认：0.7）
41 
42 #### 工作流配置
43 
44 - `--mode`：工作模式，可选"client"或"bot"（默认：client）
45   - `client`：个人开发助手模式，基于当前代码状态工作
46   - `bot`：GitHub自动化模式，拉取最新分支，自动提交并回复Issues
47 - `--default-branch`：默认Git分支（默认：main）
48 - `--base-url`：API调用的基础URL
49 - `--api-key`：API密钥（也可以通过OPENAI_API_KEY环境变量设置）
50 - `--github-remote-url`：GitHub远程URL
51 - `--github-token`：GitHub令牌
52 
53 #### 执行控制
54 
55 - `--max-retry`：最大重试次数（默认：3）
56 
57 ### 简易脚本使用
58 
59 你也可以使用提供的脚本简化命令行调用：
60 
61 ```bash
62 ./scripts/run_bot.sh <问题ID> [需求文件路径]
63 ```
64 
65 ## 编程方式使用
66 
67 你也可以在Python代码中以编程方式使用客户端包：
68 
69 ```python
70 from client.runner import run_workflow
71 
72 run_workflow(
73     issue_id=42,
74     requirement="为项目创建一个README文件",
75     core_model="gpt-4o",
76     data_model="gpt-4o",
77     core_temperature=0.7,
78     data_temperature=0.7
79 )
80 ```
81 
82 ## 环境变量
83 
84 工具会读取以下环境变量：
85 
86 - `OPENAI_API_KEY`：OpenAI的API密钥
87 - `OPENAI_API_BASE`：OpenAI API的基础URL
88 - `GITHUB_TOKEN`：GitHub身份验证令牌
89
```




```
File: core/log_manager.py
1 import datetime
2 import os
3 import json
4 import shutil
5 from dataclasses import dataclass, field
6 from typing import List, Optional
7 from pydantic import BaseModel
8 
9 from core.diff import DiffInfo
10 from core.log_config import get_logger
11 
12 logger = get_logger(__name__)
13 
14 @dataclass
15 class LogConfig:
16     """日志管理配置"""
17 
18     project_dir: str
19     issue_id: int
20     mode: str = "client" # ["client", "bot"]
21 
22 
23 class LogEntry(BaseModel):
24     """存储单次代码生成日志的数据类"""
25     issue_id: int
26     round_num: int
27     sys_prompt: str
28     prompt: str
29     response: str
30     timestamp: str = datetime.datetime.now().isoformat()
31     log_path: str = ""
32     modified_files: List[DiffInfo] = []
33 
34 
35 class LogManager:
36     """管理代码生成日志的存档和检索"""
37     base_dir: str = ".eng"
38     logs_base_dir: str = "memory"
39     rollback_dir: str = "rollback"
40 
41     def __init__(self, config: LogConfig):
42         """
43         初始化日志管理器
44 
45         Args:
46             config: LogConfig实例，包含必要的配置信息
47         """
48         self.config = config
49         self.issue_id = self.config.issue_id
50 
51         
52         # 根据模式选择存储目录
53         if self.config.mode == "bot":
54             logs_dir = "issues"
55         else:
56             logs_dir = "queries"
57             
58         # 构建完整的日志存储路径
59         self.logs_path = os.path.join(
60             self.config.project_dir, 
61             self.base_dir,
62             self.logs_base_dir,
63             logs_dir)
64         self.issues_path = os.path.join(
65             self.logs_path, "#" + str(self.issue_id)
66         )
67 
68         self.rollback_path = os.path.join(
69             self.logs_path, "#" + str(self.issue_id), self.rollback_dir
70         )
71 
72         # 初始化当前轮次
73         self.current_round = self._get_next_round()
74 
75         # 确保必要的目录存在
76         os.makedirs(self.issues_path, exist_ok=True)
77         os.makedirs(self.rollback_path, exist_ok=True)
78 
79         # 定义日志文件名常量
80         self.SYS_PROMPT_FILE = "system_prompt.txt"
81         self.USER_PROMPT_FILE = "user_prompt.txt"
82         self.AI_RESPONSE_FILE = "ai_response.txt"
83         self.TIMESTAMP_FILE = "timestamp.txt"
84         self.MODIFIED_FILES_FILE = "modified_files.txt"
85 
86     def archive_logs(self, sys_prompt: str, prompt: str, response: str, diff_infos: List[DiffInfo] = None) -> str:
87         """
88         将代码生成日志存档到指定的目录
89 
90         Args:
91             diff_infos: 文件的修改信息
92             sys_prompt: 系统提示词
93             prompt: 用户提示词
94             response: AI响应
95 
96         Returns:
97             str: 存档目录的路径
98         """
99         # 获取下一个轮次号
100 
101         round_num = self.current_round
102 
103         # 获取当前时间戳
104         timestamp = datetime.datetime.now().isoformat()
105         
106         # 创建轮次目录
107         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
108         os.makedirs(round_dir, exist_ok=True)
109         
110         # 保存系统提示词
111         with open(os.path.join(round_dir, self.SYS_PROMPT_FILE), "w", encoding="utf-8") as f:
112             f.write(sys_prompt)
113         
114         # 保存用户提示词
115         with open(os.path.join(round_dir, self.USER_PROMPT_FILE), "w", encoding="utf-8") as f:
116             f.write(prompt)
117         
118         # 保存AI响应
119         with open(os.path.join(round_dir, self.AI_RESPONSE_FILE), "w", encoding="utf-8") as f:
120             f.write(response)
121             
122         # 保存时间戳
123         with open(os.path.join(round_dir, self.TIMESTAMP_FILE), "w", encoding="utf-8") as f:
124             f.write(timestamp)
125 
126         # 保存修改的文件列表
127         if diff_infos:
128             # 使用 Pydantic 的 dict 方法进行序列化
129             diff_dicts = [diff.dict() for diff in diff_infos]
130                 
131             # 序列化为 JSON 并保存
132             with open(os.path.join(round_dir, self.MODIFIED_FILES_FILE), "w", encoding="utf-8") as f:
133                 json.dump(diff_dicts, f, ensure_ascii=False, indent=2)
134             logger.info(f"保存了 {len(diff_infos)} 个修改的文件记录")
135         
136         # 记录日志
137         logger.info(f"已将日志存档至: {round_dir}")
138         
139         # 返回存档目录的路径
140         return round_dir
141 
142     def _get_next_round(self) -> int:
143         """
144         获取下一个轮次号
145 
146         Returns:
147             int: 下一个轮次号
148         """
149         issue_path = self.issues_path
150         if not os.path.exists(issue_path):
151             return 1
152 
153         existing_rounds = [
154             int(d[6:])
155             for d in os.listdir(issue_path)
156             if os.path.isdir(os.path.join(issue_path, d)) and (d[6:]).isdigit()
157         ]
158 
159         return max(existing_rounds, default=0) + 1
160 
161     def get_current_round(self) -> int:
162         return self.current_round
163         
164     def get_issue_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
165         """
166         获取当前issue的所有轮次的日志条目
167 
168         Returns:
169             List[LogEntry]: 日志条目列表，按轮次排序
170         """
171         
172         log_entries = []
173 
174         issue_dir = self.issues_path
175         # 遍历所有轮次目录
176         for dir_name in os.listdir(issue_dir):
177             if not dir_name.startswith("round_"):
178                 continue
179                 
180             try:
181                 round_num = int(dir_name[6:])  # 提取轮次号
182                 round_dir = os.path.join(issue_dir, dir_name)
183                 
184                 # 读取系统提示词
185                 sys_prompt_path = os.path.join(round_dir, self.SYS_PROMPT_FILE)
186                 with open(sys_prompt_path, "r", encoding="utf-8") as f:
187                     sys_prompt = f.read()
188                 
189                 # 读取用户提示词
190                 user_prompt_path = os.path.join(round_dir, self.USER_PROMPT_FILE)
191                 with open(user_prompt_path, "r", encoding="utf-8") as f:
192                     prompt = f.read()
193                 
194                 # 读取AI响应
195                 ai_response_path = os.path.join(round_dir, self.AI_RESPONSE_FILE)
196                 with open(ai_response_path, "r", encoding="utf-8") as f:
197                     response = f.read()
198                     
199                 # 读取修改的文件列表(如果存在)
200                 modified_files = []
201                 if include_diff:
202                     modified_files_path = os.path.join(round_dir, self.MODIFIED_FILES_FILE)
203                     if os.path.exists(modified_files_path):
204                         try:
205                             with open(modified_files_path, "r", encoding="utf-8") as f:
206                                 diff_dicts = json.load(f)
207                                 
208                                 # 将字典转换回 DiffInfo 对象
209                                 modified_files = [DiffInfo(**diff_dict) for diff_dict in diff_dicts]
210                         except Exception as e:
211                             logger.error(f"读取修改文件列表失败: {str(e)}")
212                     
213                 # 读取时间戳
214                 timestamp_path = os.path.join(round_dir, self.TIMESTAMP_FILE)
215                 timestamp = datetime.datetime.now().isoformat()  # 默认当前时间
216                 if os.path.exists(timestamp_path):
217                     try:
218                         with open(timestamp_path, "r", encoding="utf-8") as f:
219                             timestamp = f.read().strip()
220                     except Exception as e:
221                         logger.error(f"读取时间戳失败: {str(e)}")
222                 
223                 # 创建并添加LogEntry对象
224                 entry = LogEntry(issue_id=self.issue_id, round_num=round_num,
225                                  sys_prompt=sys_prompt, prompt=prompt, 
226                                  response=response, timestamp=timestamp, log_path=round_dir,
227                                  modified_files=modified_files)
228                 log_entries.append(entry)
229             except Exception as e:
230                 logger.error(f"读取轮次 {dir_name} 的日志失败: {str(e)}")
231         
232         # 按轮次号排序
233         return sorted(log_entries, key=lambda entry: entry.round_num)
234     
235     def get_issue_round_log_entry(self, round_num: int, include_diff: bool = False) -> Optional[LogEntry]:
236         """
237         获取特定轮次的日志条目
238 
239         Args:
240             round_num: 轮次号
241             include_diff: 是否包含修改信息
242 
243         Returns:
244             Optional[LogEntry]: 指定轮次的日志条目，如果不存在则返回None
245         """
246         round_dir = os.path.join(self.issues_path, f"round_{round_num}")
247         
248         if not os.path.exists(round_dir):
249             logger.warning(f"Issue #{self.issue_id} 的轮次 {round_num} 不存在")
250             return None
251             
252         try:
253             # 直接使用现有方法获取所有轮次，然后过滤出指定轮次
254             all_entries = self.get_issue_log_entries(include_diff)
255             return next((entry for entry in all_entries if entry.round_num == round_num), None)
256         except Exception as e:
257             logger.error(f"获取 Issue #{self.issue_id} 轮次 {round_num} 的日志失败: {str(e)}")
258             return None
259             
260     def rollback_logs(self, target_round: int) -> bool:
261         """
262         将目标轮次之后的日志移至回滚目录
263         
264         Args:
265             target_round: 保留到的轮次，之后的轮次会被移到回滚目录
266             
267         Returns:
268             bool: 操作是否成功
269         """
270         try:
271             # 确保回滚目录存在
272             os.makedirs(self.rollback_path, exist_ok=True)
273             
274             # 获取所有轮次目录
275             round_dirs = [d for d in os.listdir(self.issues_path) 
276                          if os.path.isdir(os.path.join(self.issues_path, d)) 
277                          and d.startswith("round_")]
278             
279             # 筛选出需要回滚的轮次目录
280             rounds_to_rollback = []
281             for dir_name in round_dirs:
282                 try:
283                     round_num = int(dir_name[6:])  # 提取轮次号
284                     if round_num > target_round:
285                         rounds_to_rollback.append((round_num, dir_name))
286                 except ValueError:
287                     continue
288             
289             # 按轮次号排序
290             rounds_to_rollback.sort(key=lambda x: x[0])
291             
292             if not rounds_to_rollback:
293                 logger.info(f"没有轮次需要回滚")
294                 return True
295                 
296             # 移动轮次日志到回滚目录
297             for round_num, dir_name in rounds_to_rollback:
298                 source_path = os.path.join(self.issues_path, dir_name)
299                 dest_path = os.path.join(self.rollback_path, dir_name)
300                 
301                 # 如果目标路径已存在，先删除
302                 if os.path.exists(dest_path):
303                     shutil.rmtree(dest_path)
304                     
305                 # 移动目录
306                 shutil.move(source_path, dest_path)
307                 logger.info(f"已将轮次 {round_num} 的日志移至回滚目录: {dest_path}")
308             
309             # 更新当前轮次
310             self.current_round = self._get_next_round()
311             return True
312             
313         except Exception as e:
314             logger.error(f"回滚日志失败: {str(e)}")
315             return False
316     
317     def get_rollback_log_entries(self, include_diff: bool = False) -> List[LogEntry]:
318         """
319         获取已回滚的所有轮次的日志条目
320 
321         Args:
322             include_diff: 是否包含diff信息
323 
324         Returns:
325             List[LogEntry]: 回滚的日志条目列表，按轮次排序
326         """
327         try:
328             # 如果回滚目录不存在，返回空列表
329             if not os.path.exists(self.rollback_path):
330                 return []
331                 
332             # 临时保存当前issues_path
333             original_path = self.issues_path
334             
335             # 将issues_path指向rollback_path，复用get_issue_log_entries方法
336             self.issues_path = self.rollback_path
337             
338             # 获取回滚目录中的日志条目
339             rollback_entries = self.get_issue_log_entries(include_diff)
340             
341             # 恢复issues_path
342             self.issues_path = original_path
343             
344             return rollback_entries
345         except Exception as e:
346             logger.error(f"获取回滚日志条目失败: {str(e)}")
347             return []
348 
349 if __name__ == "__main__":
350     config = LogConfig("..", 1)
351     log_manager = LogManager(config)
352
```




```
File: core/version_manager.py
1 """
2 版本管理模块，处理代码生成的版本控制、历史追踪和回退功能。
3 
4 该模块提供了以下功能:
5 1. 提取历史轮次的日志信息
6 2. 格式化历史执行记录用于AI参考
7 3. 分析用户需求，决定是否需要版本回退
8 4. 执行Git版本回退操作
9 5. 为AI助手提供版本回退工具
10 """
11 
12 import os
13 from dataclasses import dataclass
14 from typing import List, Tuple, Optional
15 
16 from langchain_core.tools import Tool, StructuredTool
17 from pydantic import BaseModel, Field
18 
19 from core.ai import AIConfig, AIAssistant
20 from core.git_manager import GitManager
21 from core.log_config import get_logger
22 from core.log_manager import LogManager
23 from core.prompt_generator import PromptGenerator
24 
25 logger = get_logger(__name__)
26 
27 @dataclass
28 class VersionInfo:
29     """存储特定版本的信息"""
30     issue_id: int
31     round_num: int
32     requirement: str
33     agent_response: str
34     modified_files: List[str] = None
35 
36 
37 class VersionManager:
38     """管理代码生成的版本信息，支持版本回退和需求整合"""
39 
40     def __init__(self, issue_id: int, ai_config: AIConfig, log_manager: LogManager, git_manager: GitManager, file_memory=None):
41         """
42         初始化版本管理器
43         
44         Args:
45             issue_id: GitHub issue编号
46             ai_config: AI配置
47             log_manager: 日志管理器实例 
48             git_manager: Git管理器实例
49             file_memory: 文件内存管理器实例(可选)
50         """
51         self.ai_assistant = AIAssistant(config=ai_config, tools=[self._create_version_manager_tool()])
52         self.file_memory = file_memory
53         self.log_manager = log_manager
54         self.git_manager = git_manager
55         self.current_issue_id = issue_id
56         self.current_round_num = log_manager.get_current_round()
57 
58     def ensure_version_and_generate_context(self, original_requirement: str) -> tuple[str, str]:
59         requirement = None
60         if self.current_round_num > 1 :
61             rollback, rollback_num, requirement, reasoning = self._analyze_rollback_need(requirement)
62         requirement = original_requirement if requirement is None else requirement
63         history = self.get_formatted_history()
64         return requirement, history
65     
66     def finalize_changes(self, mode: str, comment_text: str) -> bool:
67         """
68         完成更改，在bot模式下提交并推送更改
69         
70         Args:
71             mode: 工作模式 ("client" 或 "bot")
72             comment_text: comment内容
73 
74         Returns:
75             bool: 操作是否成功
76         """
77         if mode == "bot":
78             branch_name = f"bella-bot-issues-{self.current_issue_id}"
79             self.git_manager.commit(f"Issues #{self.current_issue_id} - Changes by Bella-Issues-Bot")
80             self.git_manager.push(branch=branch_name, force=False, set_upstream=True)
81             self.git_manager.add_issue_comment(self.current_issue_id, comment_text)
82         return True
83 
84     
85     def _extract_history(self) -> List[VersionInfo]:
86         """
87         提取当前issue的历史版本信息
88             
89         Returns:
90             List[VersionInfo]: 历史版本信息列表
91         """
92         # 获取所有轮次的日志条目
93         log_entries = self.log_manager.get_issue_log_entries()
94         
95         # 提取每轮的需求和响应
96         version_info_list = []
97         for entry in log_entries:
98             try:
99                 # 从用户提示中提取需求
100                 extracted_info = PromptGenerator.extractInfo(entry.prompt)
101                 requirement = extracted_info.requirement
102                 
103                 # 创建版本信息
104                 version_info = VersionInfo(
105                     issue_id=self.current_issue_id,
106                     round_num=entry.round_num,
107                     requirement=requirement,
108                     agent_response=entry.response,
109                     modified_files=entry.modified_files
110                 )
111                 version_info_list.append(version_info)
112                 
113             except Exception as e:
114                 logger.error(f"提取轮次 {entry.round_num} 的信息时出错: {str(e)}")
115         
116         return version_info_list
117 
118     def get_formatted_history(self) -> str:
119         """
120         获取格式化的历史执行记录
121         
122         Args:
123             
124         Returns:
125             str: 格式化的历史执行记录
126         """
127         history = self._extract_history()
128         formatted_history = []
129         
130         for version in history:
131             formatted_history.append(f"【round_{version.round_num}】")
132             formatted_history.append(f"requirement: \n{version.requirement}")
133             
134             # 简化AI响应，避免历史记录过长
135             formatted_history.append(f"agent_response: \n{version.agent_response}")
136             formatted_history.append("")  # 添加空行分隔
137         return "\n".join(formatted_history)
138 
139     def _analyze_rollback_need(self,
140                               current_requirement: str) -> Tuple[bool, Optional[int], Optional[str], Optional[str]]:
141         """
142         分析是否需要版本回退
143         
144         Args:
145             current_requirement: 当前用户需求
146             
147         Returns:
148             Tuple[bool, int, str, str]: (是否需要回退, 回退到的轮次, 整合后的需求，决策的原因)
149         """
150         # 获取历史记录
151         history = self.get_formatted_history()
152         
153         # 构建提示词
154         prompt = f"""
155 # 角色
156 你是一位资深程序员，现在在处理用户的issues，请分析本次用户提出的需求和历史执行记录，判断之前提交的代码是否需要版本回退。并调用工具完成版本的创建。
157 
158 # 历史执行记录
159 {history}
160 
161 # 当前用户需求
162 {current_requirement}
163 
164 
165 #执行步骤
166 ##工具参数分析
167 你需要调用 version_manager 工具来处理问题，请请根据上述信息分析以下问题，
168 1. 是否需要回退到某个特定版本? 如果需要，则调用工具时的参数 need_rollback 为 True
169 2. 如果需要回退，应该回退到哪个round?  调用工具时的参数，大于等于0，如果全部回滚则设置为0
170 3. 如果需要回退，当前需求的信息是否完整？需要把回退到的round之后的round需求与当前需求结合，作为补充信息吗? 如果需要结合，则将重写后的本轮需求，作为integrated_requirement参数；如果不需要则不需要此参数。
171 4. 做出这个决策的原因是什么？调用工具时，作为reasoning参数
172 
173 ##工具执行
174 根据得到的参数，调用version_manager。无论是否需要rollback必须调用工具执行任务，完成当前版本的创建。
175 
176 """
177 
178         # 发送给AI进行分析
179         response = self.ai_assistant.generate_response(prompt, use_tools=True)
180 
181         return response if response else (False, 0, current_requirement)
182 
183     def _rollback_to_version(self, target_round: int) -> bool:
184         """
185         执行基于文件的版本回退
186         
187         Args:
188             target_round: 目标轮次
189             
190         Returns:
191             bool: 回退是否成功
192         """
193         try:
194             # 获取目标轮次的日志条目
195             log_entries = self.log_manager.get_issue_log_entries(include_diff=True)
196             
197             if not log_entries:
198                 logger.error("找不到任何日志条目")
199                 return False
200             
201             # 获取当前轮次到目标轮次之间的所有轮次记录，按轮次降序排列（从最新到最旧）
202             entries_to_rollback = sorted(
203                 [entry for entry in log_entries if entry.round_num > target_round],
204                 key=lambda entry: entry.round_num,
205                 reverse=True
206             )
207             
208             if not entries_to_rollback:
209                 logger.info(f"当前已经是轮次 {target_round} 或更早，无需回滚")
210                 return True
211             
212             # 依次回滚每一轮的修改
213             import os
214             project_dir = self.log_manager.config.project_dir
215             
216             for entry in entries_to_rollback:
217                 logger.info(f"正在回滚轮次 {entry.round_num} 的修改...")
218                 
219                 if not entry.modified_files:
220                     logger.info(f"轮次 {entry.round_num} 没有文件修改，跳过")
221                     continue
222                 
223                 # 对每个修改的文件进行回滚
224                 for diff_info in entry.modified_files:
225                     file_path = os.path.join(project_dir, diff_info.file_name)
226                     
227                     if diff_info.is_create:
228                         # 如果是创建操作，则删除该文件
229                         if os.path.exists(file_path):
230                             os.remove(file_path)
231                             logger.info(f"删除文件 {diff_info.file_name}，回滚轮次 {entry.round_num} 的创建操作")
232                     
233                     elif diff_info.is_modify:
234                         # 如果是修改操作，则恢复到修改前的内容
235                         if diff_info.file_content is not None:
236                             os.makedirs(os.path.dirname(file_path), exist_ok=True)
237                             with open(file_path, "w", encoding="utf-8") as f:
238                                 f.write(diff_info.file_content)
239                             logger.info(f"恢复文件 {diff_info.file_name} 到轮次 {entry.round_num} 修改前的状态")
240                         else:
241                             logger.warning(f"文件 {diff_info.file_name} 没有保存修改前的内容，无法回滚")
242                     
243                     elif diff_info.is_delete:
244                         # 如果是删除操作，则恢复文件
245                         if diff_info.file_content is not None:
246                             os.makedirs(os.path.dirname(file_path), exist_ok=True)
247                             with open(file_path, "w", encoding="utf-8") as f:
248                                 f.write(diff_info.file_content)
249                             logger.info(f"恢复文件 {diff_info.file_name}，回滚轮次 {entry.round_num} 的删除操作")
250                         else:
251                             logger.warning(f"文件 {diff_info.file_name} 没有保存删除前的内容，无法回滚")
252 
253             self.log_manager.rollback_logs(target_round)
254             logger.info(f"成功回滚到轮次 {target_round}")
255             return True
256             
257         except Exception as e:
258             logger.error(f"文件版本回退失败: {str(e)}")
259             return False
260 
261     def _rollback_to_version_git(self, target_round: int) -> bool:
262         """
263         执行版本回退
264         
265         Args:
266             target_round: 目标轮次
267             
268         Returns:
269             bool: 回退是否成功
270         """
271         try:
272             # 构建目标分支名
273             target_branch = f"bella-bot-issues-{self.current_issue_id}-{target_round}"
274             return self.git_manager.reset_to(target_branch)
275             
276         except Exception as e:
277             logger.error(f"Git版本回退失败: {str(e)}")
278             return False
279 
280     class _VersionManagerToolSchema(BaseModel):
281         need_rollback: bool = Field(
282             ...,
283             examples=[True, False],
284             description="是否需要回退版本"
285         )
286         target_round: Optional[int] = Field(
287             None,
288             examples=[0,1,2,3,4],
289             description="要回滚到的目标轮次，只有need_rollback为True时需要且必须.0代表需要全部回滚。"
290         )
291         integrated_requirement: Optional[str] = Field(
292             None,
293             description="整合后的需求，只有need_rollback为True且需要重写需求时需要"
294         )
295         reasoning: Optional[str] = Field(
296             None,
297             description="做这个出决策的原因"
298         )
299 
300     def _create_version_manager_tool(self) -> StructuredTool:
301         """
302         版本管理工具，供AI助手使用
303             
304         Returns:
305             Tool: 版本管理工具
306         """
307         def version_manager_tool(need_rollback: bool,
308                                           target_round: Optional[int] = None,
309                                           integrated_requirement: Optional[str] = None,
310                                           reasoning: Optional[str] = None) -> Tuple[str, Optional[int], Optional[str], Optional[str]]:
311             """
312             决定是否回退版本并执行回退
313             
314             Args:
315                 need_rollback:是否需要回退,
316                 target_round：回退到的轮次,
317                 integrated_requirement： 整合后的需求
318                 reasoning: 做出决策的原因
319                 
320             Returns:
321                 str: 执行结果
322             """
323             
324             if need_rollback and target_round is not None:
325                 success = self._rollback_to_version(target_round)
326                 if(success) :
327                     return (True, target_round, integrated_requirement, reasoning)
328                 else:
329                     logger.warning(f"版本回退失败:issues:{self.current_issue_id},target:{target_round},integrated_requirement:{integrated_requirement}")
330             return (False, 0, None, reasoning)
331         
332         return StructuredTool.from_function(
333             name="version_rollback_manager",
334             description="用于决定当前项目版本的工具，如果 need_rollback 为True，则根据target_round和integrated_requirement进行版本回退；如果need_rollback为False则保持当前版本",
335             func=version_manager_tool,
336             return_direct=True,
337             args_schema=self._VersionManagerToolSchema
338         )
339
```




```
File: core/file_memory.py
1 import json
2 import os
3 import time
4 import datetime
5 from dataclasses import dataclass
6 from typing import Dict, List, Optional, Set, Union
7 
8 from dotenv import load_dotenv
9 from langchain.tools import Tool
10 
11 from core.ai import AIAssistant, AIConfig
12 from core.file_fetcher import FileFetcher
13 from core.git_manager import GitManager, GitConfig
14 from core.log_manager import LogManager
15 from core.log_config import get_logger
16 
17 logger = get_logger(__name__)
18 
19 @dataclass
20 class FileMemoryConfig:
21     """配置文件记忆管理"""
22     project_dir: str
23     git_manager: GitManager
24     ai_config: AIConfig
25     # 可选的LogManager，用于获取上一轮修改信息
26     log_manager: Optional[LogManager] = None
27 
28 
29 class FileDetail:
30     """文件详细信息类"""
31     pass
32 
33 
34 class FileMemory:
35     """管理文件描述的记忆"""
36 
37     MEMORY_DIR = ".eng/memory"
38     FILE_DETAILS_PATH = f"{MEMORY_DIR}/file_details.txt"
39     GIT_ID_FILE = f"{MEMORY_DIR}/git_id"
40     MAX_RETRIES = 3    # 最大重试次数
41     RETRY_DELAY = 30    # 重试延迟（秒）
42     # 每批次最大行数和字符数限制
43     MAX_LINES_PER_BATCH = 10000  # 最大行数
44     MAX_CHARS_PER_BATCH = 100000  # 最大字符数，约为 100KB
45     MAX_FILES_PER_BATCH = 100  # 每批次最多处理的文件数
46 
47     def __init__(self, config: FileMemoryConfig):
48         self.config = config
49         self.memory_path = os.path.join(config.project_dir, self.FILE_DETAILS_PATH)
50         self.git_id_path = os.path.join(config.project_dir, self.GIT_ID_FILE)
51 
52         # 保存LogManager引用
53         self.log_manager = config.log_manager
54 
55         # 初始化 AI 助手
56         self.ai_assistant = AIAssistant(config=self.config.ai_config, tools=[self._create_batch_description_tool()])
57 
58         # 初始化 Git 管理器
59         self.git_manager = self.config.git_manager
60 
61         # 确保内存目录存在
62         os.makedirs(os.path.dirname(self.memory_path), exist_ok=True)
63 
64     def _ensure_directories(self):
65         """确保必要的目录存在"""
66         memory_dir = os.path.join(self.config.project_dir, self.MEMORY_DIR)
67         os.makedirs(memory_dir, exist_ok=True)
68 
69     def _get_failed_files_path(self) -> str:
70         """获取失败文件记录的路径"""
71         return os.path.join(self.config.project_dir, self.MEMORY_DIR, "failed_files.json")
72 
73     def _read_failed_files(self) -> List[str]:
74         """读取处理失败的文件列表"""
75         failed_files_path = self._get_failed_files_path()
76         if os.path.exists(failed_files_path):
77             try:
78                 with open(failed_files_path, 'r', encoding='utf-8') as f:
79                     return json.load(f)
80             except Exception as e:
81                 logger.error(f"读取失败文件列表出错: {str(e)}")
82         return []
83 
84     def _write_failed_files(self, failed_files: List[str]) -> None:
85         """写入处理失败的文件列表"""
86         failed_files_path = self._get_failed_files_path()
87         try:
88             with open(failed_files_path, 'w', encoding='utf-8') as f:
89                 json.dump(failed_files, f, ensure_ascii=False, indent=2)
90         except Exception as e:
91             logger.error(f"写入失败文件列表出错: {str(e)}")
92 
93     def _create_batch_description_tool(self) -> Tool:
94         """创建批量生成文件描述的工具"""
95         from langchain.tools import Tool
96         
97         def process_file_descriptions(file_descriptions: str) -> Dict[str, str]:
98             """
99             处理文件描述列表
100             
101             Args:
102                 file_descriptions: JSON格式的文件描述列表，格式为 [{"fileName": "path/to/file.py", "desc": "文件描述"}]
103                 
104             Returns:
105                 Dict[str, str]: 文件路径到描述的映射
106             """
107             try:
108                 descriptions = {}
109                 file_list = json.loads(file_descriptions)
110                 
111                 if not isinstance(file_list, list):
112                     logger.error("错误：输入必须是一个列表")
113                     return descriptions
114                 
115                 # 处理结果
116                 for item in file_list:
117                     if isinstance(item, dict) and "fileName" in item and "desc" in item:
118                         descriptions[item["fileName"]] = item["desc"]
119                     else:
120                         logger.warning(f"跳过无效的文件描述项: {item}")
121                 
122                 logger.info(f"成功处理了 {len(descriptions)} 个文件描述")
123                 return descriptions
124             except json.JSONDecodeError:
125                 logger.error("错误：输入不是有效的 JSON 格式")
126                 return {}
127             except Exception as e:
128                 logger.error(f"处理文件描述时出错: {str(e)}")
129                 return {}
130         
131         return Tool(
132             name="process_file_descriptions",
133             description="处理文件描述列表，输入必须是JSON格式的列表，每个元素包含fileName和desc字段",
134             func=process_file_descriptions,
135             return_direct=True
136         )
137 
138     def _generate_batch_file_descriptions(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
139         """
140         批量生成文件描述
141         
142         Args:
143             files_with_content: 包含文件路径和内容的列表，格式为 [{"filepath": "path/to/file.py", "content": "..."}]
144             
145         Returns:
146             Dict[str, str]: 文件路径到描述的映射
147         """
148         # 构建提示词
149         files_text = ""
150         for i, file_info in enumerate(files_with_content):
151             files_text += f"\n--- 文件 {i+1}: {file_info['filepath']} ---\n{file_info['content']}\n"
152         
153         prompt = f"""
154 请分析以下多个代码文件，并为每个文件生成一个简短的中文描述（每个不超过100字）。
155 描述应该包含：
156 1. 文件的主要功能
157 2. 包含的关键类或函数
158 3. 与其他文件的主要交互（如果明显的话）
159 
160 {files_text}
161 
162 请使用process_file_descriptions工具返回结果，输入必须是一个JSON格式的列表，每个元素包含fileName和desc字段。
163 例如：
164 [
165   {{"fileName": "path/to/file1.py", "desc": "这个文件实现了..."}},
166   {{"fileName": "path/to/file2.py", "desc": "这个文件定义了..."}}
167 ]
168 
169 请确保每个文件都有对应的描述，并且描述准确反映文件的功能和内容。
170 """
171         
172         # 尝试生成描述，最多重试MAX_RETRIES次
173         descriptions = {}
174         failed_files = []
175         file_paths = [file_info["filepath"] for file_info in files_with_content]
176         
177         for attempt in range(self.MAX_RETRIES):
178             try:
179                 logger.info(f"尝试批量生成文件描述（第{attempt+1}次尝试）")
180                 
181                 # 使用工具生成描述
182                 descriptions = self.ai_assistant.generate_response(prompt, use_tools=True)
183                 
184                 # 如果返回的不是字典，可能是字符串响应
185                 if not isinstance(descriptions, dict):
186                     logger.error(f"工具返回了非预期的结果类型: {type(descriptions)}")
187                     descriptions = {}
188                 
189                 # 检查是否所有文件都有描述
190                 missing_files = [
191                     file_path for file_path in file_paths
192                     if file_path not in descriptions
193                 ]
194                 
195                 if missing_files:
196                     failed_files.extend(missing_files)
197                     logger.warning(f"以下文件未能生成描述: {missing_files}")
198                 
199                 # 如果有成功处理的文件，则返回结果
200                 if descriptions:
201                     return descriptions
202             
203             except Exception as e:
204                 logger.error(f"批量生成文件描述失败（第{attempt+1}次尝试）: {str(e)}")
205             
206             # 如果不是最后一次尝试，则等待后重试
207             if attempt < self.MAX_RETRIES - 1:
208                 logger.info(f"等待 {self.RETRY_DELAY} 秒后重试...")
209                 time.sleep(self.RETRY_DELAY)
210         
211         # 所有尝试都失败，记录失败的文件
212         self._update_failed_files(file_paths)
213         
214         # 返回空结果
215         return descriptions
216 
217     def _update_failed_files(self, new_failed_files: List[str]) -> None:
218         """更新失败文件列表"""
219         if not new_failed_files:
220             return
221             
222         # 读取现有失败文件列表
223         existing_failed_files = self._read_failed_files()
224         
225         # 合并并去重
226         all_failed_files = list(set(existing_failed_files + new_failed_files))
227         
228         # 写入更新后的列表
229         self._write_failed_files(all_failed_files)
230         logger.info(f"更新了失败文件列表，共 {len(all_failed_files)} 个文件")
231 
232     def process_failed_files(self) -> Dict[str, str]:
233         """处理之前失败的文件"""
234         failed_files = self._read_failed_files()
235         if not failed_files:
236             logger.info("没有需要处理的失败文件")
237             return {}
238             
239         logger.info(f"开始处理 {len(failed_files)} 个失败文件")
240         
241         # 准备文件内容
242         files_with_content = []
243         for filepath in failed_files:
244             content = self._get_file_content(filepath)
245             if content.strip():  # 跳过空文件
246                 files_with_content.append({"filepath": filepath, "content": content})
247         
248         # 按批次处理文件
249         descriptions = self._process_files_in_batches(files_with_content)
250         
251         # 更新失败文件列表
252         if descriptions:
253             # 找出成功处理的文件
254             processed_files = list(descriptions.keys())
255             # 更新失败文件列表
256             new_failed_files = [f for f in failed_files if f not in processed_files]
257             self._write_failed_files(new_failed_files)
258             
259             logger.info(f"成功处理了 {len(processed_files)} 个之前失败的文件，还有 {len(new_failed_files)} 个文件失败")
260         
261         return descriptions
262 
263 
264     def _get_file_content(self, filepath: str) -> str:
265         """获取文件内容"""
266         try:
267             full_path = os.path.join(self.config.project_dir, filepath)
268             with open(full_path, "r", encoding="utf-8") as f:
269                 return f.read()
270         except Exception as e:
271             logger.error(f"读取文件 {filepath} 失败: {str(e)}")
272             return ""
273 
274     def _process_files_in_batches(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
275         """将文件分批处理"""
276         all_descriptions = {}
277         current_batch = []
278         current_lines = 0
279         current_size = 0
280 
281         
282         for file_info in files_with_content:
283             content = file_info["content"]
284             lines = len(content.splitlines())
285             chars = len(content)
286             
287             if lines == 0:
288                 continue
289                 
290             # 检查是否需要开始新批次
291             # 如果当前批次已满或添加此文件会超出限制，则处理当前批次并开始新批次
292             if (current_batch and (
293                 len(current_batch) >= self.MAX_FILES_PER_BATCH or
294                 current_lines + lines > self.MAX_LINES_PER_BATCH or
295                 current_size + chars > self.MAX_CHARS_PER_BATCH
296             )):
297                 # 处理当前批次
298                 logger.info(f"处理批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
299                 batch_descriptions = self._generate_batch_file_descriptions(current_batch)
300                 all_descriptions.update(batch_descriptions)
301                 
302                 # 重置批次
303                 current_batch = [file_info]
304                 current_lines = lines
305                 current_size = chars
306             else:
307                 current_batch.append(file_info)
308                 current_lines += lines
309                 current_size += chars
310         
311         # 处理最后一个批次
312         if current_batch:
313             logger.info(f"处理最后一个批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
314             batch_descriptions = self._generate_batch_file_descriptions(current_batch)
315             all_descriptions.update(batch_descriptions)
316         
317         return all_descriptions
318 
319     def _process_files_chunk(self, files: List[str]) -> Dict[str, str]:
320         """处理一组文件，生成描述"""
321         # 准备文件内容
322         files_with_content = []
323         for filepath in files:
324             content = self._get_file_content(filepath)
325             if content.strip():  # 跳过空文件
326                 files_with_content.append({"filepath": filepath, "content": content})
327         
328         # 按批次处理文件
329         return self._process_files_in_batches(files_with_content)
330 
331     def _read_git_id(self) -> str:
332         """读取保存的 Git ID"""
333         if not os.path.exists(self.git_id_path):
334             return ""
335         with open(self.git_id_path, "r") as f:
336             return f.read().strip()
337 
338     def _write_git_id(self, git_id: str) -> None:
339         """写入当前 Git ID"""
340         with open(self.git_id_path, "w") as f:
341             f.write(git_id)
342 
343     def _read_file_details(self) -> Dict[str, str]:
344         """读取文件描述信息"""
345         if not os.path.exists(self.memory_path):
346             return {}
347 
348         details = {}
349         with open(self.memory_path, "r", encoding="utf-8") as f:
350             for line in f:
351                 if ":" in line:
352                     filename, description = line.strip().split(":", 1)
353                     details[filename] = description
354         return details
355 
356     def _write_file_details(self, details: Dict[str, str]) -> None:
357         """写入文件描述信息"""
358         with open(self.memory_path, "w", encoding="utf-8") as f:
359             for filename, description in sorted(details.items()):
360                 f.write(f"{filename}:{description}\n")
361 
362     def update_file_details(self) -> None:
363         """更新文件描述信息"""
364         # 获取所有文件
365         all_files = set(FileFetcher.get_all_files_without_ignore(self.config.project_dir))
366         
367         # 读取现有描述
368         existing_details = self._read_file_details()
369         
370         files_to_process = []
371         
372         # 如果有LogManager，使用它获取上一轮修改的文件
373         if self.log_manager:
374             # 获取上一轮修改的文件
375             log_modified_files = self._get_last_round_modified_files()
376             
377             # 只处理LogManager中标记为修改的文件
378             files_to_process = list(log_modified_files & all_files)
379             
380             # 删除不存在的文件的描述
381             existing_details = {
382                 k: v for k, v in existing_details.items() if k in all_files
383             }
384             
385             logger.info(f"使用LogManager方式更新文件描述，处理{len(files_to_process)}个修改的文件")
386         else:
387             # 如果没有LogManager，回退到Git方式
388             current_git_id = self.git_manager.get_current_commit_id()
389             saved_git_id = self._read_git_id()
390             files_to_process = self._get_changed_files_git(all_files, existing_details, current_git_id, saved_git_id)
391             logger.info(f"使用Git方式更新文件描述，处理{len(files_to_process)}个文件")
392 
393         # 处理需要更新的文件
394         if files_to_process:
395             new_descriptions = self._process_files_chunk(files_to_process)
396             existing_details.update(new_descriptions)
397 
398         # 保存结果
399         self._write_file_details(existing_details)
400         if not self.log_manager:
401             # 只有使用Git方式时才更新Git ID
402             current_git_id = self.git_manager.get_current_commit_id()
403             self._write_git_id(current_git_id)
404 
405     def _get_last_round_modified_files(self) -> set:
406         """
407         从LogManager获取上一轮修改的文件列表
408         
409         Returns:
410             set: 上一轮修改的文件路径集合
411         """
412         if not self.log_manager:
413             logger.info("未提供LogManager，无法获取上一轮修改的文件")
414             return set()
415         
416         try:
417             # 获取当前轮次
418             current_round = self.log_manager.get_current_round()
419             
420             # 获取上一轮的日志条目
421             if current_round > 1:
422                 prev_round = current_round - 1
423                 log_entry = self.log_manager.get_issue_round_log_entry(prev_round, include_diff=True)
424                 
425                 if log_entry and log_entry.modified_files:
426                     # 从diff_info中提取文件路径
427                     modified_files = set()
428                     for diff_info in log_entry.modified_files:
429                         if diff_info.file_name and diff_info.is_create:
430                             modified_files.add(diff_info.file_name)
431                     
432                     logger.info(f"从LogManager获取到上一轮({prev_round})修改的文件: {len(modified_files)}个")
433                     return modified_files
434             return set()
435         except Exception as e:
436             logger.error(f"获取上一轮修改的文件失败: {str(e)}")
437             return set()
438 
439     def _get_changed_files_git(self, all_files: Set[str], existing_details: Dict[str, str], 
440                              current_git_id: str, saved_git_id: Optional[str]) -> List[str]:
441         """使用Git方式获取需要处理的文件列表"""
442         if saved_git_id:
443             # 获取自上次运行以来修改的文件
444             changed_files = set(
445                 self.git_manager.get_changed_files(saved_git_id, current_git_id)
446             ) & all_files
447             
448             logger.info(f"从Git获取到变更文件: {len(changed_files)}个")
449             
450             new_files = all_files - set(existing_details.keys())
451             logger.info(f"检测到新文件: {len(new_files)}个")
452             
453             return list(changed_files | new_files)
454         else:
455             # 首次运行，处理所有文件
456             return list(all_files)
457 
458     @classmethod
459     def get_file_descriptions(cls, project_dir: str) -> Dict[str, str]:
460         """获取文件描述的静态方法"""
461         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
462 
463         if not os.path.exists(memory_path):
464             return {}
465 
466         try:
467             descriptions = {}
468             with open(memory_path, "r", encoding="utf-8") as f:
469                 for line in f:
470                     if ":" in line:
471                         filename, description = line.strip().split(":", 1)
472                         descriptions[filename] = description
473             return descriptions
474         except Exception as e:
475             logger.error(f"读取文件描述失败: {str(e)}")
476             return {}
477 
478     @classmethod
479     def get_selected_file_descriptions(cls, project_dir: str, files: List[str]) -> Dict[str, str]:
480         """获取文件描述的静态方法"""
481         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
482 
483         if not os.path.exists(memory_path):
484             return {}
485         try:
486             descriptions = {}
487             with open(memory_path, "r", encoding="utf-8") as f:
488                 for line in f:
489                     if ":" in line:
490                         filename, description = line.strip().split(":", 1)
491                         if filename in files:
492                             descriptions[filename] = description
493             return descriptions
494         except Exception as e:
495             logger.error(f"读取文件描述失败: {str(e)}")
496             return {}
497 
498 if __name__ == "__main__":
499     load_dotenv()
500     project_dir = "../."
501     memory = FileMemory(
502         FileMemoryConfig(
503             ai_config=AIConfig(temperature=1, model_name="claude-3.7-sonnet"),
504             git_manager=GitManager(config=GitConfig(repo_path=project_dir)),
505             log_manager=None
506         )
507     )
508 
509     memory.update_file_details()
510
```




```
File: core/workflow_engine.py
1 import os
2 import shutil
3 import tempfile
4 import uuid
5 from dataclasses import dataclass
6 from typing import Optional
7 
8 from core.ai import AIConfig
9 from core.chat_processor import ChatProcessor, ChatProcessorConfig
10 from core.code_engineer import CodeEngineer, CodeEngineerConfig
11 from core.decision import DecisionProcess
12 from core.diff import Diff
13 from core.file_memory import FileMemory, FileMemoryConfig
14 from core.file_selector import FileSelector
15 from core.git_manager import GitManager, GitConfig
16 from core.log_config import get_logger
17 from core.log_manager import LogManager, LogConfig
18 from core.prompt_generator import PromptGenerator, PromptData
19 from core.version_manager import VersionManager
20 
21 logger = get_logger(__name__)
22 
23 @dataclass
24 class WorkflowEngineConfig:
25     project_dir: str
26     issue_id:int
27     core_model:str = "gpt-4o"
28     data_model:str = "gpt-4o"
29     core_template: float = 0.7
30     data_template: float = 0.7
31     max_retry: int = 3,
32     default_branch: str = "main"
33     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
34     base_url: Optional[str] = None
35     api_key: Optional[str] = None
36     github_remote_url: Optional[str] =None
37     github_token: Optional[str] = None
38 
39 
40 class WorkflowEngine:
41     CODE_TIMES = 0
42     CHAT_TIMES = 0
43     """
44     工作流引擎，协调版本管理、日志管理和AI交互
45     """
46     def __init__(self, config: WorkflowEngineConfig):
47         """
48         初始化工作流引擎
49         
50         Args:
51             config: 工作流配置
52         """
53         self.CODE_TIMES = 0
54         self.CHAT_TIMES = 0
55         # 存储原始配置
56         self.original_config = config
57         
58         # 根据模式设置工作目录
59         if config.mode == "bot":
60             # 创建临时目录作为工作区
61             self.temp_dir = os.path.join(
62                 tempfile.gettempdir(), 
63                 f"bella-bot-{config.issue_id}-{str(uuid.uuid4())[:8]}"
64             )
65             os.makedirs(self.temp_dir, exist_ok=True)
66             # 更新配置以使用临时目录
67             self.config = WorkflowEngineConfig(
68                 project_dir=self.temp_dir,
69                 **{k: v for k, v in vars(config).items() if k != 'project_dir'}
70             )
71             logger.info(f"Bot模式：创建临时工作目录 {self.temp_dir}")
72         else:
73             # 客户端模式直接使用指定的目录
74             self.config = config
75             self.temp_dir = None
76 
77         self.project_dir = os.path.abspath(self.config.project_dir)
78         # 创建AI配置
79         self.core_ai_config = AIConfig(
80             model_name=config.core_model,
81             temperature=config.core_template,
82             base_url=config.base_url,
83             api_key=config.api_key
84         )
85         
86         self.data_ai_config = AIConfig(
87             model_name=config.data_model,
88             temperature=config.data_template,
89             base_url=config.base_url,
90             api_key=config.api_key
91         )
92         
93         # 创建Git配置
94         self.git_config = GitConfig(
95             repo_path=self.project_dir,
96             remote_url=config.github_remote_url or os.getenv("GIT_REMOTE"),
97             auth_token=config.github_token or os.getenv("GITHUB_TOKEN"),
98             default_branch=config.default_branch
99         )
100         
101         # 创建日志配置
102         self.log_config = LogConfig(
103             project_dir=self.project_dir,
104             issue_id=config.issue_id,
105             mode=config.mode
106         )
107         
108         # 初始化管理器
109         self.git_manager = GitManager(config=self.git_config)
110         self.log_manager = LogManager(config=self.log_config)
111         
112         # 初始化文件记忆管理，传入log_manager
113         self.file_memory = FileMemory(
114             config=FileMemoryConfig(
115                 git_manager=self.git_manager,
116                 ai_config=self.core_ai_config,
117                 project_dir=self.project_dir,
118                 log_manager=self.log_manager
119             )
120         )
121         self.version_manager = VersionManager(
122             issue_id=config.issue_id,
123             ai_config=self.core_ai_config,
124             log_manager=self.log_manager,
125             git_manager=self.git_manager,
126             file_memory=self.file_memory
127         )
128         self.file_selector = FileSelector(
129             self.project_dir,
130             self.config.issue_id,
131             ai_config=self.core_ai_config
132         )
133 
134         # 初始化代码工程师
135         self.code_engineer_config = CodeEngineerConfig(
136             project_dir=self.project_dir,
137             ai_config=self.core_ai_config
138         )
139         self.engineer = CodeEngineer(
140             self.code_engineer_config,
141             self.log_manager,
142             Diff(self.data_ai_config)
143         )
144         
145         # 初始化聊天处理器
146         self.chat_processor = ChatProcessor(
147             ai_config=self.core_ai_config,
148             log_manager=self.log_manager,
149             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
150         )
151         
152         # 初始化决策环境
153         self.decision_env = DecisionProcess(
154             ai_config=self.core_ai_config,
155             version_manager=self.version_manager
156         )
157     
158     def process_requirement(self, user_requirement: str) -> Optional[str]:
159         """
160         处理用户需求
161         
162         Args:
163             user_requirement: 用户需求
164 
165         Returns:
166             str: 处理结果的响应文本
167         """
168         try:
169             # 初始化环境
170             self._setup_environment()
171             
172             response = self._process_requirement_internal(user_requirement)
173             
174             # 如果是bot模式，在结束时清理临时目录
175             if self.config.mode == "bot":
176                 self._cleanup_environment()
177             
178             return response
179         except Exception as e:
180             logger.error(f"处理需求时发生错误: {str(e)}")
181             raise
182 
183     def _setup_environment(self) -> None:
184         """
185         根据模式设置工作环境
186         """
187         if self.config.mode == "bot":
188             try:
189                 # 重置到issue对应的分支
190                 self.git_manager.reset_to_issue_branch(self.config.issue_id)
191                 logger.info(f"成功初始化Bot模式环境，工作目录: {self.temp_dir}")
192             except Exception as e:
193                 logger.error(f"初始化Bot模式环境失败: {str(e)}")
194                 self._cleanup_environment()
195                 raise
196         current_round = self.log_manager.get_current_round()
197 
198         # 如果轮次大于1，增量更新上一轮修改的文件详细信息
199         if self.file_memory and current_round > 1:
200             self.file_memory.update_file_details()
201             logger.info("已更新文件详细信息")
202         
203     def _cleanup_environment(self) -> None:
204         """
205         清理工作环境，删除临时目录
206         """
207         if self.config.mode == "bot" and self.temp_dir and os.path.exists(self.temp_dir):
208             try:
209                 # 关闭git仓库连接
210                 if hasattr(self, 'git_manager') and self.git_manager:
211                     self.git_manager.delete_local_repository()
212                 
213                 # 删除临时目录
214                 shutil.rmtree(self.temp_dir, ignore_errors=True)
215                 logger.info(f"已清理临时工作目录: {self.temp_dir}")
216             except Exception as e:
217                 logger.warning(f"清理临时目录时出错: {str(e)}")
218                 # 即使清理失败也不抛出异常，让主流程继续
219 
220     def _process_requirement_internal(self, user_requirement: str) -> Optional[str]:
221         """
222         内部处理需求的方法
223         
224         Args:
225             user_requirement: 用户需求
226             
227         Returns:
228             str: 处理结果
229         """
230         # 先通过决策环境分析需求类型
231         decision_result = self.decision_env.analyze_requirement(user_requirement)
232         
233         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
234                     f"理由={decision_result.reasoning}")
235         
236         if decision_result.needs_code_modification:
237             # 执行代码修改流程
238             response = self._run_code_generation_workflow(user_requirement)
239         else: 
240             # 执行对话流程
241             response = self._run_chat_workflow(user_requirement)
242         
243         # 如果是Bot模式且有GitHub配置，自动回复到issue
244         if self.config.mode == "bot":
245             try:
246                 self.version_manager.finalize_changes(mode=self.config.mode, comment_text=response)
247                 logger.info(f"更改已经推送到远端，并添加了Issue评论")
248             except Exception as e:
249                 logger.error(f"添加Issue评论时出错: {str(e)}")
250                 
251         return response
252     
253     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
254         """
255         执行代码生成流程，基于example_code_generate.py的逻辑
256         
257         Args:
258             user_requirement: 用户需求
259             
260         Returns:
261             str: 处理结果
262         """
263         logger.info("开始执行代码生成流程")
264 
265         # 确定当前版本
266         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
267 
268         # 生成提示词
269         user_prompt = self._get_user_prompt(requirement, history)
270 
271         # 根据提示词修改代码
272         success, response = self.engineer.process_prompt(prompt=user_prompt)
273 
274         # 提交更改
275         if success:
276             return response
277         else:
278             self.CODE_TIMES += 1
279             if self.CODE_TIMES >= self.config.max_retry:
280                 logger.error("code workflow超过最大重试次数")
281                 return self._run_chat_workflow(user_requirement)
282             else:
283                 return self._run_code_generation_workflow(user_requirement)
284     
285     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
286         """
287         执行聊天流程，基于example_chat_process.py的逻辑
288         
289         Args:
290             user_requirement: 用户需求
291             
292         Returns:
293             str: 处理结果
294         """
295         logger.info("开始执行聊天回复流程")
296 
297         history = self.version_manager.get_formatted_history()
298 
299         # 生成提示词
300         user_prompt = self._get_user_prompt(user_requirement, history)
301         
302         # 处理聊天请求
303         response = self.chat_processor.process_chat(user_prompt)
304 
305         if(response):
306             return response
307         else:
308             self.CHAT_TIMES += 1
309             if self.CHAT_TIMES >= self.config.max_retry:
310                 logger.error("chat workflow超过最大重试次数")
311                 return None
312             else:
313                 return self._run_chat_workflow(user_requirement)
314 
315     def _get_user_prompt(self, requirement: str, history: str) -> str:
316         # 选择文件
317         files = self.file_selector.select_files_for_requirement(requirement)
318         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
319 
320         # 准备提示词数据
321         data = PromptData(
322             requirement=requirement,
323             project_dir=self.project_dir,
324             steps=history,
325             files=files,
326             file_desc=descriptions
327         )
328 
329         # 生成提示词
330         return PromptGenerator.generatePrompt(data)
331
```




```
File: core/log_config.py
1 import logging
2 import os
3 import sys
4 from logging.handlers import RotatingFileHandler
5 
6 import colorlog
7 
8 project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
9 def setup_logging(log_dir=f'{project_dir}/logs', log_level=logging.INFO, log_file='app.log'):
10     """
11     设置日志配置，使用 colorlog 实现彩色控制台输出
12     
13     Args:
14         log_dir: 日志文件目录
15         log_level: 日志级别
16         log_file: 日志文件名
17     
18     Returns:
19         logging.Logger: 配置好的根日志记录器
20     """
21     # 确保日志目录存在
22     os.makedirs(log_dir, exist_ok=True)
23     
24     # 创建根日志记录器
25     root_logger = logging.getLogger()
26     root_logger.setLevel(log_level)
27     
28     # 清除现有处理器
29     for handler in root_logger.handlers[:]:
30         root_logger.removeHandler(handler)
31     
32     # 创建彩色控制台处理器
33     console_handler = colorlog.StreamHandler(stream=sys.stdout)
34     console_handler.setLevel(log_level)
35     console_format = colorlog.ColoredFormatter(
36         '%(log_color)s%(asctime)s - %(name)s - %(levelname)s - %(message)s',
37         datefmt='%Y-%m-%d %H:%M:%S',
38         log_colors={
39             'DEBUG': 'cyan',
40             'INFO': 'green',
41             'WARNING': 'yellow',
42             'ERROR': 'red',
43             'CRITICAL': 'red,bg_white',
44         }
45     )
46     console_handler.setFormatter(console_format)
47     
48     # 创建文件处理器（带日志轮换）
49     log_file_path = os.path.join(log_dir, log_file)
50     file_handler = RotatingFileHandler(
51         log_file_path, maxBytes=10*1024*1024, backupCount=5, encoding='utf-8'
52     )
53     file_handler.setLevel(log_level)
54     file_format = logging.Formatter(
55         '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
56         datefmt='%Y-%m-%d %H:%M:%S'
57     )
58     file_handler.setFormatter(file_format)
59     
60     # 添加处理器到根日志记录器
61     root_logger.addHandler(console_handler)
62     root_logger.addHandler(file_handler)
63     
64     # 返回根日志记录器
65     return root_logger
66 
67 def get_logger(name, log_level=None):
68     """
69     获取指定名称的日志记录器
70     
71     Args:
72         name: 日志记录器名称
73         log_level: 日志级别，如果提供则覆盖默认级别
74     
75     Returns:
76         logging.Logger: 指定名称的日志记录器
77     """
78     logger = logging.getLogger(name)
79     if log_level is not None:
80         logger.setLevel(log_level)
81     return logger
82 
83 # 如果直接运行此模块，则设置日志并进行测试
84 if __name__ == "__main__":
85     setup_logging(log_level=logging.DEBUG)
86     logger = get_logger(__name__)
87     
88     logger.debug("这是一条调试日志")
89     logger.info("这是一条信息日志")
90     logger.warning("这是一条警告日志")
91     logger.error("这是一条错误日志")
92     logger.critical("这是一条严重错误日志")
93     
94     print("\n日志配置测试完成，请检查控制台输出和logs目录下的日志文件。")
```




```
File: scripts/run_bot.sh
1 #!/bin/bash
2 
3 # 启动bella-issues-bot的帮助脚本
4 # 此脚本简化了命令行参数的输入，便于快速使用
5 # 支持简化的参数选项，调用Python客户端模块
6 
7 show_help() {
8     echo "使用方法: $0 <issue-id> [选项] [需求文件路径]"
9     echo ""
10     echo "必需参数:"
11     echo "  <issue-id>               问题ID（必填）"
12     echo ""
13     echo "选项:"
14     echo "  -m, --model MODEL        同时设置core和data模型名称"
15     echo "  -t, --temperature TEMP          同时设置core和data模型温度"
16     echo "  --cm, --core-model MODEL 单独设置core模型名称"
17     echo "  --dm, --data-model MODEL 单独设置data模型名称"
18     echo "  --ct, --core-temperature TEMP   单独设置core模型温度"
19     echo "  --dt, --data-temperature TEMP   单独设置data模型温度"
20     echo "  -k, --key KEY            设置API密钥"
21     echo "  -h, --help               显示此帮助信息"
22     echo ""
23     echo "示例:"
24     echo "  $0 42 ./requirements.txt             # 使用文件中的需求"
25     echo "  $0 42 -m gpt-4-turbo                # 设置所有模型为gpt-4-turbo"
26     echo "  $0 42 -m gpt-4-turbo -t 0.9         # 设置所有模型为gpt-4-turbo，温度为0.9"
27     echo "  $0 42 --cm gpt-4-turbo --dm gpt-3.5-turbo  # 分别设置不同模型"
28     echo ""
29 }
30 
31 # 检查是否请求帮助
32 if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
33     show_help
34     exit 0
35 fi
36 
37 # 检查是否提供了issue-id参数
38 if [ -z "$1" ] || [[ "$1" == -* ]]; then
39     echo "错误: 必须提供issue-id作为第一个参数"
40     show_help
41     exit 1
42 fi
43 
44 ISSUE_ID=$1
45 shift  # 移除第一个参数，使其他参数可以按顺序处理
46 
47 # 检查最后一个参数是否是一个文件（不以连字符开头）
48 ARGS=("$@")
49 if [ ${#ARGS[@]} -gt 0 ] && [[ ! "${ARGS[-1]}" == -* ]] && [ -f "${ARGS[-1]}" ]; then
50     python -m client.terminal -i $ISSUE_ID --requirement-file "${ARGS[-1]}" "${ARGS[@]:0:${#ARGS[@]}-1}"
51 else
52     python -m client.terminal -i $ISSUE_ID "$@"
53 fi
54
```




```
File: client/terminal.py
1 """
2 Terminal entrypoint for the WorkflowEngine.
3 Provides functionality to run the engine from terminal with command-line arguments.
4 """
5 import logging
6 import os
7 import sys
8 from dotenv import load_dotenv
9 
10 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
11 from client.cli import parse_args, get_requirement_text, build_config_from_args
12 from core.log_config import setup_logging
13 
14 
15 def run_workflow_from_terminal() -> str:
16     """
17     Main entry point for running the workflow engine from terminal.
18     Parses command line arguments and runs the workflow engine.
19     """
20     # Load environment variables from .env file if present
21     load_dotenv()
22     
23     # Parse command line arguments
24     args = parse_args()
25     
26     # Get requirement text
27     requirement = get_requirement_text(args)
28     if not requirement:
29         sys.exit(1)
30     
31     # Build config from arguments
32     config_params = build_config_from_args(args)
33     
34     # Try to get API key from environment if not provided as argument
35     if "api_key" not in config_params and os.environ.get("OPENAI_API_KEY"):
36         config_params["api_key"] = os.environ.get("OPENAI_API_KEY")
37     
38     # Create the workflow engine config
39     config = WorkflowEngineConfig(**config_params)
40     
41     # Initialize and run the workflow engine
42     engine = WorkflowEngine(config)
43     response = engine.process_requirement(requirement)
44     
45     # Print the response to the terminal if available
46     if response:
47         print(f"\nResponse:\n{response}")
48     
49     return response if response else ""
50 
51 
52 if __name__ == "__main__":
53     setup_logging(log_level=logging.INFO)
54     response = run_workflow_from_terminal()
55 
56
```




```
File: client/runner.py
1 """
2 Programmatic API for running the WorkflowEngine.
3 Provides a simplified interface for use in Python scripts.
4 """
5 
6 import os
7 from typing import Optional, Dict, Any, Union
8 
9 from dotenv import load_dotenv
10 
11 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
12 
13 
14 def run_workflow(
15     issue_id: int,
16     requirement: str,
17     project_dir: Optional[str] = None,
18     model: Optional[str] = None,  # 统一的模型设置
19     core_model: Optional[str] = "gpt-4o",
20     data_model: Optional[str] = None,  # 默认与core_model相同
21     temperature: Optional[float] = None,  # 统一的温度设置
22     core_temperature: float = 0.7,
23     data_temperature: float = 0.7,
24     max_retry: int = 3,
25     default_branch: str = "main",
26     mode: str = "client",
27     base_url: Optional[str] = None,
28     api_key: Optional[str] = None,
29     github_remote_url: Optional[str] = None,
30     github_token: Optional[str] = None,
31     **kwargs: Dict[str, Any]
32 ) -> None:
33     """Run the WorkflowEngine with the given configuration."""
34     # Load environment variables
35     load_dotenv()
36     
37     # Use current directory if no project_dir specified
38     if project_dir is None:
39         project_dir = os.getcwd()
40     
41     # 处理统一的模型配置
42     if model is not None:
43         core_model = model
44         data_model = model
45     
46     # 如果未指定data_model，则默认与core_model相同
47     if data_model is None:
48         data_model = core_model
49     
50     # 处理统一的温度配置
51     if temperature is not None:
52         core_temperature = temperature
53         data_temperature = temperature
54     
55     # Create config with provided parameters
56     config = WorkflowEngineConfig(
57         project_dir=project_dir, issue_id=issue_id, 
58         core_model=core_model, data_model=data_model,
59         core_template=core_temperature, data_template=data_temperature,
60         max_retry=max_retry, default_branch=default_branch, mode=mode, 
61         base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
62         github_token=github_token
63     )
64     
65     # Run the workflow engine
66     engine = WorkflowEngine(config)
67     response = engine.process_requirement(requirement)
68     
69     return response
70
```




```
File: client/cli.py
1 """
2 Command-line interface for the WorkflowEngine.
3 Provides functionality to parse command-line arguments and run the engine.
4 """
5 
6 import argparse
7 import os
8 import sys
9 from typing import Optional, Dict, Any
10 
11 
12 def parse_args() -> argparse.Namespace:
13     """Parse command-line arguments for the WorkflowEngine."""
14     parser = argparse.ArgumentParser(
15         description="Run the WorkflowEngine to process user requirements"
16     )
17 
18     # Required arguments
19     parser.add_argument(
20         "--project-dir", 
21         "-p",
22         type=str, 
23         default=os.path.abspath(os.getcwd()),
24         help="Path to the project directory (default: current directory)"
25     )
26     parser.add_argument(
27         "--issue-id", 
28         "-i",
29         type=int, 
30         required=True,
31         help="The ID of the issue being processed"
32     )
33     parser.add_argument(
34         "--requirement", 
35         "-r",
36         type=str, 
37         help="The user requirement text"
38     )
39     parser.add_argument(
40         "--requirement-file", 
41         "-f",
42         type=str, 
43         help="Path to file containing the user requirement"
44     )
45 
46     # Optional arguments for WorkflowEngineConfig
47     # 统一模型配置
48     parser.add_argument(
49         "--model", 
50         "-m",
51         type=str, 
52         help="Model to use for both core and data operations (优先级高于单独配置)"
53     )
54     parser.add_argument(
55         "--temperature",
56         "-t",
57         type=float, 
58         help="Temperature for both core and data models (优先级高于单独配置)"
59     )
60     
61     # 独立模型配置
62     parser.add_argument(
63         "--core-model", 
64         "--cm",
65         type=str, 
66         default="gpt-4o",
67         help="Model to use for core AI operations (当未设置--model时使用)"
68     )
69     parser.add_argument(
70         "--data-model", 
71         "--dm",
72         type=str, 
73         default="gpt-4o",
74         help="Model to use for data operations (当未设置--model时使用)"
75     )
76     parser.add_argument(
77         "--core-temperature",
78         "--ct",
79         type=float, 
80         default=0.7,
81         help="Temperature for core model (当未设置--temperature时使用)"
82     )
83     parser.add_argument(
84         "--data-temperature",
85         "--dt",
86         type=float, 
87         default=0.7,
88         help="Temperature for data model (当未设置--temperature时使用)"
89     )
90     parser.add_argument(
91         "--max-retry", 
92         "--retry",
93         type=int, 
94         default=3,
95         help="Maximum number of retry attempts"
96     )
97     parser.add_argument(
98         "--default-branch", 
99         "--branch",
100         type=str, 
101         default="main",
102         help="Default branch name"
103     )
104     parser.add_argument(
105         "--mode",
106         "-md",
107         type=str,
108         choices=["client", "bot"],
109         default="client",
110         help="Operation mode: 'client' or 'bot'"
111     )
112     parser.add_argument(
113         "--base-url",
114         "-u",
115         type=str,
116         help="Base URL for API calls"
117     )
118     parser.add_argument(
119         "--api-key",
120         "-k",
121         type=str,
122         help="API key for authentication"
123     )
124     parser.add_argument(
125         "--github-remote-url",
126         "--git-url",
127         type=str,
128         help="GitHub remote repository URL"
129     )
130     parser.add_argument(
131         "--github-token",
132         "--git-token",
133         type=str,
134         help="GitHub authentication token"
135     )
136     
137     return parser.parse_args()
138 
139 
140 def get_requirement_text(args: argparse.Namespace) -> Optional[str]:
141     """Get requirement text from arguments or file."""
142     if args.requirement:
143         return args.requirement
144     elif args.requirement_file:
145         try:
146             with open(args.requirement_file, 'r', encoding='utf-8') as file:
147                 return file.read()
148         except IOError as e:
149             print(f"Error reading requirement file: {e}", file=sys.stderr)
150             return None
151     else:
152         print("No requirement specified. Use --requirement or --requirement-file", file=sys.stderr)
153         return None
154 
155 
156 def build_config_from_args(args: argparse.Namespace) -> Dict[str, Any]:
157     """Build WorkflowEngineConfig parameters from command line arguments."""
158     
159     # 处理统一的模型和温度配置
160     core_model = args.core_model
161     data_model = args.data_model
162     core_temperature = args.core_temperature
163     data_temperature = args.data_temperature
164     
165     # 如果设置了统一模型，则覆盖个别设置
166     if args.model:
167         core_model = args.model
168         data_model = args.model
169         
170     # 如果设置了统一温度，则覆盖个别设置
171     if args.temperature is not None:
172         core_temperature = args.temperature
173         data_temperature = args.temperature
174     
175     config_params = {
176         "project_dir": args.project_dir,
177         "issue_id": args.issue_id,
178         "core_model": core_model,
179         "data_model": data_model,
180         "core_template": core_temperature,  # Note: using template to match original param name
181         "data_template": data_temperature,  # Note: using template to match original param name
182         "max_retry": args.max_retry, 
183         "default_branch": args.default_branch,
184         "mode": args.mode,
185     }
186     
187     # Add optional parameters if they're specified
188     if args.base_url:
189         config_params["base_url"] = args.base_url
190     if args.api_key:
191         config_params["api_key"] = args.api_key
192     if args.github_remote_url:
193         config_params["github_remote_url"] = args.github_remote_url
194     if args.github_token:
195         config_params["github_token"] = args.github_token
196         
197     return config_params
198
```




# 历史执行信息

【round_1】
requirement: 
现在的启动脚本参数太长了，提供简称。再加一个model和温度代表把core和data一起配置了。也可以用单独的core和data分别配置。用中文写描述。
agent_response: 
我将实现对启动脚本的改进，增加简称参数，并添加model和temperature参数作为core和data模型的统一配置选项。让我们逐步实现这些需求。

首先，我们需要修改命令行参数解析模块，然后更新启动脚本。

## 1. 修改 client/cli.py 添加简称和统一配置选项

```diff
--- client/cli.py
+++ client/cli.py
@@ -18,55 +18,82 @@
     # Required arguments
     parser.add_argument(
         "--project-dir", 
+        "-p",
         type=str, 
         default=os.path.abspath(os.getcwd()),
         help="Path to the project directory (default: current directory)"
     )
     parser.add_argument(
         "--issue-id", 
+        "-i",
         type=int, 
         required=True,
         help="The ID of the issue being processed"
     )
     parser.add_argument(
         "--requirement", 
+        "-r",
         type=str, 
         help="The user requirement text"
     )
     parser.add_argument(
         "--requirement-file", 
+        "-f",
         type=str, 
         help="Path to file containing the user requirement"
     )
 
     # Optional arguments for WorkflowEngineConfig
+    # 统一模型配置
+    parser.add_argument(
+        "--model", 
+        "-m",
+        type=str, 
+        help="Model to use for both core and data operations (优先级高于单独配置)"
+    )
+    parser.add_argument(
+        "--temperature", 
+        "-t",
+        type=float, 
+        help="Temperature for both core and data models (优先级高于单独配置)"
+    )
+    
+    # 独立模型配置
     parser.add_argument(
         "--core-model", 
+        "--cm",
         type=str, 
         default="gpt-4o",
-        help="Model to use for core AI operations"
+        help="Model to use for core AI operations (当未设置--model时使用)"
     )
     parser.add_argument(
         "--data-model", 
+        "--dm",
         type=str, 
         default="gpt-4o",
-        help="Model to use for data operations"
+        help="Model to use for data operations (当未设置--model时使用)"
     )
     parser.add_argument(
         "--core-temperature", 
+        "--ct",
         type=float, 
         default=0.7,
-        help="Temperature for core model"
+        help="Temperature for core model (当未设置--temperature时使用)"
     )
     parser.add_argument(
         "--data-temperature", 
+        "--dt",
         type=float, 
         default=0.7,
-        help="Temperature for data model"
+        help="Temperature for data model (当未设置--temperature时使用)"
     )
     parser.add_argument(
         "--max-retry", 
+        "--retry",
         type=int, 
         default=3,
         help="Maximum number of retry attempts"
     )
     parser.add_argument(
         "--default-branch", 
+        "--branch",
         type=str, 
         default="main",
         help="Default branch name"
@@ -79,6 +106,7 @@
     parser.add_argument(
         "--mode", 
         type=str, 
+        "-md",
         choices=["client", "bot"],
         default="client",
         help="Operation mode: 'client' or 'bot'"
@@ -86,21 +114,25 @@
     parser.add_argument(
         "--base-url", 
         type=str, 
+        "-u",
         help="Base URL for API calls"
     )
     parser.add_argument(
         "--api-key", 
         type=str, 
+        "-k",
         help="API key for authentication"
     )
     parser.add_argument(
         "--github-remote-url", 
         type=str, 
+        "--git-url",
         help="GitHub remote repository URL"
     )
     parser.add_argument(
         "--github-token", 
         type=str, 
+        "--git-token",
         help="GitHub authentication token"
     )
     
@@ -125,14 +157,30 @@
 
 def build_config_from_args(args: argparse.Namespace) -> Dict[str, Any]:
     """Build WorkflowEngineConfig parameters from command line arguments."""
+    
+    # 处理统一的模型和温度配置
+    core_model = args.core_model
+    data_model = args.data_model
+    core_temperature = args.core_temperature
+    data_temperature = args.data_temperature
+    
+    # 如果设置了统一模型，则覆盖个别设置
+    if args.model:
+        core_model = args.model
+        data_model = args.model
+        
+    # 如果设置了统一温度，则覆盖个别设置
+    if args.temperature is not None:
+        core_temperature = args.temperature
+        data_temperature = args.temperature
+    
     config_params = {
         "project_dir": args.project_dir,
         "issue_id": args.issue_id,
-        "core_model": args.core_model,
-        "data_model": args.data_model,
-        "core_template": args.core_temperature,  # Note: using template to match original param name
-        "data_template": args.data_temperature,  # Note: using template to match original param name
-        "max_retry": args.max_retry,
+        "core_model": core_model,
+        "data_model": data_model,
+        "core_template": core_temperature,  # Note: using template to match original param name
+        "data_template": data_temperature,  # Note: using template to match original param name
+        "max_retry": args.max_retry, 
         "default_branch": args.default_branch,
         "mode": args.mode,
     }
```

## 2. 更新启动脚本，添加更多参数支持和帮助信息

```diff
--- scripts/run_bot.sh
+++ scripts/run_bot.sh
@@ -2,15 +2,50 @@
 
 # 启动bella-issues-bot的帮助脚本
 # 此脚本简化了命令行参数的输入，便于快速使用
+# 支持简化的参数选项，调用Python客户端模块
+
+show_help() {
+    echo "使用方法: $0 <issue-id> [选项] [需求文件路径]"
+    echo ""
+    echo "必需参数:"
+    echo "  <issue-id>               问题ID（必填）"
+    echo ""
+    echo "选项:"
+    echo "  -m, --model MODEL        同时设置core和data模型名称"
+    echo "  -t, --temp TEMP          同时设置core和data模型温度"
+    echo "  --cm, --core-model MODEL 单独设置core模型名称"
+    echo "  --dm, --data-model MODEL 单独设置data模型名称"
+    echo "  --ct, --core-temp TEMP   单独设置core模型温度"
+    echo "  --dt, --data-temp TEMP   单独设置data模型温度"
+    echo "  -k, --key KEY            设置API密钥"
+    echo "  -h, --help               显示此帮助信息"
+    echo ""
+    echo "示例:"
+    echo "  $0 42 ./requirements.txt             # 使用文件中的需求"
+    echo "  $0 42 -m gpt-4-turbo                # 设置所有模型为gpt-4-turbo"
+    echo "  $0 42 -m gpt-4-turbo -t 0.9         # 设置所有模型为gpt-4-turbo，温度为0.9"
+    echo "  $0 42 --cm gpt-4-turbo --dm gpt-3.5-turbo  # 分别设置不同模型"
+    echo ""
+}
+
+# 检查是否请求帮助
+if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
+    show_help
+    exit 0
+fi
 
 # 检查是否提供了issue-id参数
-if [ -z "$1" ]; then
-    echo "使用方法: $0 <issue-id> [需求文件路径]"
-    echo ""
-    echo "示例:"
-    echo "  $0 42 ./requirements.txt  # 使用文件中的需求"
-    echo "  $0 42                    # 将会要求您输入需求"
+if [ -z "$1" ] || [[ "$1" == -* ]]; then
+    echo "错误: 必须提供issue-id作为第一个参数"
+    show_help
     exit 1
 fi
 
-python -m client.terminal --issue-id "$1" ${2:+--requirement-file "$2"}
+ISSUE_ID=$1
+shift  # 移除第一个参数，使其他参数可以按顺序处理
+
+# 检查最后一个参数是否是一个文件（不以连字符开头）
+ARGS=("$@")
+if [ ${#ARGS[@]} -gt 0 ] && [[ ! "${ARGS[-1]}" == -* ]] && [ -f "${ARGS[-1]}" ]; then
+    python -m client.terminal -i $ISSUE_ID --requirement-file "${ARGS[-1]}" "${ARGS[@]:0:${#ARGS[@]}-1}"
+else
+    python -m client.terminal -i $ISSUE_ID "$@"
+fi
```

## 3. 让我们修改 client/terminal.py 以正确处理这些新参数

```diff
--- client/terminal.py
+++ client/terminal.py
@@ -4,7 +4,7 @@
 """
 import logging
 import os
-import sys 
+import sys
 from dotenv import load_dotenv
 
 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
@@ -34,7 +34,7 @@
     # Try to get API key from environment if not provided as argument
     if "api_key" not in config_params and os.environ.get("OPENAI_API_KEY"):
         config_params["api_key"] = os.environ.get("OPENAI_API_KEY")
-        
+    
     # Create the workflow engine config
     config = WorkflowEngineConfig(**config_params)
     
```

## 4. 同样更新 client/runner.py 以支持统一模型参数

```diff
--- client/runner.py
+++ client/runner.py
@@ -15,8 +15,10 @@
     issue_id: int,
     requirement: str,
     project_dir: Optional[str] = None,
-    core_model: str = "gpt-4o",
-    data_model: str = "gpt-4o",
+    model: Optional[str] = None,  # 统一的模型设置
+    core_model: Optional[str] = "gpt-4o",
+    data_model: Optional[str] = None,  # 默认与core_model相同
+    temperature: Optional[float] = None,  # 统一的温度设置
     core_temperature: float = 0.7,
     data_temperature: float = 0.7,
     max_retry: int = 3,
@@ -36,11 +38,24 @@
     if project_dir is None:
         project_dir = os.getcwd()
     
+    # 处理统一的模型配置
+    if model is not None:
+        core_model = model
+        data_model = model
+    
+    # 如果未指定data_model，则默认与core_model相同
+    if data_model is None:
+        data_model = core_model
+    
+    # 处理统一的温度配置
+    if temperature is not None:
+        core_temperature = temperature
+        data_temperature = temperature
+    
     # Create config with provided parameters
     config = WorkflowEngineConfig(
-        project_dir=project_dir, issue_id=issue_id, core_model=core_model,
-        data_model=data_model, core_template=core_temperature, data_template=data_temperature,
-        max_retry=max_retry, default_branch=default_branch, mode=mode,
+        project_dir=project_dir, issue_id=issue_id, 
+        core_model=core_model, data_model=data_model,
+        core_template=core_temperature, data_template=data_temperature,
+        max_retry=max_retry, default_branch=default_branch, mode=mode, 
         base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
         github_token=github_token, **kwargs
     )
```

现在，让我确认所有的更改都正确实现：

1. 在 `client/cli.py` 中:
   - 为所有参数添加了简称
   - 添加了统一模型配置参数 `--model` 和 `--temperature`
   - 更新了参数描述，说明了优先级关系

2. 在 `scripts/run_bot.sh` 中:
   - 完全重写了启动脚本，支持更多参数和帮助信息
   - 添加了详细的使用说明和示例
   - 改进了参数处理逻辑，更灵活地支持文件路径参数

3. 在 `client/runner.py` 中:
   - 添加了统一模型参数 `model` 和 `temperature`
   - 添加了处理逻辑，确保统一参数优先于单独配置

这些修改使得用户可以：
1. 使用简短的命令行参数（如 `-m` 代替 `--model`）
2. 用单个参数同时设置 core 和 data 模型
3. 获得更友好的帮助信息

这些更改完全保留了原有功能，同时增加了新的便捷选项，提高了用户体验。

this concludes a fully working implementation



# 用户需求

写两个read.me分别介绍启动和项目，着重介绍memory的部分，比如log记录，版本管理中的上下文怎么生成这些。