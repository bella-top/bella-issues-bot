# 项目文件描述


- README.md: 项目主要说明文档，介绍bella-issues-bot的功能和使用方法。包含项目简介、主要功能、记忆与上下文管理系统介绍、安装方法、使用方法和环境变量配置说明。

- client/README.md: WorkflowEngine客户端文档，详细介绍了系统的记忆与上下文管理机制（日志管理、版本管理、文件记忆），支持的工作模式（客户端和机器人模式），以及命令行和编程API的使用方法和配置选项。

- client/__init__.py: Client包的初始化文件，用于从终端运行WorkflowEngine。导出了file_memory_client模块中的initialize_file_memory、update_file_descriptions和process_failed_files函数供编程使用。

- client/cli.py: WorkflowEngine的命令行接口，提供解析命令行参数的功能。包含parse_args、get_requirement_text和build_config_from_args三个主要函数，支持统一和独立的模型配置选项。

- client/file_memory_client.py: 一个独立的客户端模块，用于初始化和管理FileMemory，仅使用GitManager而不依赖LogManager。提供了CLI和编程接口，实现了文件描述的更新功能。包含initialize_file_memory、update_file_descriptions等关键函数。支持命令行参数配置和环境变量加载。

- client/runner.py: WorkflowEngine的编程API，提供在Python脚本中使用的简化接口。包含run_workflow函数，支持统一的模型和温度设置，以及各种配置选项。

- client/terminal.py: WorkflowEngine的终端入口点，提供命令行运行引擎的功能。主要函数run_workflow_from_terminal解析命令行参数、获取需求文本、构建配置并运行工作流引擎，支持从环境变量加载配置。

- core/git_manager.py: Git操作管理模块，提供仓库克隆、分支管理、提交、拉取、推送等功能。包含GitManager类和GitConfig数据类，支持认证令牌、远程仓库操作，提供获取变更文件、重置分支等辅助方法。被FileMemory等模块调用以支持版本控制。

- core/workflow_engine.py: 工作流引擎核心类，协调版本管理、日志管理和AI交互。实现了处理用户需求的完整流程，支持代码生成和聊天两种工作模式，包含环境设置、清理和决策分析功能。

- core/file_memory.py: 文件记忆管理模块，负责维护和更新项目文件的描述信息。包含FileMemory类，使用AI生成文件描述，支持Git和LogManager两种方式跟踪文件变更，并批量处理文件以提高效率。与AI和Git模块紧密交互。

- scripts/init_file_memory.sh: 一个Bash脚本，作为client/file_memory_client.py的命令行包装器。提供了简化的接口来运行文件记忆初始化，支持设置项目目录、AI模型、温度等参数。包含帮助信息展示功能，并将所有命令行参数传递给Python模块。

- scripts/run_bot.sh: 启动bella-issues-bot的Bash帮助脚本，简化命令行参数输入。提供简化的参数选项，支持设置模型名称、温度等参数，并调用Python客户端模块。

- pyproject.toml: 项目配置文件，定义bella-issues-bot的元数据、依赖项和工具配置。包含项目版本、描述、作者等信息，以及Python依赖库配置、代码格式化工具设置。是项目构建和包管理的核心配置文件。


# 文件内容



```
File: README.md
1 # bella-issues-bot
2 
3 ## 项目简介
4 
5 bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：
6 
7 1. **个人开发助手模式**：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。
8 2. **GitHub自动化模式**：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。
9 
10 通过对项目结构的深入理解和强大的代码生成能力，bella-issues-bot 能够显著提高开发效率，减少重复工作，让您专注于更有创造性的任务。
11 
12 ## 主要功能
13 
14 - **需求分析**：自动理解和分解用户的功能需求
15 - **代码生成**：根据需求生成符合项目风格的代码
16 - **版本管理**：与Git集成，支持分支创建和代码提交
17 - **记忆系统**：记录项目文件描述和操作历史，提供上下文感知能力
18 
19 ## 记忆与上下文管理
20 
21 bella-issues-bot 配备了强大的记忆系统，由三个核心组件构成：
22 
23 ### 1. 日志管理 (LogManager)
24 
25 LogManager 负责记录每次交互的完整历史，包括：
26 - 系统提示词和用户需求
27 - AI响应内容
28 - 文件修改记录和差异对比
29 
30 这些日志按issue和轮次组织，支持历史追溯和问题诊断。每轮交互都会生成详细日志，便于追踪AI的决策过程和代码修改历史。
31 
32 ### 2. 版本管理 (VersionManager)
33 
34 VersionManager 提供智能的版本控制功能：
35 - 自动提取历史轮次的需求和响应
36 - 生成格式化的历史执行记录作为上下文
37 - 分析当前需求与历史需求的关系
38 - 根据需要执行版本回退操作
39 
40 系统会分析新需求与先前修改的关系，判断是否需要回滚，确保代码修改的连贯性和一致性。
41 
42 ### 3. 文件记忆 (FileMemory)
43 
44 FileMemory 模块为项目的每个文件维护详细描述：
45 - 自动生成文件功能、结构和关系描述
46 - 跟踪文件变更，更新受影响文件的描述
47 - 提供上下文相关的文件选择
48 - 支持配置忽略文件，默认包含项目的.gitignore，支持自定义添加.eng/.engignore
49 
50 这使得AI助手能够理解整个代码库的结构和功能，在修改代码时考虑到更广泛的项目上下文。
51 
52 ## 安装方法
53 
54 使用pip安装：
55 
56 ```bash
57 pip install bella-issues-bot
58 ```
59 
60 ## 使用方法
61 
62 bella-issues-bot 提供了多种使用方式：
63 
64 ### 个人开发模式
65 
66 在日常开发中，您可以通过命令行界面或编程API使用bella-issues-bot：
67 
68 #### 命令行使用
69 
70 ```bash
71 bella-issues-bot --issue-id <问题ID> --requirement "你的需求描述"
72 ```
73 
74 更多高级选项和详细使用说明，请参考[客户端文档](./client/README.md)。
75 
76 #### 编程API使用
77 
78 ```python
79 from client.runner import run_workflow
80 
81 run_workflow(
82     issue_id=42,
83     requirement="创建一个简单的README文件",
84     core_temperature=0.7
85 )
86 ```
87 
88 ## 环境变量配置
89 
90 工具会读取以下环境变量：
91 
92 - `OPENAI_API_KEY`: OpenAI API密钥
93 - `OPENAI_API_BASE`: OpenAI API基础URL
94 - `GITHUB_REMOTE_URL`: GitHub远程仓库URL
95 - `GITHUB_TOKEN`: GitHub身份验证令牌
96 - 在项目文件的.eng/目录下创建 .engignore文件，示例[examples](./.engignore.example)
97 
98 ## 示例
99 
100 可以在[examples](./examples/)目录下找到使用示例。
101 
102 ### 文件记忆初始化
103 
104 在项目根目录执行 `bella-file-memory` 可以初始化文件记忆系统，它会自动分析项目中的文件并生成描述信息。
105 更多详细信息请参阅[文件记忆客户端文档](./client/README_FILE_MEMORY.md)。
106
```




```
File: client/README.md
1 # WorkflowEngine 客户端
2 
3 一个强大的命令行接口和编程API，用于运行WorkflowEngine处理用户需求，支持个人开发助手模式和GitHub自动化工作流模式。
4 
5 ## 记忆与上下文管理
6 
7 客户端依赖于强大的后台记忆系统，包括三个核心组件：
8 
9 ### 日志管理 (LogManager)
10 
11 LogManager负责存储每次交互的详细记录：
12 
13 - **结构化存储**：日志按issue ID和轮次有序组织，便于检索
14 - **完整性**：记录系统提示词、用户提示词、AI响应和文件修改
15 - **差异追踪**：保存每个修改文件的完整差异信息
16 
17 所有日志保存在项目的`.eng/memory`目录下，按照`issues/#<issue-id>/round_<num>`格式组织，可随时查看历史交互。
18 
19 ### 版本管理 (VersionManager)
20 
21 VersionManager提供智能版本控制功能：
22 
23 - **历史分析**：自动提取历史轮次的数据形成上下文
24 - **需求整合**：在新需求与历史需求有冲突时，提供智能整合
25 - **版本回退**：根据需要自动执行版本回退操作
26 
27 每次启动新的需求处理时，系统会：
28 1. 提取过去所有轮次的需求和响应
29 2. 格式化为结构化历史记录
30 3. 分析新需求与历史的关系
31 4. 决定是保持当前状态还是执行回退
32 
33 ### 文件记忆 (FileMemory)
34 
35 FileMemory为AI提供项目文件的深度理解：
36 
37 - **自动描述**：为项目中的每个文件生成功能描述
38 - **增量更新**：只更新被修改的文件描述，提高效率
39 - **批量处理**：使用智能分批策略处理大型代码库
40 - **失败处理**：对无法处理的文件提供重试机制
41 
42 当工作流运行时，系统会：
43 1. 检测新建或修改的文件
44 2. 使用AI生成这些文件的功能描述
45 3. 将描述保存在`.eng/memory/file_details.txt`中
46 4. 在后续需求处理时提供这些描述作为上下文
47 
48 ## 工作模式
49 
50 bella-issues-bot 支持两种主要工作模式：
51 
52 - **客户端模式 (client)**：默认模式，适合作为个人开发助手使用，每次运行时基于project_dir目录下的当前代码状态进行操作。
53 - **机器人模式 (bot)**：专为GitHub集成设计，会在project_dir目录下创建临时目录作为工作区，自动拉取issues对应的最新分支状态，处理完成后自动提交更改并在Issues中回复处理结果，最后清理临时工作区。
54 ## 命令行使用方式（个人开发助手模式）
55 
56 你可以通过以下两种方式从命令行运行WorkflowEngine：
57 
58 ### 使用安装后的CLI命令
59 
60 ```bash
61 bella-issues-bot --issue-id 42 --requirement "创建一个README文件"
62 ```
63 
64 ### 直接使用Python模块
65 
66 ```bash
67 python -m client.terminal --issue-id 42 --requirement "创建一个README文件"
68 ```
69 
70 ### 命令行参数
71 
72 #### 基础参数
73 
74 - `--issue-id -i`：（必需）问题ID，用于跟踪和引用
75 - `--requirement -r` 或 `--requirement-file -f`：（必需）具体需求描述或包含需求的文件路径
76 - `--project-dir -p`：项目目录路径（默认：当前目录）
77 
78 #### AI模型配置
79 
80 - `-model -m`： 同时配置核心模型和数据模型
81 - `-temperature -t`： 同时配置核心模型和数据模型温度
82 - `--core-model --cm`：核心AI操作使用的模型（默认：gpt-4o）
83 - `--data-model --dm`：数据操作使用的模型（默认：gpt-4o）
84 - `--core-temperature --ct`：核心模型的温度参数（默认：0.7）
85 - `--data-temperature --dt`：数据模型的温度参数（默认：0.7）
86 
87 #### 工作流配置
88 
89 - `--mode`：工作模式，可选"client"或"bot"（默认：client）
90   - `client`：个人开发助手模式，基于当前代码状态工作
91   - `bot`：GitHub自动化模式，拉取最新分支，自动提交并回复Issues
92 - `--default-branch --branch`：默认Git分支（默认：main）
93 - `--base-url -u`：API调用的基础URL
94 - `--api-key -k`：API密钥（也可以通过OPENAI_API_KEY环境变量设置）
95 - `--github-remote-url --git-url`：GitHub远程URL
96 - `--github-token --git-token`：GitHub令牌
97 
98 #### 执行控制
99 
100 - `--max-retry`：最大重试次数（默认：3）
101 
102 ### 简易脚本使用
103 
104 你也可以使用提供的脚本简化命令行调用：
105 
106 ```bash
107 ./scripts/run_bot.sh <问题ID> [需求文件路径]
108 ```
109 
110 ## 编程方式使用
111 
112 你也可以在Python代码中以编程方式使用客户端包：
113 
114 ```python
115 from client.runner import run_workflow
116 
117 run_workflow(
118     issue_id=42,
119     requirement="为项目创建一个README文件",
120     core_model="gpt-4o",
121     data_model="gpt-4o",
122     core_temperature=0.7,
123     data_temperature=0.7
124 )
125 ```
126 
127 ## 环境变量
128 
129 工具会读取以下环境变量：
130 
131 - `OPENAI_API_KEY`：OpenAI的API密钥
132 - `OPENAI_API_BASE`：OpenAI API的基础URL
133 - `GITHUB_TOKEN`：GitHub身份验证令牌
```




```
File: client/__init__.py
1 """Client package for running the WorkflowEngine from the terminal."""
2 
3 # Export file memory functions for programmatic use
4 from client.file_memory_client import initialize_file_memory, update_file_descriptions, process_failed_files
5
```




```
File: client/cli.py
1 """
2 Command-line interface for the WorkflowEngine.
3 Provides functionality to parse command-line arguments and run the engine.
4 """
5 
6 import argparse
7 import os
8 import sys
9 from typing import Optional, Dict, Any
10 
11 
12 def parse_args() -> argparse.Namespace:
13     """Parse command-line arguments for the WorkflowEngine."""
14     parser = argparse.ArgumentParser(
15         description="Run the WorkflowEngine to process user requirements"
16     )
17 
18     # Required arguments
19     parser.add_argument(
20         "--project-dir", 
21         "-p",
22         type=str, 
23         default=os.path.abspath(os.getcwd()),
24         help="Path to the project directory (default: current directory)"
25     )
26     parser.add_argument(
27         "--issue-id", 
28         "-i",
29         type=int, 
30         required=True,
31         help="The ID of the issue being processed"
32     )
33     parser.add_argument(
34         "--requirement", 
35         "-r",
36         type=str, 
37         help="The user requirement text"
38     )
39     parser.add_argument(
40         "--requirement-file", 
41         "-f",
42         type=str, 
43         help="Path to file containing the user requirement"
44     )
45 
46     # Optional arguments for WorkflowEngineConfig
47     # 统一模型配置
48     parser.add_argument(
49         "--model", 
50         "-m",
51         type=str, 
52         help="Model to use for both core and data operations (优先级高于单独配置)"
53     )
54     parser.add_argument(
55         "--temperature",
56         "-t",
57         type=float, 
58         help="Temperature for both core and data models (优先级高于单独配置)"
59     )
60     
61     # 独立模型配置
62     parser.add_argument(
63         "--core-model", 
64         "--cm",
65         type=str, 
66         default="gpt-4o",
67         help="Model to use for core AI operations (当未设置--model时使用)"
68     )
69     parser.add_argument(
70         "--data-model", 
71         "--dm",
72         type=str, 
73         default="gpt-4o",
74         help="Model to use for data operations (当未设置--model时使用)"
75     )
76     parser.add_argument(
77         "--core-temperature",
78         "--ct",
79         type=float, 
80         default=0.7,
81         help="Temperature for core model (当未设置--temperature时使用)"
82     )
83     parser.add_argument(
84         "--data-temperature",
85         "--dt",
86         type=float, 
87         default=0.7,
88         help="Temperature for data model (当未设置--temperature时使用)"
89     )
90     parser.add_argument(
91         "--max-retry", 
92         "--retry",
93         type=int, 
94         default=3,
95         help="Maximum number of retry attempts"
96     )
97     parser.add_argument(
98         "--default-branch", 
99         "--branch",
100         type=str, 
101         default="main",
102         help="Default branch name"
103     )
104     parser.add_argument(
105         "--mode",
106         "-md",
107         type=str,
108         choices=["client", "bot"],
109         default="client",
110         help="Operation mode: 'client' or 'bot'"
111     )
112     parser.add_argument(
113         "--base-url",
114         "-u",
115         type=str,
116         help="Base URL for API calls"
117     )
118     parser.add_argument(
119         "--api-key",
120         "-k",
121         type=str,
122         help="API key for authentication"
123     )
124     parser.add_argument(
125         "--github-remote-url",
126         "--git-url",
127         type=str,
128         help="GitHub remote repository URL"
129     )
130     parser.add_argument(
131         "--github-token",
132         "--git-token",
133         type=str,
134         help="GitHub authentication token"
135     )
136     
137     return parser.parse_args()
138 
139 
140 def get_requirement_text(args: argparse.Namespace) -> Optional[str]:
141     """Get requirement text from arguments or file."""
142     if args.requirement:
143         return args.requirement
144     elif args.requirement_file:
145         try:
146             with open(args.requirement_file, 'r', encoding='utf-8') as file:
147                 return file.read()
148         except IOError as e:
149             print(f"Error reading requirement file: {e}", file=sys.stderr)
150             return None
151     else:
152         print("No requirement specified. Use --requirement or --requirement-file", file=sys.stderr)
153         return None
154 
155 
156 def build_config_from_args(args: argparse.Namespace) -> Dict[str, Any]:
157     """Build WorkflowEngineConfig parameters from command line arguments."""
158     
159     # 处理统一的模型和温度配置
160     core_model = args.core_model
161     data_model = args.data_model
162     core_temperature = args.core_temperature
163     data_temperature = args.data_temperature
164     
165     # 如果设置了统一模型，则覆盖个别设置
166     if args.model:
167         core_model = args.model
168         data_model = args.model
169         
170     # 如果设置了统一温度，则覆盖个别设置
171     if args.temperature is not None:
172         core_temperature = args.temperature
173         data_temperature = args.temperature
174     
175     config_params = {
176         "project_dir": args.project_dir,
177         "issue_id": args.issue_id,
178         "core_model": core_model,
179         "data_model": data_model,
180         "core_template": core_temperature,  # Note: using template to match original param name
181         "data_template": data_temperature,  # Note: using template to match original param name
182         "max_retry": args.max_retry, 
183         "default_branch": args.default_branch,
184         "mode": args.mode,
185     }
186     
187     # Add optional parameters if they're specified
188     if args.base_url:
189         config_params["base_url"] = args.base_url
190     if args.api_key:
191         config_params["api_key"] = args.api_key
192     if args.github_remote_url:
193         config_params["github_remote_url"] = args.github_remote_url
194     if args.github_token:
195         config_params["github_token"] = args.github_token
196         
197     return config_params
198
```




```
File: client/file_memory_client.py
1 """
2 File Memory Client
3 
4 A standalone client for initializing and managing FileMemory using only GitManager.
5 This module provides both CLI and programmatic interfaces for updating file descriptions.
6 """
7 
8 import argparse
9 import logging
10 import os
11 import sys
12 from typing import Dict, List, Optional
13 
14 from dotenv import load_dotenv
15 
16 from core.ai import AIConfig
17 from core.file_memory import FileMemory, FileMemoryConfig
18 from core.git_manager import GitManager, GitConfig
19 from core.log_config import setup_logging, get_logger
20 
21 logger = get_logger(__name__)
22 
23 
24 def initialize_file_memory(
25     project_dir: str,
26     model_name: str = "gpt-4o",
27     temperature: float = 0.7,
28     api_key: Optional[str] = None,
29     base_url: Optional[str] = None,
30     remote_url: Optional[str] = None,
31     auth_token: Optional[str] = None,
32 ) -> FileMemory:
33     """
34     Initialize FileMemory using GitManager without LogManager.
35     
36     Args:
37         project_dir: Path to the project directory
38         model_name: AI model to use for generating file descriptions
39         temperature: Temperature setting for AI responses
40         api_key: API key for AI service (will use env var if None)
41         base_url: Base URL for AI service (will use default if None)
42         remote_url: Git remote URL (will use env var if None)
43         auth_token: Git authentication token (will use env var if None)
44         
45     Returns:
46         Initialized FileMemory instance
47     """
48     # Create AI config
49     ai_config = AIConfig(
50         model_name=model_name,
51         temperature=temperature,
52         api_key=api_key,
53         base_url=base_url
54     )
55     
56     # Create Git config
57     git_config = GitConfig(
58         repo_path=project_dir,
59         remote_url=remote_url or os.getenv("GIT_REMOTE_URL"),
60         auth_token=auth_token or os.getenv("GITHUB_TOKEN")
61     )
62     
63     # Initialize Git manager
64     git_manager = GitManager(config=git_config)
65     
66     # Initialize and return FileMemory
67     file_memory_config = FileMemoryConfig(
68         project_dir=project_dir,
69         git_manager=git_manager,
70         ai_config=ai_config,
71         log_manager=None  # Explicitly set to None as per requirements
72     )
73     
74     return FileMemory(config=file_memory_config)
75 
76 
77 def update_file_descriptions(file_memory: FileMemory) -> None:
78     """
79     Update file descriptions using the given FileMemory instance.
80     
81     Args:
82         file_memory: Initialized FileMemory instance
83         
84     Returns:
85         Dictionary mapping file paths to their descriptions
86     """
87     return file_memory.update_file_details()
88 
89 
90 def process_failed_files(file_memory: FileMemory) -> Dict[str, str]:
91     """
92     Process previously failed files to generate their descriptions.
93     
94     Args:
95         file_memory: Initialized FileMemory instance
96         
97     Returns:
98         Dictionary mapping file paths to their descriptions
99     """
100     return file_memory.process_failed_files()
101 
102 
103 def main() -> None:
104     """Command line interface for FileMemory client."""
105     # Load environment variables
106     load_dotenv()
107     
108     # Parse command line arguments
109     parser = argparse.ArgumentParser(description="FileMemory Client - Update file descriptions for a project")
110     parser.add_argument("-d", "--directory", default=".", help="Project directory path (default: current directory)")
111     parser.add_argument("-m", "--model", default="gpt-4o", help="AI model name (default: gpt-4o)")
112     parser.add_argument("-t", "--temperature", type=float, default=0.7, help="AI temperature (default: 0.7)")
113     parser.add_argument("-k", "--api-key", help="OpenAI API key (defaults to OPENAI_API_KEY env var)")
114     parser.add_argument("-u", "--base-url", help="Base URL for API calls (optional)")
115     parser.add_argument("--git-url", help="Git remote URL (defaults to GIT_REMOTE_URL env var)")
116     parser.add_argument("--git-token", help="Git auth token (defaults to GITHUB_TOKEN env var)")
117     parser.add_argument("-l", "--log-level", choices=["DEBUG", "INFO", "WARNING", "ERROR"], default="INFO", help="Logging level")
118     parser.add_argument("--failed-only", action="store_true", help="Process only previously failed files")
119     args = parser.parse_args()
120     
121     # Setup logging
122     setup_logging(log_level=getattr(logging, args.log_level))
123     
124     # Get absolute path for project directory
125     project_dir = os.path.abspath(args.directory)
126     if not os.path.isdir(project_dir):
127         logger.error(f"Project directory does not exist: {project_dir}")
128         sys.exit(1)
129     
130     logger.info(f"Initializing FileMemory for project: {project_dir}")
131     
132     # Initialize FileMemory
133     file_memory = initialize_file_memory(
134         project_dir=project_dir,
135         model_name=args.model,
136         temperature=args.temperature,
137         api_key=args.api_key,
138         base_url=args.base_url,
139         remote_url=args.git_url,
140         auth_token=args.git_token
141     )
142     
143     # Update file details or process failed files
144     if args.failed_only:
145         process_failed_files(file_memory)
146         logger.info("Processed failed files")
147     else:
148         update_file_descriptions(file_memory)
149         logger.info("Updated descriptions files")
150 
151 
152 if __name__ == "__main__":
153     main()
154
```




```
File: client/runner.py
1 """
2 Programmatic API for running the WorkflowEngine.
3 Provides a simplified interface for use in Python scripts.
4 """
5 
6 import os
7 from typing import Optional, Dict, Any, Union
8 
9 from dotenv import load_dotenv
10 
11 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
12 
13 
14 def run_workflow(
15     issue_id: int,
16     requirement: str,
17     project_dir: Optional[str] = None,
18     model: Optional[str] = None,  # 统一的模型设置
19     core_model: Optional[str] = "gpt-4o",
20     data_model: Optional[str] = None,  # 默认与core_model相同
21     temperature: Optional[float] = None,  # 统一的温度设置
22     core_temperature: float = 0.7,
23     data_temperature: float = 0.7,
24     max_retry: int = 3,
25     default_branch: str = "main",
26     mode: str = "client",
27     base_url: Optional[str] = None,
28     api_key: Optional[str] = None,
29     github_remote_url: Optional[str] = None,
30     github_token: Optional[str] = None,
31     **kwargs: Dict[str, Any]
32 ) -> None:
33     """Run the WorkflowEngine with the given configuration."""
34     # Load environment variables
35     load_dotenv()
36     
37     # Use current directory if no project_dir specified
38     if project_dir is None:
39         project_dir = os.getcwd()
40     
41     # 处理统一的模型配置
42     if model is not None:
43         core_model = model
44         data_model = model
45     
46     # 如果未指定data_model，则默认与core_model相同
47     if data_model is None:
48         data_model = core_model
49     
50     # 处理统一的温度配置
51     if temperature is not None:
52         core_temperature = temperature
53         data_temperature = temperature
54     
55     # Create config with provided parameters
56     config = WorkflowEngineConfig(
57         project_dir=project_dir, issue_id=issue_id, 
58         core_model=core_model, data_model=data_model,
59         core_template=core_temperature, data_template=data_temperature,
60         max_retry=max_retry, default_branch=default_branch, mode=mode, 
61         base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
62         github_token=github_token
63     )
64     
65     # Run the workflow engine
66     engine = WorkflowEngine(config)
67     response = engine.process_requirement(requirement)
68     
69     return response
70
```




```
File: client/terminal.py
1 """
2 Terminal entrypoint for the WorkflowEngine.
3 Provides functionality to run the engine from terminal with command-line arguments.
4 """
5 import logging
6 import os
7 import sys
8 from dotenv import load_dotenv
9 
10 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
11 from client.cli import parse_args, get_requirement_text, build_config_from_args
12 from core.log_config import setup_logging
13 
14 
15 def run_workflow_from_terminal() -> str:
16     """
17     Main entry point for running the workflow engine from terminal.
18     Parses command line arguments and runs the workflow engine.
19     """
20     # Load environment variables from .env file if present
21     load_dotenv()
22     
23     # Parse command line arguments
24     args = parse_args()
25     
26     # Get requirement text
27     requirement = get_requirement_text(args)
28     if not requirement:
29         sys.exit(1)
30     
31     # Build config from arguments
32     config_params = build_config_from_args(args)
33     
34     # Try to get API key from environment if not provided as argument
35     if "api_key" not in config_params and os.environ.get("OPENAI_API_KEY"):
36         config_params["api_key"] = os.environ.get("OPENAI_API_KEY")
37     
38     # Create the workflow engine config
39     config = WorkflowEngineConfig(**config_params)
40     
41     # Initialize and run the workflow engine
42     engine = WorkflowEngine(config)
43     response = engine.process_requirement(requirement)
44     
45     # Print the response to the terminal if available
46     if response:
47         print(f"\nResponse:\n{response}")
48     
49     return response if response else ""
50 
51 
52 if __name__ == "__main__":
53     setup_logging(log_level=logging.INFO)
54     response = run_workflow_from_terminal()
55 
56
```




```
File: core/git_manager.py
1 import os
2 import shutil
3 from dataclasses import dataclass
4 from typing import Optional, List
5 from urllib.parse import urlparse, urlunparse
6 
7 import git
8 
9 from core.log_config import get_logger
10 
11 logger = get_logger(__name__)
12 
13 
14 @dataclass
15 class GitConfig:
16     """Git configuration parameters"""
17 
18     repo_path: str
19     remote_name: str = "origin"
20     default_branch: str = "main"
21     remote_url: Optional[str] = os.getenv("GIT_REMOTE")
22     auth_token: Optional[str] = os.getenv("GITHUB_TOKEN")
23 
24 
25 class GitManager:
26     """Manages git operations including push, pull, branch creation and switching"""
27 
28     def __init__(self, config: GitConfig):
29         """Initialize GitManager with configuration"""
30         self.config = config
31         self.repo = None
32         self._ensure_repo()
33 
34     def _ensure_repo(self) -> None:
35         """Ensure git repository exists and is properly initialized"""
36         if not os.path.exists(self.config.repo_path):
37             if self.config.remote_url:
38                 self.clone()
39             else:
40                 raise ValueError(
41                     f"Repository path does not exist: {self.config.repo_path}"
42                 )
43         else:
44             try:
45                 self.repo = git.Repo(self.config.repo_path)
46                 # Set auth token for remote operations if provided
47                 if self.config.auth_token and self.config.remote_url:
48                     self._set_remote_with_auth()
49             except git.InvalidGitRepositoryError:
50                 raise ValueError(
51                     f"Invalid git repository at: {self.config.repo_path}"
52                 )
53 
54 
55     def _get_url_with_token(self, url: str) -> str:
56         """
57         Insert authentication token into git URL
58 
59         Args:
60             url: Original git URL
61 
62         Returns:
63             URL with authentication token
64         """
65         if not self.config.auth_token:
66             return url
67 
68         parsed = urlparse(url)
69 
70         # Handle different URL formats
71         if parsed.scheme in ["http", "https"]:
72             netloc = f"{self.config.auth_token}@{parsed.netloc}"
73             return urlunparse(
74                 (
75                     parsed.scheme,
76                     netloc,
77                     parsed.path,
78                     parsed.params,
79                     parsed.query,
80                     parsed.fragment,
81                 )
82             )
83         elif "@" in url and ":" in url and url.startswith("git@"):  # Handle SSH format: git@github.com:username/repo.git
84             return url  # Don't modify SSH URLs
85         else:
86             return url  # Return original if format is not recognized
87 
88     def _set_remote_with_auth(self) -> None:
89         """Configure remote with authentication token"""
90         if not self.repo or not self.config.auth_token or not self.config.remote_url:
91             return
92 
93         try:
94             # Get current remotes
95             remotes = list(self.repo.remotes)
96             remote_exists = any(
97                 remote.name == self.config.remote_name for remote in remotes
98             )
99 
100             # Prepare URL with token
101             url_with_token = self._get_url_with_token(self.config.remote_url)
102 
103             # Set or update remote
104             if remote_exists:
105                 self.repo.git.remote("set-url", self.config.remote_name, url_with_token)
106             else:
107                 self.repo.git.remote("add", self.config.remote_name, url_with_token)
108 
109             logger.info(
110                 f"Configured remote '{self.config.remote_name}' with authentication"
111             )
112         except git.GitCommandError as e:
113             logger.error(f"Failed to configure remote with authentication: {str(e)}")
114             raise
115 
116     def clone(self) -> None:
117         """
118         Clone the repository specified in config
119 
120         Raises:
121             ValueError: If remote_url is not set in config
122             git.GitCommandError: If clone operation fails
123         """
124         if not self.config.remote_url:
125             raise ValueError("Remote URL must be set to clone a repository")
126 
127         self._clone_repo(branch=self.config.default_branch)
128 
129     def _clone_repo(self, branch: Optional[str] = None) -> None:
130         """
131         Internal method to perform the clone operation
132 
133         Args:
134             branch: Branch to checkout after cloning
135         """
136         try:
137             # Prepare parent directory if it doesn't exist
138             parent_dir = os.path.dirname(self.config.repo_path)
139             if parent_dir and not os.path.exists(parent_dir):
140                 os.makedirs(parent_dir)
141 
142             # Remove target directory if it exists
143             if os.path.exists(self.config.repo_path):
144                 shutil.rmtree(self.config.repo_path)
145 
146             # Prepare URL with token if provided
147             clone_url = self._get_url_with_token(self.config.remote_url)
148 
149             # Clone options
150             clone_args = {
151                 "url": clone_url,
152                 "to_path": self.config.repo_path,
153             }
154 
155             # Add branch if specified
156             if branch:
157                 clone_args["branch"] = branch
158 
159             # Clone the repository
160             self.repo = git.Repo.clone_from(**clone_args)
161 
162             logger.info(f"Successfully cloned repository to {self.config.repo_path}")
163 
164             # Configure remote with auth token if provided
165             if self.config.auth_token:
166                 self._set_remote_with_auth()
167 
168         except git.GitCommandError as e:
169             logger.error(f"Failed to clone repository: {str(e)}")
170             # Clean up if clone failed
171             if os.path.exists(self.config.repo_path):
172                 shutil.rmtree(self.config.repo_path)
173             raise
174 
175     def pull(self, branch: Optional[str] = None) -> None:
176         """
177         Pull changes from remote repository
178 
179         Args:
180             branch: Branch to pull from. If None, pulls current branch
181         """
182         try:
183             if branch:
184                 self.repo.git.pull(self.config.remote_name, branch)
185             else:
186                 self.repo.git.pull()
187             logger.info(
188                 f"Successfully pulled changes from {branch or 'current branch'}"
189             )
190         except git.GitCommandError as e:
191             logger.error(f"Failed to pull changes: {str(e)}")
192             raise
193 
194     def push(
195         self,
196         branch: Optional[str] = None,
197         force: bool = False,
198         set_upstream: bool = True,
199     ) -> None:
200         """
201         Push changes to remote repository
202 
203         Args:
204             branch: Branch to push. If None, pushes current branch
205             force: Whether to force push
206             set_upstream: Whether to set upstream branch if it doesn't exist
207         """
208         try:
209             # 确保远程 URL 包含认证令牌
210             if self.config.auth_token:
211                 self._set_remote_with_auth()
212 
213             # 如果没有指定分支，获取当前分支
214             current_branch = branch or self.get_current_branch()
215 
216             # 执行推送操作
217             if force:
218                 if set_upstream:
219                     self.repo.git.push(
220                         "-f", "--set-upstream", self.config.remote_name, current_branch
221                     )
222                 else:
223                     if branch:
224                         self.repo.git.push("-f", self.config.remote_name, branch)
225                     else:
226                         self.repo.git.push("-f")
227             else:
228                 if set_upstream:
229                     self.repo.git.push(
230                         "--set-upstream", self.config.remote_name, current_branch
231                     )
232                 else:
233                     if branch:
234                         self.repo.git.push(self.config.remote_name, branch)
235                     else:
236                         self.repo.git.push()
237 
238             logger.info(f"Successfully pushed changes to {current_branch}")
239         except git.GitCommandError as e:
240             logger.error(f"Failed to push changes: {str(e)}")
241             raise
242 
243     def create_branch(
244         self, branch_name: str, start_point: Optional[str] = None
245     ) -> None:
246         """
247         Create a new branch
248 
249         Args:
250             branch_name: Name of the new branch
251             start_point: Branch/commit to create branch from. If None, uses current HEAD
252         """
253         try:
254             if start_point:
255                 self.repo.git.branch(branch_name, start_point)
256             else:
257                 self.repo.git.branch(branch_name)
258             logger.info(f"Successfully created branch: {branch_name}")
259         except git.GitCommandError as e:
260             logger.error(f"Failed to create branch: {str(e)}")
261             raise
262 
263     def switch_branch(self, branch_name: str, create: bool = False) -> None:
264         """
265         Switch to specified branch
266 
267         Args:
268             branch_name: Name of the branch to switch to
269             create: Create branch if it doesn't exist
270         """
271         try:
272             if create:
273                 try:
274                     self.repo.git.checkout("-b", branch_name)
275                 except:
276                     self.repo.git.checkout(branch_name)
277             else:
278                 self.repo.git.checkout(branch_name)
279             logger.info(f"Successfully switched to branch: {branch_name}")
280         except git.GitCommandError as e:
281             logger.error(f"Failed to switch branch: {str(e)}")
282             raise
283 
284     def delete_branch(self, branch_name: str, force: bool = False) -> None:
285         """
286         Delete specified branch
287 
288         Args:
289             branch_name: Name of the branch to delete
290             force: Force delete even if branch not fully merged
291         """
292         try:
293             if force:
294                 self.repo.git.branch("-D", branch_name)
295             else:
296                 self.repo.git.branch("-d", branch_name)
297             logger.info(f"Successfully deleted branch: {branch_name}")
298         except git.GitCommandError as e:
299             logger.error(f"Failed to delete branch: {str(e)}")
300             raise
301 
302     def get_current_branch(self) -> str:
303         """Get name of current branch"""
304         return self.repo.active_branch.name
305 
306     def list_branches(self, remote: bool = False) -> List[str]:
307         """
308         List all branches
309 
310         Args:
311             remote: Whether to list remote branches instead of local
312 
313         Returns:
314             List of branch names
315         """
316         if remote:
317             return [ref.name for ref in self.repo.remote().refs]
318         return [branch.name for branch in self.repo.heads]
319 
320     def get_current_commit_id(self) -> str:
321         """获取当前提交的 ID"""
322         try:
323             return self.repo.head.commit.hexsha
324         except Exception as e:
325             logger.error(f"获取当前提交 ID 失败: {str(e)}")
326             return ""
327 
328     def get_changed_files(self, old_commit: str, new_commit: str) -> List[str]:
329         """
330         获取两个提交之间变更的文件列表
331 
332         Args:
333             old_commit: 旧提交的 ID
334             new_commit: 新提交的 ID
335 
336         Returns:
337             变更的文件路径列表
338         """
339         try:
340             # 获取提交对象
341             old = self.repo.commit(old_commit)
342             new = self.repo.commit(new_commit)
343 
344             # 获取差异
345             diff_index = old.diff(new)
346 
347             # 收集所有变更的文件
348             changed_files = set()
349 
350             # 添加修改的文件
351             for diff in diff_index.iter_change_type("M"):
352                 if not self.is_ignore(diff.a_path):
353                     changed_files.add(diff.a_path)
354 
355             # 添加增加的文件
356             for diff in diff_index.iter_change_type("A"):
357                 if not self.is_ignore(diff.b_path):
358                     changed_files.add(diff.b_path)
359 
360             # 添加删除的文件
361             for diff in diff_index.iter_change_type("D"):
362                 if not self.is_ignore(diff.b_path):
363                     changed_files.add(diff.a_path)
364 
365             return list(changed_files)
366         except Exception as e:
367             logger.error(f"获取变更文件列表失败: {str(e)}")
368             return []
369 
370     def is_ignore(self, path: str) -> bool:
371         # 检查文件名是否以点开头
372         file_name = os.path.basename(path)
373         if file_name.startswith("."):
374             return True
375         # 检查路径中是否包含以点开头的目录
376         path_parts = path.split(os.path.sep)
377         for part in path_parts:
378             # 跳过空字符串（可能出现在路径开头）
379             if not part:
380                 continue
381             # 如果目录名以点开头，则忽略
382             if part.startswith("."):
383                 return True
384 
385         # 如果不满足任何忽略条件，则不忽略
386         return False
387 
388     def delete_local_repository(self, remove_git_config: bool = False) -> None:
389         """
390         删除本地代码仓库和可选的全局 git 配置
391 
392         Args:
393             remove_git_config: 是否同时删除与此仓库相关的全局 git 配置
394 
395         Raises:
396             ValueError: 如果仓库路径不存在
397             OSError: 如果删除操作失败
398         """
399         if not os.path.exists(self.config.repo_path):
400             logger.warning(f"仓库路径不存在，无需删除: {self.config.repo_path}")
401             return
402 
403         try:
404             # 关闭仓库连接以释放文件锁
405             if self.repo:
406                 self.repo.close()
407                 self.repo = None
408 
409             # 删除本地仓库目录
410             shutil.rmtree(self.config.repo_path)
411             logger.info(f"成功删除本地仓库: {self.config.repo_path}")
412 
413             # 可选：删除全局 git 配置中与此仓库相关的条目
414             if remove_git_config:
415                 self._remove_git_config()
416 
417         except (OSError, shutil.Error) as e:
418             logger.error(f"删除本地仓库失败: {str(e)}")
419             raise
420 
421     def _remove_git_config(self) -> None:
422         """
423         从全局 git 配置中删除与当前仓库相关的配置
424 
425         这包括：
426         - 与远程仓库 URL 相关的凭证
427         - 特定于此仓库的用户配置
428         """
429         try:
430             # 获取仓库的规范路径
431             repo_path = os.path.abspath(self.config.repo_path)
432             repo_name = os.path.basename(repo_path)
433 
434             # 尝试从 git 配置中删除与此仓库相关的条目
435             if self.config.remote_url:
436                 # 解析远程 URL 以获取主机名
437                 parsed = urlparse(self.config.remote_url)
438                 if parsed.netloc:
439                     # 尝试删除凭证
440                     try:
441                         git.cmd.Git().execute(
442                             ["git", "credential", "reject"],
443                             input=f"url={self.config.remote_url}\n\n",
444                         )
445                         logger.info(f"已尝试从凭证存储中删除 {parsed.netloc} 的凭证")
446                     except git.GitCommandError:
447                         logger.debug("凭证删除操作未成功，可能没有存储凭证")
448 
449             # 尝试删除仓库特定的配置（如果有）
450             try:
451                 git.cmd.Git().execute(
452                     [
453                         "git",
454                         "config",
455                         "--global",
456                         "--remove-section",
457                         f"remote.{repo_name}",
458                     ]
459                 )
460                 logger.info(f"已删除全局 git 配置中的 remote.{repo_name} 部分")
461             except git.GitCommandError:
462                 logger.debug(f"全局配置中没有 remote.{repo_name} 部分")
463 
464             logger.info("已完成 git 配置清理")
465 
466         except Exception as e:
467             logger.warning(f"清理 git 配置时出错: {str(e)}")
468             # 不抛出异常，因为这是次要操作
469 
470     def add_issue_comment(self, issue_number: int, comment_text: str) -> bool:
471         """
472         在 GitHub 仓库的指定 Issue 下添加评论
473 
474         Args:
475             issue_number: Issue 编号
476             comment_text: 评论内容
477 
478         Returns:
479             bool: 操作是否成功
480 
481         Raises:
482             ValueError: 如果未配置认证令牌或远程 URL
483             Exception: 如果添加评论过程中发生其他错误
484         """
485         try:
486             # 检查必要的配置
487             if not self.config.auth_token:
488                 raise ValueError("添加 Issue 评论需要认证令牌 (auth_token)")
489 
490             if not self.config.remote_url:
491                 raise ValueError("添加 Issue 评论需要远程仓库 URL (remote_url)")
492 
493             # 导入 PyGithub
494             try:
495                 from github import Github
496             except ImportError:
497                 raise ImportError("添加 Issue 评论需要安装 PyGithub 库: pip install PyGithub")
498 
499             # 解析仓库所有者和名称
500             parsed_url = urlparse(self.config.remote_url)
501             path_parts = parsed_url.path.strip("/").split("/")
502 
503             if len(path_parts) < 2 or not all(path_parts[:2]):
504                 raise ValueError(f"无法从 URL 解析仓库所有者和名称: {self.config.remote_url}")
505 
506             owner = path_parts[0]
507             repo_name = path_parts[1]
508             if repo_name.endswith(".git"):
509                 repo_name = repo_name[:-4]  # 移除 .git 后缀
510 
511             # 初始化 GitHub 客户端
512             g = Github(self.config.auth_token)
513 
514             # 获取仓库和 Issue
515             repo = g.get_repo(f"{owner}/{repo_name}")
516             issue = repo.get_issue(issue_number)
517 
518             # 添加评论
519             comment = issue.create_comment(f"bella-issues-bot已处理：\n{comment_text}")
520 
521             logger.info(f"成功在 Issue #{issue_number} 下添加评论 (ID: {comment.id})")
522             return True
523 
524         except Exception as e:
525             logger.error(f"添加 Issue 评论失败: {str(e)}")
526             raise
527 
528     def commit(
529         self, message: str, add_all: bool = True, files: Optional[List[str]] = None
530     ) -> str:
531         """
532         创建一个新的提交
533 
534         Args:
535             message: 提交信息
536             add_all: 是否添加所有变更的文件，默认为 True
537             files: 要添加的特定文件列表，如果 add_all 为 True 则忽略此参数
538 
539         Returns:
540             str: 新提交的 SHA 哈希值
541 
542         Raises:
543             git.GitCommandError: 如果 Git 操作失败
544         """
545         try:
546             # 添加文件到暂存区
547             if add_all:
548                 self.repo.git.add(A=True)
549             elif files:
550                 for file in files:
551                     self.repo.git.add(file)
552 
553             # 创建提交
554             commit = self.repo.index.commit(message)
555             logger.info(f"成功创建提交: {commit.hexsha[:7]} - {message}")
556 
557             return commit.hexsha
558         except git.GitCommandError as e:
559             logger.error(f"创建提交失败: {str(e)}")
560             raise
561 
562     def reset_to(self, target_branch: str) -> bool:
563         """
564         将当前分支重置到远程目标分支的状态
565 
566         Args:
567             target_branch: 目标分支名称
568 
569         Returns:
570             bool: 操作是否成功
571         """
572         try:
573             # 获取远程分支
574             remote_name = self.config.remote_name
575             remote_branches = self.list_branches(remote=True)
576             remote_target = f"{remote_name}/{target_branch}"
577             # 检查目标分支是否存在于远端
578             if remote_target not in remote_branches:
579                 logger.warning(f"目标分支 {remote_target} 不存在于远端")
580                 return False
581 
582             # 切换到目标分支，如果不存在则创建
583             logger.info(f"切换到分支: {target_branch}")
584             self.switch_branch(target_branch, create=True)
585 
586             # 拉取最新代码
587             logger.info(f"拉取远程分支: {remote_target} 的最新代码")
588             self.pull(target_branch)
589 
590             # 强制重置到远程分支状态
591             logger.info(f"重置到远程分支: {remote_target}")
592             self.repo.git.reset(f"{remote_target}", hard=True)
593 
594             logger.info(f"成功重置到版本: {target_branch}")
595             return True
596         except git.GitCommandError as e:
597             logger.error(f"重置到分支 {target_branch} 失败: {str(e)}")
598             return False
599         except Exception as e:
600             logger.error(f"重置过程中发生未知错误: {str(e)}")
601             return False
602 
603     def reset_to_issue_branch(self, issue_id: int) -> str:
604         """
605         拉取指定issue对应的最新分支并切换到该分支
606         如果该issue还未创建过分支，则切换到默认分支
607 
608         Args:
609             issue_id: Issue编号
610 
611         Returns:
612             str: 成功切换到的分支名称
613 
614         Raises:
615             git.GitCommandError: 如果Git操作失败
616         """
617         try:
618             # 确保远程仓库信息是最新的
619             self.repo.git.fetch(self.config.remote_name)
620             logger.info(f"成功获取远程仓库信息")
621             
622             # 获取所有远程分支
623             remote_branches = self.repo.git.branch("-r").splitlines()
624             remote_branches = [branch.strip() for branch in remote_branches]
625             
626             # 查找与指定issue相关的分支
627             issue_branch_name = f"bella-issues-bot-{issue_id}"
628             remote_issue_branch = f"{self.config.remote_name}/{issue_branch_name}"
629             
630             branch_exists = False
631             for branch in remote_branches:
632                 if remote_issue_branch in branch:
633                     branch_exists = True
634                     break
635                     
636             if branch_exists:
637                 # 切换到issue分支
638                 self.switch_branch(issue_branch_name, create=True)
639                 self.pull()
640                 logger.info(f"成功切换到issue #{issue_id}的分支: {issue_branch_name}")
641             else:
642                 # 如果没有找到相关分支，切换到默认分支
643                 self.switch_branch(self.config.default_branch)
644                 self.pull()
645                 logger.info(f"重置到远程分支: {self.config.remote_name}/{self.config.default_branch}")
646                 self.repo.git.reset(f"{self.config.remote_name}/{self.config.default_branch}", hard=True)
647                 logger.info(f"未找到issue #{issue_id}的分支，已切换到默认分支: {self.config.default_branch}")
648             
649             return issue_branch_name
650         except git.GitCommandError as e:
651             logger.error(f"切换到issue分支时出错: {str(e)}")
652             raise
653
```




```
File: core/workflow_engine.py
1 import os
2 import shutil
3 import tempfile
4 import uuid
5 from dataclasses import dataclass
6 from typing import Optional
7 
8 from core.ai import AIConfig
9 from core.chat_processor import ChatProcessor, ChatProcessorConfig
10 from core.code_engineer import CodeEngineer, CodeEngineerConfig
11 from core.decision import DecisionProcess
12 from core.diff import Diff
13 from core.file_memory import FileMemory, FileMemoryConfig
14 from core.file_selector import FileSelector
15 from core.git_manager import GitManager, GitConfig
16 from core.log_config import get_logger
17 from core.log_manager import LogManager, LogConfig
18 from core.prompt_generator import PromptGenerator, PromptData
19 from core.version_manager import VersionManager
20 
21 logger = get_logger(__name__)
22 
23 @dataclass
24 class WorkflowEngineConfig:
25     project_dir: str
26     issue_id:int
27     core_model:str = "gpt-4o"
28     data_model:str = "gpt-4o"
29     core_template: float = 0.7
30     data_template: float = 0.7
31     max_retry: int = 3,
32     default_branch: str = "main"
33     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
34     base_url: Optional[str] = None
35     api_key: Optional[str] = None
36     github_remote_url: Optional[str] =None
37     github_token: Optional[str] = None
38 
39 
40 class WorkflowEngine:
41     CODE_TIMES = 0
42     CHAT_TIMES = 0
43     """
44     工作流引擎，协调版本管理、日志管理和AI交互
45     """
46     def __init__(self, config: WorkflowEngineConfig):
47         """
48         初始化工作流引擎
49         
50         Args:
51             config: 工作流配置
52         """
53         self.CODE_TIMES = 0
54         self.CHAT_TIMES = 0
55         # 存储原始配置
56         self.original_config = config
57         
58         # 根据模式设置工作目录
59         if config.mode == "bot":
60             # 创建临时目录作为工作区
61             self.temp_dir = os.path.join(
62                 tempfile.gettempdir(), 
63                 f"bella-bot-{config.issue_id}-{str(uuid.uuid4())[:8]}"
64             )
65             os.makedirs(self.temp_dir, exist_ok=True)
66             # 更新配置以使用临时目录
67             self.config = WorkflowEngineConfig(
68                 project_dir=self.temp_dir,
69                 **{k: v for k, v in vars(config).items() if k != 'project_dir'}
70             )
71             logger.info(f"Bot模式：创建临时工作目录 {self.temp_dir}")
72         else:
73             # 客户端模式直接使用指定的目录
74             self.config = config
75             self.temp_dir = None
76 
77         self.project_dir = os.path.abspath(self.config.project_dir)
78         # 创建AI配置
79         self.core_ai_config = AIConfig(
80             model_name=config.core_model,
81             temperature=config.core_template,
82             base_url=config.base_url,
83             api_key=config.api_key
84         )
85         
86         self.data_ai_config = AIConfig(
87             model_name=config.data_model,
88             temperature=config.data_template,
89             base_url=config.base_url,
90             api_key=config.api_key
91         )
92         
93         # 创建Git配置
94         self.git_config = GitConfig(
95             repo_path=self.project_dir,
96             remote_url=config.github_remote_url or os.getenv("GIT_REMOTE"),
97             auth_token=config.github_token or os.getenv("GITHUB_TOKEN"),
98             default_branch=config.default_branch
99         )
100         
101         # 创建日志配置
102         self.log_config = LogConfig(
103             project_dir=self.project_dir,
104             issue_id=config.issue_id,
105             mode=config.mode
106         )
107         
108         # 初始化管理器
109         self.git_manager = GitManager(config=self.git_config)
110         self.log_manager = LogManager(config=self.log_config)
111         
112         # 初始化文件记忆管理，传入log_manager
113         self.file_memory = FileMemory(
114             config=FileMemoryConfig(
115                 git_manager=self.git_manager,
116                 ai_config=self.core_ai_config,
117                 project_dir=self.project_dir,
118                 log_manager=self.log_manager
119             )
120         )
121         self.version_manager = VersionManager(
122             issue_id=config.issue_id,
123             ai_config=self.core_ai_config,
124             log_manager=self.log_manager,
125             git_manager=self.git_manager,
126             file_memory=self.file_memory
127         )
128         self.file_selector = FileSelector(
129             self.project_dir,
130             self.config.issue_id,
131             ai_config=self.core_ai_config
132         )
133 
134         # 初始化代码工程师
135         self.code_engineer_config = CodeEngineerConfig(
136             project_dir=self.project_dir,
137             ai_config=self.core_ai_config
138         )
139         self.engineer = CodeEngineer(
140             self.code_engineer_config,
141             self.log_manager,
142             Diff(self.data_ai_config)
143         )
144         
145         # 初始化聊天处理器
146         self.chat_processor = ChatProcessor(
147             ai_config=self.core_ai_config,
148             log_manager=self.log_manager,
149             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
150         )
151         
152         # 初始化决策环境
153         self.decision_env = DecisionProcess(
154             ai_config=self.core_ai_config,
155             version_manager=self.version_manager
156         )
157     
158     def process_requirement(self, user_requirement: str) -> Optional[str]:
159         """
160         处理用户需求
161         
162         Args:
163             user_requirement: 用户需求
164 
165         Returns:
166             str: 处理结果的响应文本
167         """
168         try:
169             # 初始化环境
170             self._setup_environment()
171             
172             response = self._process_requirement_internal(user_requirement)
173             
174             # 如果是bot模式，在结束时清理临时目录
175             if self.config.mode == "bot":
176                 self._cleanup_environment()
177             
178             return response
179         except Exception as e:
180             logger.error(f"处理需求时发生错误: {str(e)}")
181             raise
182 
183     def _setup_environment(self) -> None:
184         """
185         根据模式设置工作环境
186         """
187         if self.config.mode == "bot":
188             try:
189                 # 重置到issue对应的分支
190                 self.git_manager.reset_to_issue_branch(self.config.issue_id)
191                 logger.info(f"成功初始化Bot模式环境，工作目录: {self.temp_dir}")
192             except Exception as e:
193                 logger.error(f"初始化Bot模式环境失败: {str(e)}")
194                 self._cleanup_environment()
195                 raise
196         current_round = self.log_manager.get_current_round()
197 
198         # 如果轮次大于1，增量更新上一轮修改的文件详细信息
199         if self.file_memory and current_round > 1:
200             self.file_memory.update_file_details()
201             logger.info("已更新文件详细信息")
202         
203     def _cleanup_environment(self) -> None:
204         """
205         清理工作环境，删除临时目录
206         """
207         if self.config.mode == "bot" and self.temp_dir and os.path.exists(self.temp_dir):
208             try:
209                 # 关闭git仓库连接
210                 if hasattr(self, 'git_manager') and self.git_manager:
211                     self.git_manager.delete_local_repository()
212                 
213                 # 删除临时目录
214                 shutil.rmtree(self.temp_dir, ignore_errors=True)
215                 logger.info(f"已清理临时工作目录: {self.temp_dir}")
216             except Exception as e:
217                 logger.warning(f"清理临时目录时出错: {str(e)}")
218                 # 即使清理失败也不抛出异常，让主流程继续
219 
220     def _process_requirement_internal(self, user_requirement: str) -> Optional[str]:
221         """
222         内部处理需求的方法
223         
224         Args:
225             user_requirement: 用户需求
226             
227         Returns:
228             str: 处理结果
229         """
230         # 先通过决策环境分析需求类型
231         decision_result = self.decision_env.analyze_requirement(user_requirement)
232         
233         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
234                     f"理由={decision_result.reasoning}")
235         
236         if decision_result.needs_code_modification:
237             # 执行代码修改流程
238             response = self._run_code_generation_workflow(user_requirement)
239         else: 
240             # 执行对话流程
241             response = self._run_chat_workflow(user_requirement)
242         
243         # 如果是Bot模式且有GitHub配置，自动回复到issue
244         if self.config.mode == "bot":
245             try:
246                 self.version_manager.finalize_changes(mode=self.config.mode, comment_text=response)
247                 logger.info(f"更改已经推送到远端，并添加了Issue评论")
248             except Exception as e:
249                 logger.error(f"添加Issue评论时出错: {str(e)}")
250                 
251         return response
252     
253     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
254         """
255         执行代码生成流程，基于example_code_generate.py的逻辑
256         
257         Args:
258             user_requirement: 用户需求
259             
260         Returns:
261             str: 处理结果
262         """
263         logger.info("开始执行代码生成流程")
264 
265         # 确定当前版本
266         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
267 
268         # 生成提示词
269         user_prompt = self._get_user_prompt(requirement, history)
270 
271         # 根据提示词修改代码
272         success, response = self.engineer.process_prompt(prompt=user_prompt)
273 
274         # 提交更改
275         if success:
276             return response
277         else:
278             self.CODE_TIMES += 1
279             if self.CODE_TIMES >= self.config.max_retry:
280                 logger.error("code workflow超过最大重试次数")
281                 return self._run_chat_workflow(user_requirement)
282             else:
283                 return self._run_code_generation_workflow(user_requirement)
284     
285     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
286         """
287         执行聊天流程，基于example_chat_process.py的逻辑
288         
289         Args:
290             user_requirement: 用户需求
291             
292         Returns:
293             str: 处理结果
294         """
295         logger.info("开始执行聊天回复流程")
296 
297         history = self.version_manager.get_formatted_history()
298 
299         # 生成提示词
300         user_prompt = self._get_user_prompt(user_requirement, history)
301         
302         # 处理聊天请求
303         response = self.chat_processor.process_chat(user_prompt)
304 
305         if(response):
306             return response
307         else:
308             self.CHAT_TIMES += 1
309             if self.CHAT_TIMES >= self.config.max_retry:
310                 logger.error("chat workflow超过最大重试次数")
311                 return None
312             else:
313                 return self._run_chat_workflow(user_requirement)
314 
315     def _get_user_prompt(self, requirement: str, history: str) -> str:
316         # 选择文件
317         files = self.file_selector.select_files_for_requirement(requirement)
318         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
319 
320         # 准备提示词数据
321         data = PromptData(
322             requirement=requirement,
323             project_dir=self.project_dir,
324             steps=history,
325             files=files,
326             file_desc=descriptions
327         )
328 
329         # 生成提示词
330         return PromptGenerator.generatePrompt(data)
331
```




```
File: core/file_memory.py
1 import json
2 import os
3 import time
4 import datetime
5 from dataclasses import dataclass
6 from typing import Dict, List, Optional, Set, Union
7 
8 from dotenv import load_dotenv
9 from langchain.tools import Tool
10 
11 from core.ai import AIAssistant, AIConfig
12 from core.file_fetcher import FileFetcher
13 from core.git_manager import GitManager, GitConfig
14 from core.log_manager import LogManager
15 from core.log_config import get_logger
16 
17 logger = get_logger(__name__)
18 
19 @dataclass
20 class FileMemoryConfig:
21     """配置文件记忆管理"""
22     project_dir: str
23     git_manager: GitManager
24     ai_config: AIConfig
25     # 可选的LogManager，用于获取上一轮修改信息
26     log_manager: Optional[LogManager] = None
27 
28 
29 class FileDetail:
30     """文件详细信息类"""
31     pass
32 
33 
34 class FileMemory:
35     """管理文件描述的记忆"""
36 
37     MEMORY_DIR = ".eng/memory"
38     FILE_DETAILS_PATH = f"{MEMORY_DIR}/file_details.txt"
39     GIT_ID_FILE = f"{MEMORY_DIR}/git_id"
40     MAX_RETRIES = 3    # 最大重试次数
41     RETRY_DELAY = 30    # 重试延迟（秒）
42     # 每批次最大行数和字符数限制
43     MAX_LINES_PER_BATCH = 10000  # 最大行数
44     MAX_CHARS_PER_BATCH = 50000  # 最大字符数，约为 100KB
45     MAX_FILES_PER_BATCH = 20  # 每批次最多处理的文件数
46 
47     def __init__(self, config: FileMemoryConfig):
48         self.config = config
49         self.memory_path = os.path.join(config.project_dir, self.FILE_DETAILS_PATH)
50         self.git_id_path = os.path.join(config.project_dir, self.GIT_ID_FILE)
51 
52         # 保存LogManager引用
53         self.log_manager = config.log_manager
54 
55         # 初始化 AI 助手
56         self.ai_assistant = AIAssistant(config=self.config.ai_config, tools=[self._create_batch_description_tool()])
57 
58         # 初始化 Git 管理器
59         self.git_manager = self.config.git_manager
60 
61         # 确保内存目录存在
62         os.makedirs(os.path.dirname(self.memory_path), exist_ok=True)
63 
64     def _ensure_directories(self):
65         """确保必要的目录存在"""
66         memory_dir = os.path.join(self.config.project_dir, self.MEMORY_DIR)
67         os.makedirs(memory_dir, exist_ok=True)
68 
69     def _get_failed_files_path(self) -> str:
70         """获取失败文件记录的路径"""
71         return os.path.join(self.config.project_dir, self.MEMORY_DIR, "failed_files.json")
72 
73     def _read_failed_files(self) -> List[str]:
74         """读取处理失败的文件列表"""
75         failed_files_path = self._get_failed_files_path()
76         if os.path.exists(failed_files_path):
77             try:
78                 with open(failed_files_path, 'r', encoding='utf-8') as f:
79                     return json.load(f)
80             except Exception as e:
81                 logger.error(f"读取失败文件列表出错: {str(e)}")
82         return []
83 
84     def _write_failed_files(self, failed_files: List[str]) -> None:
85         """写入处理失败的文件列表"""
86         failed_files_path = self._get_failed_files_path()
87         try:
88             with open(failed_files_path, 'w', encoding='utf-8') as f:
89                 json.dump(failed_files, f, ensure_ascii=False, indent=2)
90         except Exception as e:
91             logger.error(f"写入失败文件列表出错: {str(e)}")
92 
93     def _create_batch_description_tool(self) -> Tool:
94         """创建批量生成文件描述的工具"""
95         from langchain.tools import Tool
96         
97         def process_file_descriptions(file_descriptions: str) -> Dict[str, str]:
98             """
99             处理文件描述列表
100             
101             Args:
102                 file_descriptions: JSON格式的文件描述列表，格式为 [{"fileName": "path/to/file.py", "desc": "文件描述"}]
103                 
104             Returns:
105                 Dict[str, str]: 文件路径到描述的映射
106             """
107             try:
108                 descriptions = {}
109                 file_list = json.loads(file_descriptions)
110                 
111                 if not isinstance(file_list, list):
112                     logger.error("错误：输入必须是一个列表")
113                     return descriptions
114                 
115                 # 处理结果
116                 for item in file_list:
117                     if isinstance(item, dict) and "fileName" in item and "desc" in item:
118                         descriptions[item["fileName"]] = item["desc"]
119                     else:
120                         logger.warning(f"跳过无效的文件描述项: {item}")
121                 
122                 logger.info(f"成功处理了 {len(descriptions)} 个文件描述")
123                 return descriptions
124             except json.JSONDecodeError:
125                 logger.error("错误：输入不是有效的 JSON 格式")
126                 return {}
127             except Exception as e:
128                 logger.error(f"处理文件描述时出错: {str(e)}")
129                 return {}
130         
131         return Tool(
132             name="process_file_descriptions",
133             description="处理文件描述列表，输入必须是JSON格式的列表，每个元素包含fileName和desc字段",
134             func=process_file_descriptions,
135             return_direct=True
136         )
137 
138     def _generate_batch_file_descriptions(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
139         """
140         批量生成文件描述
141         
142         Args:
143             files_with_content: 包含文件路径和内容的列表，格式为 [{"filepath": "path/to/file.py", "content": "..."}]
144             
145         Returns:
146             Dict[str, str]: 文件路径到描述的映射
147         """
148         # 构建提示词
149         files_text = ""
150         for i, file_info in enumerate(files_with_content):
151             files_text += f"\n--- 文件 {i+1}: {file_info['filepath']} ---\n{file_info['content']}\n"
152         
153         prompt = f"""
154 请分析以下多个代码文件，并为每个文件生成一个简短的中文描述（每个不超过100字）。
155 描述应该包含：
156 1. 文件的主要功能
157 2. 包含的关键类或函数
158 3. 与其他文件的主要交互（如果明显的话）
159 
160 {files_text}
161 
162 请使用process_file_descriptions工具返回结果，输入必须是一个JSON格式的列表，每个元素包含fileName和desc字段。
163 例如：
164 [
165   {{"fileName": "path/to/file1.py", "desc": "这个文件实现了..."}},
166   {{"fileName": "path/to/file2.py", "desc": "这个文件定义了..."}}
167 ]
168 
169 请确保每个文件都有对应的描述，并且描述准确反映文件的功能和内容。
170 """
171         
172         # 尝试生成描述，最多重试MAX_RETRIES次
173         descriptions = {}
174         failed_files = []
175         file_paths = [file_info["filepath"] for file_info in files_with_content]
176         
177         for attempt in range(self.MAX_RETRIES):
178             try:
179                 logger.info(f"尝试批量生成文件描述（第{attempt+1}次尝试）")
180                 
181                 # 使用工具生成描述
182                 descriptions = self.ai_assistant.generate_response(prompt, use_tools=True)
183                 
184                 # 如果返回的不是字典，可能是字符串响应
185                 if not isinstance(descriptions, dict):
186                     logger.error(f"工具返回了非预期的结果类型: {type(descriptions)}")
187                     descriptions = {}
188                 
189                 # 检查是否所有文件都有描述
190                 missing_files = [
191                     file_path for file_path in file_paths
192                     if file_path not in descriptions
193                 ]
194                 
195                 if missing_files:
196                     failed_files.extend(missing_files)
197                     logger.warning(f"以下文件未能生成描述: {missing_files}")
198                 
199                 # 如果有成功处理的文件，则返回结果
200                 if descriptions:
201                     return descriptions
202             
203             except Exception as e:
204                 logger.error(f"批量生成文件描述失败（第{attempt+1}次尝试）: {str(e)}")
205             
206             # 如果不是最后一次尝试，则等待后重试
207             if attempt < self.MAX_RETRIES - 1:
208                 logger.info(f"等待 {self.RETRY_DELAY} 秒后重试...")
209                 time.sleep(self.RETRY_DELAY)
210         
211         # 所有尝试都失败，记录失败的文件
212         self._update_failed_files(file_paths)
213         
214         # 返回空结果
215         return descriptions
216 
217     def _update_failed_files(self, new_failed_files: List[str]) -> None:
218         """更新失败文件列表"""
219         if not new_failed_files:
220             return
221             
222         # 读取现有失败文件列表
223         existing_failed_files = self._read_failed_files()
224         
225         # 合并并去重
226         all_failed_files = list(set(existing_failed_files + new_failed_files))
227         
228         # 写入更新后的列表
229         self._write_failed_files(all_failed_files)
230         logger.info(f"更新了失败文件列表，共 {len(all_failed_files)} 个文件")
231 
232     def process_failed_files(self) -> Dict[str, str]:
233         """处理之前失败的文件"""
234         failed_files = self._read_failed_files()
235         if not failed_files:
236             logger.info("没有需要处理的失败文件")
237             return {}
238             
239         logger.info(f"开始处理 {len(failed_files)} 个失败文件")
240         
241         # 准备文件内容
242         files_with_content = []
243         for filepath in failed_files:
244             content = self._get_file_content(filepath)
245             if content.strip():  # 跳过空文件
246                 files_with_content.append({"filepath": filepath, "content": content})
247         
248         # 按批次处理文件
249         descriptions = self._process_files_in_batches(files_with_content)
250         
251         # 更新失败文件列表
252         if descriptions:
253             # 找出成功处理的文件
254             processed_files = list(descriptions.keys())
255             # 更新失败文件列表
256             new_failed_files = [f for f in failed_files if f not in processed_files]
257             self._write_failed_files(new_failed_files)
258             
259             logger.info(f"成功处理了 {len(processed_files)} 个之前失败的文件，还有 {len(new_failed_files)} 个文件失败, 如果存在要忽略的文件，请在项目根目录下配置 .eng/.engignore 配置方式同.gitignore")
260         
261         return descriptions
262 
263 
264     def _get_file_content(self, filepath: str) -> str:
265         """获取文件内容"""
266         try:
267             full_path = os.path.join(self.config.project_dir, filepath)
268             with open(full_path, "r", encoding="utf-8") as f:
269                 return f.read()
270         except Exception as e:
271             logger.error(f"读取文件 {filepath} 失败: {str(e)}, 如果要忽略该文件，请在项目根目录下配置 .eng/.engignore 配置方式同.gitignore")
272             return ""
273 
274     def _process_files_in_batches(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
275         """将文件分批处理"""
276         all_descriptions = {}
277         current_batch = []
278         current_lines = 0
279         current_size = 0
280 
281         
282         for file_info in files_with_content:
283             content = file_info["content"]
284             lines = len(content.splitlines())
285             chars = len(content)
286             
287             if lines == 0:
288                 continue
289                 
290             # 检查是否需要开始新批次
291             # 如果当前批次已满或添加此文件会超出限制，则处理当前批次并开始新批次
292             if (current_batch and (
293                 len(current_batch) >= self.MAX_FILES_PER_BATCH or
294                 current_lines + lines > self.MAX_LINES_PER_BATCH or
295                 current_size + chars > self.MAX_CHARS_PER_BATCH
296             )):
297                 # 处理当前批次
298                 logger.info(f"处理批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
299                 batch_descriptions = self._generate_batch_file_descriptions(current_batch)
300                 all_descriptions.update(batch_descriptions)
301                 
302                 # 重置批次
303                 current_batch = [file_info]
304                 current_lines = lines
305                 current_size = chars
306             else:
307                 current_batch.append(file_info)
308                 current_lines += lines
309                 current_size += chars
310         
311         # 处理最后一个批次
312         if current_batch:
313             logger.info(f"处理最后一个批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
314             batch_descriptions = self._generate_batch_file_descriptions(current_batch)
315             all_descriptions.update(batch_descriptions)
316         
317         return all_descriptions
318 
319     def _process_files_chunk(self, files: List[str]) -> Dict[str, str]:
320         """处理一组文件，生成描述"""
321         # 准备文件内容
322         files_with_content = []
323         for filepath in files:
324             content = self._get_file_content(filepath)
325             if content.strip():  # 跳过空文件
326                 files_with_content.append({"filepath": filepath, "content": content})
327         
328         # 按批次处理文件
329         return self._process_files_in_batches(files_with_content)
330 
331     def _read_git_id(self) -> str:
332         """读取保存的 Git ID"""
333         if not os.path.exists(self.git_id_path):
334             return ""
335         with open(self.git_id_path, "r") as f:
336             return f.read().strip()
337 
338     def _write_git_id(self, git_id: str) -> None:
339         """写入当前 Git ID"""
340         with open(self.git_id_path, "w") as f:
341             f.write(git_id)
342 
343     def _read_file_details(self) -> Dict[str, str]:
344         """读取文件描述信息"""
345         if not os.path.exists(self.memory_path):
346             return {}
347 
348         details = {}
349         with open(self.memory_path, "r", encoding="utf-8") as f:
350             for line in f:
351                 if ":" in line:
352                     filename, description = line.strip().split(":", 1)
353                     details[filename] = description
354         return details
355 
356     def _write_file_details(self, details: Dict[str, str]) -> None:
357         """写入文件描述信息"""
358         with open(self.memory_path, "w", encoding="utf-8") as f:
359             for filename, description in sorted(details.items()):
360                 f.write(f"{filename}:{description}\n")
361 
362     def update_file_details(self) -> None:
363         """更新文件描述信息"""
364         # 获取所有文件
365         all_files = set(FileFetcher.get_all_files_without_ignore(self.config.project_dir))
366         
367         # 读取现有描述
368         existing_details = self._read_file_details()
369         
370         files_to_process = []
371         
372         # 如果有LogManager，使用它获取上一轮修改的文件
373         if self.log_manager:
374             # 获取上一轮修改的文件
375             log_modified_files = self._get_last_round_modified_files()
376             
377             # 只处理LogManager中标记为修改的文件
378             files_to_process = list(log_modified_files & all_files)
379             
380             # 删除不存在的文件的描述
381             existing_details = {
382                 k: v for k, v in existing_details.items() if k in all_files
383             }
384             
385             logger.info(f"使用LogManager方式更新文件描述，处理{len(files_to_process)}个修改的文件")
386         else:
387             # 如果没有LogManager，回退到Git方式
388             current_git_id = self.git_manager.get_current_commit_id()
389             saved_git_id = self._read_git_id()
390             files_to_process = self._get_changed_files_git(all_files, existing_details, current_git_id, saved_git_id)
391             logger.info(f"使用Git方式更新文件描述，处理{len(files_to_process)}个文件")
392 
393         # 处理需要更新的文件
394         if files_to_process:
395             new_descriptions = self._process_files_chunk(files_to_process)
396             existing_details.update(new_descriptions)
397 
398         # 保存结果
399         self._write_file_details(existing_details)
400         if not self.log_manager:
401             # 只有使用Git方式时才更新Git ID
402             current_git_id = self.git_manager.get_current_commit_id()
403             self._write_git_id(current_git_id)
404 
405     def _get_last_round_modified_files(self) -> set:
406         """
407         从LogManager获取上一轮修改的文件列表
408         
409         Returns:
410             set: 上一轮修改的文件路径集合
411         """
412         if not self.log_manager:
413             logger.info("未提供LogManager，无法获取上一轮修改的文件")
414             return set()
415         
416         try:
417             # 获取当前轮次
418             current_round = self.log_manager.get_current_round()
419             
420             # 获取上一轮的日志条目
421             if current_round > 1:
422                 prev_round = current_round - 1
423                 log_entry = self.log_manager.get_issue_round_log_entry(prev_round, include_diff=True)
424                 
425                 if log_entry and log_entry.modified_files:
426                     # 从diff_info中提取文件路径
427                     modified_files = set()
428                     for diff_info in log_entry.modified_files:
429                         if diff_info.file_name and diff_info.is_create:
430                             modified_files.add(diff_info.file_name)
431                     
432                     logger.info(f"从LogManager获取到上一轮({prev_round})修改的文件: {len(modified_files)}个")
433                     return modified_files
434             return set()
435         except Exception as e:
436             logger.error(f"获取上一轮修改的文件失败: {str(e)}")
437             return set()
438 
439     def _get_changed_files_git(self, all_files: Set[str], existing_details: Dict[str, str], 
440                              current_git_id: str, saved_git_id: Optional[str]) -> List[str]:
441         """使用Git方式获取需要处理的文件列表"""
442         if saved_git_id:
443             # 获取自上次运行以来修改的文件
444             changed_files = set(
445                 self.git_manager.get_changed_files(saved_git_id, current_git_id)
446             ) & all_files
447             
448             logger.info(f"从Git获取到变更文件: {len(changed_files)}个")
449             
450             new_files = all_files - set(existing_details.keys())
451             logger.info(f"检测到新文件: {len(new_files)}个")
452             
453             return list(changed_files | new_files)
454         else:
455             # 首次运行，处理所有文件
456             return list(all_files)
457 
458     @classmethod
459     def get_file_descriptions(cls, project_dir: str) -> Dict[str, str]:
460         """获取文件描述的静态方法"""
461         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
462 
463         if not os.path.exists(memory_path):
464             return {}
465 
466         try:
467             descriptions = {}
468             with open(memory_path, "r", encoding="utf-8") as f:
469                 for line in f:
470                     if ":" in line:
471                         filename, description = line.strip().split(":", 1)
472                         descriptions[filename] = description
473             return descriptions
474         except Exception as e:
475             logger.error(f"读取文件描述失败: {str(e)}")
476             return {}
477 
478     @classmethod
479     def get_selected_file_descriptions(cls, project_dir: str, files: List[str]) -> Dict[str, str]:
480         """获取文件描述的静态方法"""
481         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
482 
483         if not os.path.exists(memory_path):
484             return {}
485         try:
486             descriptions = {}
487             with open(memory_path, "r", encoding="utf-8") as f:
488                 for line in f:
489                     if ":" in line:
490                         filename, description = line.strip().split(":", 1)
491                         if filename in files:
492                             descriptions[filename] = description
493             return descriptions
494         except Exception as e:
495             logger.error(f"读取文件描述失败: {str(e)}")
496             return {}
497 
498 if __name__ == "__main__":
499     load_dotenv()
500     project_dir = "../."
501     memory = FileMemory(
502         FileMemoryConfig(
503             ai_config=AIConfig(temperature=1, model_name="claude-3.7-sonnet"),
504             git_manager=GitManager(config=GitConfig(repo_path=project_dir)),
505             log_manager=None
506         )
507     )
508 
509     memory.update_file_details()
510
```




```
File: scripts/init_file_memory.sh
1 #!/bin/bash
2 
3 # Script to initialize file memory using GitManager (without LogManager)
4 # This script helps to run the bella-file-memory command with common options
5 
6 show_help() {
7     echo "Usage: $0 [options]"
8     echo ""
9     echo "Options:"
10     echo "  -d, --directory DIR    Set project directory (default: current directory)"
11     echo "  -m, --model MODEL      Set AI model (default: gpt-4o)"
12     echo "  -t, --temp VALUE       Set temperature (default: 0.7)"
13     echo "  -f, --failed-only      Process only previously failed files"
14     echo "  -h, --help             Show this help message"
15     echo ""
16 }
17 
18 if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
19     show_help
20     exit 0
21 fi
22 
23 # Pass all arguments to the Python module
24 python -m client.file_memory_client "$@"
25 
26 # Exit with the same status code as the Python command
27 exit $?
28
```




```
File: scripts/run_bot.sh
1 #!/bin/bash
2 
3 # 启动bella-issues-bot的帮助脚本
4 # 此脚本简化了命令行参数的输入，便于快速使用
5 # 支持简化的参数选项，调用Python客户端模块
6 
7 show_help() {
8     echo "使用方法: $0 <issue-id> [选项] [需求文件路径]"
9     echo ""
10     echo "必需参数:"
11     echo "  <issue-id>               问题ID（必填）"
12     echo ""
13     echo "选项:"
14     echo "  -m, --model MODEL        同时设置core和data模型名称"
15     echo "  -t, --temperature TEMP          同时设置core和data模型温度"
16     echo "  --cm, --core-model MODEL 单独设置core模型名称"
17     echo "  --dm, --data-model MODEL 单独设置data模型名称"
18     echo "  --ct, --core-temperature TEMP   单独设置core模型温度"
19     echo "  --dt, --data-temperature TEMP   单独设置data模型温度"
20     echo "  -k, --key KEY            设置API密钥"
21     echo "  -h, --help               显示此帮助信息"
22     echo ""
23     echo "示例:"
24     echo "  $0 42 ./requirements.txt             # 使用文件中的需求"
25     echo "  $0 42 -m gpt-4-turbo                # 设置所有模型为gpt-4-turbo"
26     echo "  $0 42 -m gpt-4-turbo -t 0.9         # 设置所有模型为gpt-4-turbo，温度为0.9"
27     echo "  $0 42 --cm gpt-4-turbo --dm gpt-3.5-turbo  # 分别设置不同模型"
28     echo ""
29 }
30 
31 # 检查是否请求帮助
32 if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
33     show_help
34     exit 0
35 fi
36 
37 # 检查是否提供了issue-id参数
38 if [ -z "$1" ] || [[ "$1" == -* ]]; then
39     echo "错误: 必须提供issue-id作为第一个参数"
40     show_help
41     exit 1
42 fi
43 
44 ISSUE_ID=$1
45 shift  # 移除第一个参数，使其他参数可以按顺序处理
46 
47 # 检查最后一个参数是否是一个文件（不以连字符开头）
48 ARGS=("$@")
49 if [ ${#ARGS[@]} -gt 0 ] && [[ ! "${ARGS[-1]}" == -* ]] && [ -f "${ARGS[-1]}" ]; then
50     python -m client.terminal -i $ISSUE_ID --requirement-file "${ARGS[-1]}" "${ARGS[@]:0:${#ARGS[@]}-1}"
51 else
52     python -m client.terminal -i $ISSUE_ID "$@"
53 fi
54
```




```
File: pyproject.toml
1 [tool.poetry]
2 name = "bella-issues-bot"
3 version = "0.1.1"
4 description = "bella-issues-bot 是一个基于人工智能的多功能代码开发助手，具备两种强大的工作模式：个人开发助手模式：在日常开发过程中，作为命令行工具辅助编码，帮助分析代码、生成实现、解决技术难题。GitHub自动化模式：集成到GitHub工作流中，自动监控和处理项目Issues，无需人工干预即可分析需求、提出解决方案并实现代码变更。"
5 authors = ["saizhuolin"]
6 license = "MIT"
7 readme = "README.md"
8 homepage = "https://github.com/szl97/bella-issues-bot"
9 repository = "https://github.com/szl97/bella-issues-bot"
10 documentation = "https://github.com/szl97/bella-issues-bot"
11 packages = [
12     {include = "core"},
13     {include = "client"}
14 ]
15 include = [
16     "system.txt"
17 ]
18 classifiers = [
19   "Development Status :: 4 - Beta",
20   "Topic :: Scientific/Engineering :: Artificial Intelligence",
21 ]
22 
23 [build-system]
24 requires = ["poetry-core>=1.0.0"]
25 build-backend = "poetry.core.masonry.api"
26 
27 [tool.poetry.dependencies]
28 python = ">=3.10,<3.13"
29 gitpython = "^3.1.40"
30 PyGithub = "^2.1.1"
31 langchain = ">=0.3.0,<0.4.0"
32 langchain-openai = ">=0.1.0"
33 langchain-core = ">=0.3.0,<0.4.0"
34 langchain-community = ">=0.3.0,<0.4.0"
35 python-dotenv = "^1.0.0"
36 pydantic = "^2.5.0"
37 openai = "^1.3.5"
38 pytest = "^7.4.0"
39 pathspec = ">=0.9.0"
40 toml = ">=0.10.2"
41 typing-extensions = ">=4.0.0"
42 jinja2 = ">=3.1.0,<4.0.0"
43 colorlog = ">=6.8.0,<7.0.0"
44 colorama = ">=0.4.4"
45 argparse = ">=1.4.0"
46 pyyaml = ">=6.0"
47 
48 [tool.poetry.scripts]
49 bella-issues-bot = 'client.terminal:run_workflow_from_terminal'
50 bella-file-memory = 'client.file_memory_client:main'
51 
52 [tool.ruff]
53 select = ["F", "E", "W", "I001"]
54 show-fixes = false
55 target-version = "py310"
56 task-tags = ["TODO", "FIXME"]
57 extend-ignore = ["E501", "E722"]
58 
59 [tool.black]
60 target-version = ["py310"]
61 
62 [tool.ruff.isort]
63 known-first-party = []
64 known-third-party = []
65 section-order = [
66   "future",
67   "standard-library",
68   "third-party",
69   "first-party",
70   "local-folder",
71 ]
72 combine-as-imports = true
73 split-on-trailing-comma = false
74 lines-between-types = 1
75
```




# 用户需求

为了与GitHub更好地集成，提供一个客户端，为项目文件生成GitHub CICD，分为两个cicd。
    一个是执行memory初始化的，配置为某一个分支push，分支默认为main，提供参数可以修改。
    一个时执行workflowEngine的，配置为提issues和用户issues下回复comment时触发，将issues_id传入，所有环境变量都配置在github cicd的环境变量中带入。
    提issues的时候，用户需求就是提的issues内容。提comment时，需求内容开头为 bella-issues-bot已处理：则代表是bella-issues-bot追加的不需要触发。
    
这是一个客户端工具，供其他项目安装和使用，通过pip install bella-issues-bot安装，用来为其他项目自动生成GitHub工作流配置文件。

注意：在bot模式下，workflowEngineer应该创建临时目录来处理，所以执行的时候不需要project_dir参数。