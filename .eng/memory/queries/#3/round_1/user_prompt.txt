# 项目文件描述


- core/file_memory.py: 文件记忆管理模块，负责存储和更新文件描述信息。FileMemory类通过AI为项目文件生成描述并跟踪变更，支持批量处理和失败重试机制。

- core/git_manager.py: Git管理模块，处理所有Git操作。GitManager类实现了仓库初始化、分支管理、提交、推送等功能，支持认证令牌和远程仓库操作，还集成了GitHub Issue交互能力。

- client/runner.py: 工作流引擎的编程接口模块，提供run_workflow函数简化在Python脚本中调用工作流引擎的过程，处理配置参数和环境变量加载。

- examples/example_workflow.py: 展示如何使用WorkflowEngine处理用户需求的示例代码。初始化工作流引擎处理代码修改需求，演示了配置设置和需求处理流程。作为项目使用方式的参考样例，展示自动决策代码生成或对话流程的能力。

- examples/example_code_generate.py: 代码生成流程示例，展示如何使用CodeEngineer处理代码修改需求。演示了从需求分析到代码生成和提交的完整流程，包含main函数作为入口点。

- core/workflow_engine.py: 工作流引擎模块，作为系统核心协调各组件工作。实现WorkflowEngine类，根据用户需求决策执行代码生成或聊天流程，管理环境初始化和清理，支持客户端和bot两种工作模式。

- client/terminal.py: 工作流引擎的终端入口点，提供命令行接口。实现run_workflow_from_terminal函数解析命令行参数、加载配置并运行工作流引擎。

- client/__init__.py: 客户端包的初始化文件，标识client包用于从终端运行WorkflowEngine。内容简单，仅包含一行包描述文档。


# 文件内容



```
File: core/file_memory.py
1 import json
2 import os
3 import time
4 import datetime
5 from dataclasses import dataclass
6 from typing import Dict, List, Optional, Set, Union
7 
8 from dotenv import load_dotenv
9 from langchain.tools import Tool
10 
11 from core.ai import AIAssistant, AIConfig
12 from core.file_fetcher import FileFetcher
13 from core.git_manager import GitManager, GitConfig
14 from core.log_manager import LogManager
15 from core.log_config import get_logger
16 
17 logger = get_logger(__name__)
18 
19 @dataclass
20 class FileMemoryConfig:
21     """配置文件记忆管理"""
22     project_dir: str
23     git_manager: GitManager
24     ai_config: AIConfig
25     # 可选的LogManager，用于获取上一轮修改信息
26     log_manager: Optional[LogManager] = None
27 
28 
29 class FileDetail:
30     """文件详细信息类"""
31     pass
32 
33 
34 class FileMemory:
35     """管理文件描述的记忆"""
36 
37     MEMORY_DIR = ".eng/memory"
38     FILE_DETAILS_PATH = f"{MEMORY_DIR}/file_details.txt"
39     GIT_ID_FILE = f"{MEMORY_DIR}/git_id"
40     MAX_RETRIES = 3    # 最大重试次数
41     RETRY_DELAY = 30    # 重试延迟（秒）
42     # 每批次最大行数和字符数限制
43     MAX_LINES_PER_BATCH = 10000  # 最大行数
44     MAX_CHARS_PER_BATCH = 100000  # 最大字符数，约为 100KB
45     MAX_FILES_PER_BATCH = 100  # 每批次最多处理的文件数
46 
47     def __init__(self, config: FileMemoryConfig):
48         self.config = config
49         self.memory_path = os.path.join(config.project_dir, self.FILE_DETAILS_PATH)
50         self.git_id_path = os.path.join(config.project_dir, self.GIT_ID_FILE)
51 
52         # 保存LogManager引用
53         self.log_manager = config.log_manager
54 
55         # 初始化 AI 助手
56         self.ai_assistant = AIAssistant(config=self.config.ai_config, tools=[self._create_batch_description_tool()])
57 
58         # 初始化 Git 管理器
59         self.git_manager = self.config.git_manager
60 
61         # 确保内存目录存在
62         os.makedirs(os.path.dirname(self.memory_path), exist_ok=True)
63 
64     def _ensure_directories(self):
65         """确保必要的目录存在"""
66         memory_dir = os.path.join(self.config.project_dir, self.MEMORY_DIR)
67         os.makedirs(memory_dir, exist_ok=True)
68 
69     def _get_failed_files_path(self) -> str:
70         """获取失败文件记录的路径"""
71         return os.path.join(self.config.project_dir, self.MEMORY_DIR, "failed_files.json")
72 
73     def _read_failed_files(self) -> List[str]:
74         """读取处理失败的文件列表"""
75         failed_files_path = self._get_failed_files_path()
76         if os.path.exists(failed_files_path):
77             try:
78                 with open(failed_files_path, 'r', encoding='utf-8') as f:
79                     return json.load(f)
80             except Exception as e:
81                 logger.error(f"读取失败文件列表出错: {str(e)}")
82         return []
83 
84     def _write_failed_files(self, failed_files: List[str]) -> None:
85         """写入处理失败的文件列表"""
86         failed_files_path = self._get_failed_files_path()
87         try:
88             with open(failed_files_path, 'w', encoding='utf-8') as f:
89                 json.dump(failed_files, f, ensure_ascii=False, indent=2)
90         except Exception as e:
91             logger.error(f"写入失败文件列表出错: {str(e)}")
92 
93     def _create_batch_description_tool(self) -> Tool:
94         """创建批量生成文件描述的工具"""
95         from langchain.tools import Tool
96         
97         def process_file_descriptions(file_descriptions: str) -> Dict[str, str]:
98             """
99             处理文件描述列表
100             
101             Args:
102                 file_descriptions: JSON格式的文件描述列表，格式为 [{"fileName": "path/to/file.py", "desc": "文件描述"}]
103                 
104             Returns:
105                 Dict[str, str]: 文件路径到描述的映射
106             """
107             try:
108                 descriptions = {}
109                 file_list = json.loads(file_descriptions)
110                 
111                 if not isinstance(file_list, list):
112                     logger.error("错误：输入必须是一个列表")
113                     return descriptions
114                 
115                 # 处理结果
116                 for item in file_list:
117                     if isinstance(item, dict) and "fileName" in item and "desc" in item:
118                         descriptions[item["fileName"]] = item["desc"]
119                     else:
120                         logger.warning(f"跳过无效的文件描述项: {item}")
121                 
122                 logger.info(f"成功处理了 {len(descriptions)} 个文件描述")
123                 return descriptions
124             except json.JSONDecodeError:
125                 logger.error("错误：输入不是有效的 JSON 格式")
126                 return {}
127             except Exception as e:
128                 logger.error(f"处理文件描述时出错: {str(e)}")
129                 return {}
130         
131         return Tool(
132             name="process_file_descriptions",
133             description="处理文件描述列表，输入必须是JSON格式的列表，每个元素包含fileName和desc字段",
134             func=process_file_descriptions,
135             return_direct=True
136         )
137 
138     def _generate_batch_file_descriptions(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
139         """
140         批量生成文件描述
141         
142         Args:
143             files_with_content: 包含文件路径和内容的列表，格式为 [{"filepath": "path/to/file.py", "content": "..."}]
144             
145         Returns:
146             Dict[str, str]: 文件路径到描述的映射
147         """
148         # 构建提示词
149         files_text = ""
150         for i, file_info in enumerate(files_with_content):
151             files_text += f"\n--- 文件 {i+1}: {file_info['filepath']} ---\n{file_info['content']}\n"
152         
153         prompt = f"""
154 请分析以下多个代码文件，并为每个文件生成一个简短的中文描述（每个不超过100字）。
155 描述应该包含：
156 1. 文件的主要功能
157 2. 包含的关键类或函数
158 3. 与其他文件的主要交互（如果明显的话）
159 
160 {files_text}
161 
162 请使用process_file_descriptions工具返回结果，输入必须是一个JSON格式的列表，每个元素包含fileName和desc字段。
163 例如：
164 [
165   {{"fileName": "path/to/file1.py", "desc": "这个文件实现了..."}},
166   {{"fileName": "path/to/file2.py", "desc": "这个文件定义了..."}}
167 ]
168 
169 请确保每个文件都有对应的描述，并且描述准确反映文件的功能和内容。
170 """
171         
172         # 尝试生成描述，最多重试MAX_RETRIES次
173         descriptions = {}
174         failed_files = []
175         file_paths = [file_info["filepath"] for file_info in files_with_content]
176         
177         for attempt in range(self.MAX_RETRIES):
178             try:
179                 logger.info(f"尝试批量生成文件描述（第{attempt+1}次尝试）")
180                 
181                 # 使用工具生成描述
182                 descriptions = self.ai_assistant.generate_response(prompt, use_tools=True)
183                 
184                 # 如果返回的不是字典，可能是字符串响应
185                 if not isinstance(descriptions, dict):
186                     logger.error(f"工具返回了非预期的结果类型: {type(descriptions)}")
187                     descriptions = {}
188                 
189                 # 检查是否所有文件都有描述
190                 missing_files = [
191                     file_path for file_path in file_paths
192                     if file_path not in descriptions
193                 ]
194                 
195                 if missing_files:
196                     failed_files.extend(missing_files)
197                     logger.warning(f"以下文件未能生成描述: {missing_files}")
198                 
199                 # 如果有成功处理的文件，则返回结果
200                 if descriptions:
201                     return descriptions
202             
203             except Exception as e:
204                 logger.error(f"批量生成文件描述失败（第{attempt+1}次尝试）: {str(e)}")
205             
206             # 如果不是最后一次尝试，则等待后重试
207             if attempt < self.MAX_RETRIES - 1:
208                 logger.info(f"等待 {self.RETRY_DELAY} 秒后重试...")
209                 time.sleep(self.RETRY_DELAY)
210         
211         # 所有尝试都失败，记录失败的文件
212         self._update_failed_files(file_paths)
213         
214         # 返回空结果
215         return descriptions
216 
217     def _update_failed_files(self, new_failed_files: List[str]) -> None:
218         """更新失败文件列表"""
219         if not new_failed_files:
220             return
221             
222         # 读取现有失败文件列表
223         existing_failed_files = self._read_failed_files()
224         
225         # 合并并去重
226         all_failed_files = list(set(existing_failed_files + new_failed_files))
227         
228         # 写入更新后的列表
229         self._write_failed_files(all_failed_files)
230         logger.info(f"更新了失败文件列表，共 {len(all_failed_files)} 个文件")
231 
232     def process_failed_files(self) -> Dict[str, str]:
233         """处理之前失败的文件"""
234         failed_files = self._read_failed_files()
235         if not failed_files:
236             logger.info("没有需要处理的失败文件")
237             return {}
238             
239         logger.info(f"开始处理 {len(failed_files)} 个失败文件")
240         
241         # 准备文件内容
242         files_with_content = []
243         for filepath in failed_files:
244             content = self._get_file_content(filepath)
245             if content.strip():  # 跳过空文件
246                 files_with_content.append({"filepath": filepath, "content": content})
247         
248         # 按批次处理文件
249         descriptions = self._process_files_in_batches(files_with_content)
250         
251         # 更新失败文件列表
252         if descriptions:
253             # 找出成功处理的文件
254             processed_files = list(descriptions.keys())
255             # 更新失败文件列表
256             new_failed_files = [f for f in failed_files if f not in processed_files]
257             self._write_failed_files(new_failed_files)
258             
259             logger.info(f"成功处理了 {len(processed_files)} 个之前失败的文件，还有 {len(new_failed_files)} 个文件失败")
260         
261         return descriptions
262 
263 
264     def _get_file_content(self, filepath: str) -> str:
265         """获取文件内容"""
266         try:
267             full_path = os.path.join(self.config.project_dir, filepath)
268             with open(full_path, "r", encoding="utf-8") as f:
269                 return f.read()
270         except Exception as e:
271             logger.error(f"读取文件 {filepath} 失败: {str(e)}")
272             return ""
273 
274     def _process_files_in_batches(self, files_with_content: List[Dict[str, str]]) -> Dict[str, str]:
275         """将文件分批处理"""
276         all_descriptions = {}
277         current_batch = []
278         current_lines = 0
279         current_size = 0
280 
281         
282         for file_info in files_with_content:
283             content = file_info["content"]
284             lines = len(content.splitlines())
285             chars = len(content)
286             
287             if lines == 0:
288                 continue
289                 
290             # 检查是否需要开始新批次
291             # 如果当前批次已满或添加此文件会超出限制，则处理当前批次并开始新批次
292             if (current_batch and (
293                 len(current_batch) >= self.MAX_FILES_PER_BATCH or
294                 current_lines + lines > self.MAX_LINES_PER_BATCH or
295                 current_size + chars > self.MAX_CHARS_PER_BATCH
296             )):
297                 # 处理当前批次
298                 logger.info(f"处理批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
299                 batch_descriptions = self._generate_batch_file_descriptions(current_batch)
300                 all_descriptions.update(batch_descriptions)
301                 
302                 # 重置批次
303                 current_batch = [file_info]
304                 current_lines = lines
305                 current_size = chars
306             else:
307                 current_batch.append(file_info)
308                 current_lines += lines
309                 current_size += chars
310         
311         # 处理最后一个批次
312         if current_batch:
313             logger.info(f"处理最后一个批次: {len(current_batch)} 个文件，共 {current_lines} 行，{current_size} 字符")
314             batch_descriptions = self._generate_batch_file_descriptions(current_batch)
315             all_descriptions.update(batch_descriptions)
316         
317         return all_descriptions
318 
319     def _process_files_chunk(self, files: List[str]) -> Dict[str, str]:
320         """处理一组文件，生成描述"""
321         # 准备文件内容
322         files_with_content = []
323         for filepath in files:
324             content = self._get_file_content(filepath)
325             if content.strip():  # 跳过空文件
326                 files_with_content.append({"filepath": filepath, "content": content})
327         
328         # 按批次处理文件
329         return self._process_files_in_batches(files_with_content)
330 
331     def _read_git_id(self) -> str:
332         """读取保存的 Git ID"""
333         if not os.path.exists(self.git_id_path):
334             return ""
335         with open(self.git_id_path, "r") as f:
336             return f.read().strip()
337 
338     def _write_git_id(self, git_id: str) -> None:
339         """写入当前 Git ID"""
340         with open(self.git_id_path, "w") as f:
341             f.write(git_id)
342 
343     def _read_file_details(self) -> Dict[str, str]:
344         """读取文件描述信息"""
345         if not os.path.exists(self.memory_path):
346             return {}
347 
348         details = {}
349         with open(self.memory_path, "r", encoding="utf-8") as f:
350             for line in f:
351                 if ":" in line:
352                     filename, description = line.strip().split(":", 1)
353                     details[filename] = description
354         return details
355 
356     def _write_file_details(self, details: Dict[str, str]) -> None:
357         """写入文件描述信息"""
358         with open(self.memory_path, "w", encoding="utf-8") as f:
359             for filename, description in sorted(details.items()):
360                 f.write(f"{filename}:{description}\n")
361 
362     def update_file_details(self) -> None:
363         """更新文件描述信息"""
364         # 获取所有文件
365         all_files = set(FileFetcher.get_all_files_without_ignore(self.config.project_dir))
366         
367         # 读取现有描述
368         existing_details = self._read_file_details()
369         
370         files_to_process = []
371         
372         # 如果有LogManager，使用它获取上一轮修改的文件
373         if self.log_manager:
374             # 获取上一轮修改的文件
375             log_modified_files = self._get_last_round_modified_files()
376             
377             # 只处理LogManager中标记为修改的文件
378             files_to_process = list(log_modified_files & all_files)
379             
380             # 删除不存在的文件的描述
381             existing_details = {
382                 k: v for k, v in existing_details.items() if k in all_files
383             }
384             
385             logger.info(f"使用LogManager方式更新文件描述，处理{len(files_to_process)}个修改的文件")
386         else:
387             # 如果没有LogManager，回退到Git方式
388             current_git_id = self.git_manager.get_current_commit_id()
389             saved_git_id = self._read_git_id()
390             files_to_process = self._get_changed_files_git(all_files, existing_details, current_git_id, saved_git_id)
391             logger.info(f"使用Git方式更新文件描述，处理{len(files_to_process)}个文件")
392 
393         # 处理需要更新的文件
394         if files_to_process:
395             new_descriptions = self._process_files_chunk(files_to_process)
396             existing_details.update(new_descriptions)
397 
398         # 保存结果
399         self._write_file_details(existing_details)
400         if not self.log_manager:
401             # 只有使用Git方式时才更新Git ID
402             current_git_id = self.git_manager.get_current_commit_id()
403             self._write_git_id(current_git_id)
404 
405     def _get_last_round_modified_files(self) -> set:
406         """
407         从LogManager获取上一轮修改的文件列表
408         
409         Returns:
410             set: 上一轮修改的文件路径集合
411         """
412         if not self.log_manager:
413             logger.info("未提供LogManager，无法获取上一轮修改的文件")
414             return set()
415         
416         try:
417             # 获取当前轮次
418             current_round = self.log_manager.get_current_round()
419             
420             # 获取上一轮的日志条目
421             if current_round > 1:
422                 prev_round = current_round - 1
423                 log_entry = self.log_manager.get_issue_round_log_entry(prev_round, include_diff=True)
424                 
425                 if log_entry and log_entry.modified_files:
426                     # 从diff_info中提取文件路径
427                     modified_files = set()
428                     for diff_info in log_entry.modified_files:
429                         if diff_info.file_name and diff_info.is_create:
430                             modified_files.add(diff_info.file_name)
431                     
432                     logger.info(f"从LogManager获取到上一轮({prev_round})修改的文件: {len(modified_files)}个")
433                     return modified_files
434             return set()
435         except Exception as e:
436             logger.error(f"获取上一轮修改的文件失败: {str(e)}")
437             return set()
438 
439     def _get_changed_files_git(self, all_files: Set[str], existing_details: Dict[str, str], 
440                              current_git_id: str, saved_git_id: Optional[str]) -> List[str]:
441         """使用Git方式获取需要处理的文件列表"""
442         if saved_git_id:
443             # 获取自上次运行以来修改的文件
444             changed_files = set(
445                 self.git_manager.get_changed_files(saved_git_id, current_git_id)
446             ) & all_files
447             
448             logger.info(f"从Git获取到变更文件: {len(changed_files)}个")
449             
450             new_files = all_files - set(existing_details.keys())
451             logger.info(f"检测到新文件: {len(new_files)}个")
452             
453             return list(changed_files | new_files)
454         else:
455             # 首次运行，处理所有文件
456             return list(all_files)
457 
458     @classmethod
459     def get_file_descriptions(cls, project_dir: str) -> Dict[str, str]:
460         """获取文件描述的静态方法"""
461         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
462 
463         if not os.path.exists(memory_path):
464             return {}
465 
466         try:
467             descriptions = {}
468             with open(memory_path, "r", encoding="utf-8") as f:
469                 for line in f:
470                     if ":" in line:
471                         filename, description = line.strip().split(":", 1)
472                         descriptions[filename] = description
473             return descriptions
474         except Exception as e:
475             logger.error(f"读取文件描述失败: {str(e)}")
476             return {}
477 
478     @classmethod
479     def get_selected_file_descriptions(cls, project_dir: str, files: List[str]) -> Dict[str, str]:
480         """获取文件描述的静态方法"""
481         memory_path = os.path.join(project_dir, cls.FILE_DETAILS_PATH)
482 
483         if not os.path.exists(memory_path):
484             return {}
485         try:
486             descriptions = {}
487             with open(memory_path, "r", encoding="utf-8") as f:
488                 for line in f:
489                     if ":" in line:
490                         filename, description = line.strip().split(":", 1)
491                         if filename in files:
492                             descriptions[filename] = description
493             return descriptions
494         except Exception as e:
495             logger.error(f"读取文件描述失败: {str(e)}")
496             return {}
497 
498 if __name__ == "__main__":
499     load_dotenv()
500     project_dir = "../."
501     memory = FileMemory(
502         FileMemoryConfig(
503             ai_config=AIConfig(temperature=1, model_name="claude-3.7-sonnet"),
504             git_manager=GitManager(config=GitConfig(repo_path=project_dir)),
505             log_manager=None
506         )
507     )
508 
509     memory.update_file_details()
510
```




```
File: core/git_manager.py
1 import os
2 import shutil
3 from dataclasses import dataclass
4 from typing import Optional, List
5 from urllib.parse import urlparse, urlunparse
6 
7 import git
8 
9 from core.log_config import get_logger
10 
11 logger = get_logger(__name__)
12 
13 
14 @dataclass
15 class GitConfig:
16     """Git configuration parameters"""
17 
18     repo_path: str
19     remote_name: str = "origin"
20     default_branch: str = "main"
21     remote_url: Optional[str] = os.getenv("GIT_REMOTE")
22     auth_token: Optional[str] = os.getenv("GITHUB_TOKEN")
23 
24 
25 class GitManager:
26     """Manages git operations including push, pull, branch creation and switching"""
27 
28     def __init__(self, config: GitConfig):
29         """Initialize GitManager with configuration"""
30         self.config = config
31         self.repo = None
32         self._ensure_repo()
33 
34     def _ensure_repo(self) -> None:
35         """Ensure git repository exists and is properly initialized"""
36         if not os.path.exists(self.config.repo_path):
37             if self.config.remote_url:
38                 self.clone()
39             else:
40                 raise ValueError(
41                     f"Repository path does not exist: {self.config.repo_path}"
42                 )
43         else:
44             try:
45                 self.repo = git.Repo(self.config.repo_path)
46                 # Set auth token for remote operations if provided
47                 if self.config.auth_token and self.config.remote_url:
48                     self._set_remote_with_auth()
49             except git.InvalidGitRepositoryError:
50                 raise ValueError(
51                     f"Invalid git repository at: {self.config.repo_path}"
52                 )
53 
54 
55     def _get_url_with_token(self, url: str) -> str:
56         """
57         Insert authentication token into git URL
58 
59         Args:
60             url: Original git URL
61 
62         Returns:
63             URL with authentication token
64         """
65         if not self.config.auth_token:
66             return url
67 
68         parsed = urlparse(url)
69 
70         # Handle different URL formats
71         if parsed.scheme in ["http", "https"]:
72             netloc = f"{self.config.auth_token}@{parsed.netloc}"
73             return urlunparse(
74                 (
75                     parsed.scheme,
76                     netloc,
77                     parsed.path,
78                     parsed.params,
79                     parsed.query,
80                     parsed.fragment,
81                 )
82             )
83         elif "@" in url and ":" in url and url.startswith("git@"):  # Handle SSH format: git@github.com:username/repo.git
84             return url  # Don't modify SSH URLs
85         else:
86             return url  # Return original if format is not recognized
87 
88     def _set_remote_with_auth(self) -> None:
89         """Configure remote with authentication token"""
90         if not self.repo or not self.config.auth_token or not self.config.remote_url:
91             return
92 
93         try:
94             # Get current remotes
95             remotes = list(self.repo.remotes)
96             remote_exists = any(
97                 remote.name == self.config.remote_name for remote in remotes
98             )
99 
100             # Prepare URL with token
101             url_with_token = self._get_url_with_token(self.config.remote_url)
102 
103             # Set or update remote
104             if remote_exists:
105                 self.repo.git.remote("set-url", self.config.remote_name, url_with_token)
106             else:
107                 self.repo.git.remote("add", self.config.remote_name, url_with_token)
108 
109             logger.info(
110                 f"Configured remote '{self.config.remote_name}' with authentication"
111             )
112         except git.GitCommandError as e:
113             logger.error(f"Failed to configure remote with authentication: {str(e)}")
114             raise
115 
116     def clone(self) -> None:
117         """
118         Clone the repository specified in config
119 
120         Raises:
121             ValueError: If remote_url is not set in config
122             git.GitCommandError: If clone operation fails
123         """
124         if not self.config.remote_url:
125             raise ValueError("Remote URL must be set to clone a repository")
126 
127         self._clone_repo(branch=self.config.default_branch)
128 
129     def _clone_repo(self, branch: Optional[str] = None) -> None:
130         """
131         Internal method to perform the clone operation
132 
133         Args:
134             branch: Branch to checkout after cloning
135         """
136         try:
137             # Prepare parent directory if it doesn't exist
138             parent_dir = os.path.dirname(self.config.repo_path)
139             if parent_dir and not os.path.exists(parent_dir):
140                 os.makedirs(parent_dir)
141 
142             # Remove target directory if it exists
143             if os.path.exists(self.config.repo_path):
144                 shutil.rmtree(self.config.repo_path)
145 
146             # Prepare URL with token if provided
147             clone_url = self._get_url_with_token(self.config.remote_url)
148 
149             # Clone options
150             clone_args = {
151                 "url": clone_url,
152                 "to_path": self.config.repo_path,
153             }
154 
155             # Add branch if specified
156             if branch:
157                 clone_args["branch"] = branch
158 
159             # Clone the repository
160             self.repo = git.Repo.clone_from(**clone_args)
161 
162             logger.info(f"Successfully cloned repository to {self.config.repo_path}")
163 
164             # Configure remote with auth token if provided
165             if self.config.auth_token:
166                 self._set_remote_with_auth()
167 
168         except git.GitCommandError as e:
169             logger.error(f"Failed to clone repository: {str(e)}")
170             # Clean up if clone failed
171             if os.path.exists(self.config.repo_path):
172                 shutil.rmtree(self.config.repo_path)
173             raise
174 
175     def pull(self, branch: Optional[str] = None) -> None:
176         """
177         Pull changes from remote repository
178 
179         Args:
180             branch: Branch to pull from. If None, pulls current branch
181         """
182         try:
183             if branch:
184                 self.repo.git.pull(self.config.remote_name, branch)
185             else:
186                 self.repo.git.pull()
187             logger.info(
188                 f"Successfully pulled changes from {branch or 'current branch'}"
189             )
190         except git.GitCommandError as e:
191             logger.error(f"Failed to pull changes: {str(e)}")
192             raise
193 
194     def push(
195         self,
196         branch: Optional[str] = None,
197         force: bool = False,
198         set_upstream: bool = True,
199     ) -> None:
200         """
201         Push changes to remote repository
202 
203         Args:
204             branch: Branch to push. If None, pushes current branch
205             force: Whether to force push
206             set_upstream: Whether to set upstream branch if it doesn't exist
207         """
208         try:
209             # 确保远程 URL 包含认证令牌
210             if self.config.auth_token:
211                 self._set_remote_with_auth()
212 
213             # 如果没有指定分支，获取当前分支
214             current_branch = branch or self.get_current_branch()
215 
216             # 执行推送操作
217             if force:
218                 if set_upstream:
219                     self.repo.git.push(
220                         "-f", "--set-upstream", self.config.remote_name, current_branch
221                     )
222                 else:
223                     if branch:
224                         self.repo.git.push("-f", self.config.remote_name, branch)
225                     else:
226                         self.repo.git.push("-f")
227             else:
228                 if set_upstream:
229                     self.repo.git.push(
230                         "--set-upstream", self.config.remote_name, current_branch
231                     )
232                 else:
233                     if branch:
234                         self.repo.git.push(self.config.remote_name, branch)
235                     else:
236                         self.repo.git.push()
237 
238             logger.info(f"Successfully pushed changes to {current_branch}")
239         except git.GitCommandError as e:
240             logger.error(f"Failed to push changes: {str(e)}")
241             raise
242 
243     def create_branch(
244         self, branch_name: str, start_point: Optional[str] = None
245     ) -> None:
246         """
247         Create a new branch
248 
249         Args:
250             branch_name: Name of the new branch
251             start_point: Branch/commit to create branch from. If None, uses current HEAD
252         """
253         try:
254             if start_point:
255                 self.repo.git.branch(branch_name, start_point)
256             else:
257                 self.repo.git.branch(branch_name)
258             logger.info(f"Successfully created branch: {branch_name}")
259         except git.GitCommandError as e:
260             logger.error(f"Failed to create branch: {str(e)}")
261             raise
262 
263     def switch_branch(self, branch_name: str, create: bool = False) -> None:
264         """
265         Switch to specified branch
266 
267         Args:
268             branch_name: Name of the branch to switch to
269             create: Create branch if it doesn't exist
270         """
271         try:
272             if create:
273                 try:
274                     self.repo.git.checkout("-b", branch_name)
275                 except:
276                     self.repo.git.checkout(branch_name)
277             else:
278                 self.repo.git.checkout(branch_name)
279             logger.info(f"Successfully switched to branch: {branch_name}")
280         except git.GitCommandError as e:
281             logger.error(f"Failed to switch branch: {str(e)}")
282             raise
283 
284     def delete_branch(self, branch_name: str, force: bool = False) -> None:
285         """
286         Delete specified branch
287 
288         Args:
289             branch_name: Name of the branch to delete
290             force: Force delete even if branch not fully merged
291         """
292         try:
293             if force:
294                 self.repo.git.branch("-D", branch_name)
295             else:
296                 self.repo.git.branch("-d", branch_name)
297             logger.info(f"Successfully deleted branch: {branch_name}")
298         except git.GitCommandError as e:
299             logger.error(f"Failed to delete branch: {str(e)}")
300             raise
301 
302     def get_current_branch(self) -> str:
303         """Get name of current branch"""
304         return self.repo.active_branch.name
305 
306     def list_branches(self, remote: bool = False) -> List[str]:
307         """
308         List all branches
309 
310         Args:
311             remote: Whether to list remote branches instead of local
312 
313         Returns:
314             List of branch names
315         """
316         if remote:
317             return [ref.name for ref in self.repo.remote().refs]
318         return [branch.name for branch in self.repo.heads]
319 
320     def get_current_commit_id(self) -> str:
321         """获取当前提交的 ID"""
322         try:
323             return self.repo.head.commit.hexsha
324         except Exception as e:
325             logger.error(f"获取当前提交 ID 失败: {str(e)}")
326             return ""
327 
328     def get_changed_files(self, old_commit: str, new_commit: str) -> List[str]:
329         """
330         获取两个提交之间变更的文件列表
331 
332         Args:
333             old_commit: 旧提交的 ID
334             new_commit: 新提交的 ID
335 
336         Returns:
337             变更的文件路径列表
338         """
339         try:
340             # 获取提交对象
341             old = self.repo.commit(old_commit)
342             new = self.repo.commit(new_commit)
343 
344             # 获取差异
345             diff_index = old.diff(new)
346 
347             # 收集所有变更的文件
348             changed_files = set()
349 
350             # 添加修改的文件
351             for diff in diff_index.iter_change_type("M"):
352                 if not self.is_ignore(diff.a_path):
353                     changed_files.add(diff.a_path)
354 
355             # 添加增加的文件
356             for diff in diff_index.iter_change_type("A"):
357                 if not self.is_ignore(diff.b_path):
358                     changed_files.add(diff.b_path)
359 
360             # 添加删除的文件
361             for diff in diff_index.iter_change_type("D"):
362                 if not self.is_ignore(diff.b_path):
363                     changed_files.add(diff.a_path)
364 
365             return list(changed_files)
366         except Exception as e:
367             logger.error(f"获取变更文件列表失败: {str(e)}")
368             return []
369 
370     def is_ignore(self, path: str) -> bool:
371         # 检查文件名是否以点开头
372         file_name = os.path.basename(path)
373         if file_name.startswith("."):
374             return True
375         # 检查路径中是否包含以点开头的目录
376         path_parts = path.split(os.path.sep)
377         for part in path_parts:
378             # 跳过空字符串（可能出现在路径开头）
379             if not part:
380                 continue
381             # 如果目录名以点开头，则忽略
382             if part.startswith("."):
383                 return True
384 
385         # 如果不满足任何忽略条件，则不忽略
386         return False
387 
388     def delete_local_repository(self, remove_git_config: bool = False) -> None:
389         """
390         删除本地代码仓库和可选的全局 git 配置
391 
392         Args:
393             remove_git_config: 是否同时删除与此仓库相关的全局 git 配置
394 
395         Raises:
396             ValueError: 如果仓库路径不存在
397             OSError: 如果删除操作失败
398         """
399         if not os.path.exists(self.config.repo_path):
400             logger.warning(f"仓库路径不存在，无需删除: {self.config.repo_path}")
401             return
402 
403         try:
404             # 关闭仓库连接以释放文件锁
405             if self.repo:
406                 self.repo.close()
407                 self.repo = None
408 
409             # 删除本地仓库目录
410             shutil.rmtree(self.config.repo_path)
411             logger.info(f"成功删除本地仓库: {self.config.repo_path}")
412 
413             # 可选：删除全局 git 配置中与此仓库相关的条目
414             if remove_git_config:
415                 self._remove_git_config()
416 
417         except (OSError, shutil.Error) as e:
418             logger.error(f"删除本地仓库失败: {str(e)}")
419             raise
420 
421     def _remove_git_config(self) -> None:
422         """
423         从全局 git 配置中删除与当前仓库相关的配置
424 
425         这包括：
426         - 与远程仓库 URL 相关的凭证
427         - 特定于此仓库的用户配置
428         """
429         try:
430             # 获取仓库的规范路径
431             repo_path = os.path.abspath(self.config.repo_path)
432             repo_name = os.path.basename(repo_path)
433 
434             # 尝试从 git 配置中删除与此仓库相关的条目
435             if self.config.remote_url:
436                 # 解析远程 URL 以获取主机名
437                 parsed = urlparse(self.config.remote_url)
438                 if parsed.netloc:
439                     # 尝试删除凭证
440                     try:
441                         git.cmd.Git().execute(
442                             ["git", "credential", "reject"],
443                             input=f"url={self.config.remote_url}\n\n",
444                         )
445                         logger.info(f"已尝试从凭证存储中删除 {parsed.netloc} 的凭证")
446                     except git.GitCommandError:
447                         logger.debug("凭证删除操作未成功，可能没有存储凭证")
448 
449             # 尝试删除仓库特定的配置（如果有）
450             try:
451                 git.cmd.Git().execute(
452                     [
453                         "git",
454                         "config",
455                         "--global",
456                         "--remove-section",
457                         f"remote.{repo_name}",
458                     ]
459                 )
460                 logger.info(f"已删除全局 git 配置中的 remote.{repo_name} 部分")
461             except git.GitCommandError:
462                 logger.debug(f"全局配置中没有 remote.{repo_name} 部分")
463 
464             logger.info("已完成 git 配置清理")
465 
466         except Exception as e:
467             logger.warning(f"清理 git 配置时出错: {str(e)}")
468             # 不抛出异常，因为这是次要操作
469 
470     def add_issue_comment(self, issue_number: int, comment_text: str) -> bool:
471         """
472         在 GitHub 仓库的指定 Issue 下添加评论
473 
474         Args:
475             issue_number: Issue 编号
476             comment_text: 评论内容
477 
478         Returns:
479             bool: 操作是否成功
480 
481         Raises:
482             ValueError: 如果未配置认证令牌或远程 URL
483             Exception: 如果添加评论过程中发生其他错误
484         """
485         try:
486             # 检查必要的配置
487             if not self.config.auth_token:
488                 raise ValueError("添加 Issue 评论需要认证令牌 (auth_token)")
489 
490             if not self.config.remote_url:
491                 raise ValueError("添加 Issue 评论需要远程仓库 URL (remote_url)")
492 
493             # 导入 PyGithub
494             try:
495                 from github import Github
496             except ImportError:
497                 raise ImportError("添加 Issue 评论需要安装 PyGithub 库: pip install PyGithub")
498 
499             # 解析仓库所有者和名称
500             parsed_url = urlparse(self.config.remote_url)
501             path_parts = parsed_url.path.strip("/").split("/")
502 
503             if len(path_parts) < 2 or not all(path_parts[:2]):
504                 raise ValueError(f"无法从 URL 解析仓库所有者和名称: {self.config.remote_url}")
505 
506             owner = path_parts[0]
507             repo_name = path_parts[1]
508             if repo_name.endswith(".git"):
509                 repo_name = repo_name[:-4]  # 移除 .git 后缀
510 
511             # 初始化 GitHub 客户端
512             g = Github(self.config.auth_token)
513 
514             # 获取仓库和 Issue
515             repo = g.get_repo(f"{owner}/{repo_name}")
516             issue = repo.get_issue(issue_number)
517 
518             # 添加评论
519             comment = issue.create_comment(comment_text)
520 
521             logger.info(f"成功在 Issue #{issue_number} 下添加评论 (ID: {comment.id})")
522             return True
523 
524         except Exception as e:
525             logger.error(f"添加 Issue 评论失败: {str(e)}")
526             raise
527 
528     def commit(
529         self, message: str, add_all: bool = True, files: Optional[List[str]] = None
530     ) -> str:
531         """
532         创建一个新的提交
533 
534         Args:
535             message: 提交信息
536             add_all: 是否添加所有变更的文件，默认为 True
537             files: 要添加的特定文件列表，如果 add_all 为 True 则忽略此参数
538 
539         Returns:
540             str: 新提交的 SHA 哈希值
541 
542         Raises:
543             git.GitCommandError: 如果 Git 操作失败
544         """
545         try:
546             # 添加文件到暂存区
547             if add_all:
548                 self.repo.git.add(A=True)
549             elif files:
550                 for file in files:
551                     self.repo.git.add(file)
552 
553             # 创建提交
554             commit = self.repo.index.commit(message)
555             logger.info(f"成功创建提交: {commit.hexsha[:7]} - {message}")
556 
557             return commit.hexsha
558         except git.GitCommandError as e:
559             logger.error(f"创建提交失败: {str(e)}")
560             raise
561 
562     def reset_to(self, target_branch: str) -> bool:
563         """
564         将当前分支重置到远程目标分支的状态
565 
566         Args:
567             target_branch: 目标分支名称
568 
569         Returns:
570             bool: 操作是否成功
571         """
572         try:
573             # 获取远程分支
574             remote_name = self.config.remote_name
575             remote_branches = self.list_branches(remote=True)
576             remote_target = f"{remote_name}/{target_branch}"
577             # 检查目标分支是否存在于远端
578             if remote_target not in remote_branches:
579                 logger.warning(f"目标分支 {remote_target} 不存在于远端")
580                 return False
581 
582             # 切换到目标分支，如果不存在则创建
583             logger.info(f"切换到分支: {target_branch}")
584             self.switch_branch(target_branch, create=True)
585 
586             # 拉取最新代码
587             logger.info(f"拉取远程分支: {remote_target} 的最新代码")
588             self.pull(target_branch)
589 
590             # 强制重置到远程分支状态
591             logger.info(f"重置到远程分支: {remote_target}")
592             self.repo.git.reset(f"{remote_target}", hard=True)
593 
594             logger.info(f"成功重置到版本: {target_branch}")
595             return True
596         except git.GitCommandError as e:
597             logger.error(f"重置到分支 {target_branch} 失败: {str(e)}")
598             return False
599         except Exception as e:
600             logger.error(f"重置过程中发生未知错误: {str(e)}")
601             return False
602 
603     def reset_to_issue_branch(self, issue_id: int) -> str:
604         """
605         拉取指定issue对应的最新分支并切换到该分支
606         如果该issue还未创建过分支，则切换到默认分支
607 
608         Args:
609             issue_id: Issue编号
610 
611         Returns:
612             str: 成功切换到的分支名称
613 
614         Raises:
615             git.GitCommandError: 如果Git操作失败
616         """
617         try:
618             # 确保远程仓库信息是最新的
619             self.repo.git.fetch(self.config.remote_name)
620             logger.info(f"成功获取远程仓库信息")
621             
622             # 获取所有远程分支
623             remote_branches = self.repo.git.branch("-r").splitlines()
624             remote_branches = [branch.strip() for branch in remote_branches]
625             
626             # 查找与指定issue相关的分支
627             issue_branch_name = f"bella-issues-bot-{issue_id}"
628             remote_issue_branch = f"{self.config.remote_name}/{issue_branch_name}"
629             
630             branch_exists = False
631             for branch in remote_branches:
632                 if remote_issue_branch in branch:
633                     branch_exists = True
634                     break
635                     
636             if branch_exists:
637                 # 切换到issue分支
638                 self.switch_branch(issue_branch_name, create=True)
639                 self.pull()
640                 logger.info(f"成功切换到issue #{issue_id}的分支: {issue_branch_name}")
641             else:
642                 # 如果没有找到相关分支，切换到默认分支
643                 self.switch_branch(self.config.default_branch)
644                 self.pull()
645                 logger.info(f"重置到远程分支: {self.config.remote_name}/{self.config.default_branch}")
646                 self.repo.git.reset(f"{self.config.remote_name}/{self.config.default_branch}", hard=True)
647                 logger.info(f"未找到issue #{issue_id}的分支，已切换到默认分支: {self.config.default_branch}")
648             
649             return issue_branch_name
650         except git.GitCommandError as e:
651             logger.error(f"切换到issue分支时出错: {str(e)}")
652             raise
653
```




```
File: client/runner.py
1 """
2 Programmatic API for running the WorkflowEngine.
3 Provides a simplified interface for use in Python scripts.
4 """
5 
6 import os
7 from typing import Optional, Dict, Any, Union
8 
9 from dotenv import load_dotenv
10 
11 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
12 
13 
14 def run_workflow(
15     issue_id: int,
16     requirement: str,
17     project_dir: Optional[str] = None,
18     model: Optional[str] = None,  # 统一的模型设置
19     core_model: Optional[str] = "gpt-4o",
20     data_model: Optional[str] = None,  # 默认与core_model相同
21     temperature: Optional[float] = None,  # 统一的温度设置
22     core_temperature: float = 0.7,
23     data_temperature: float = 0.7,
24     max_retry: int = 3,
25     default_branch: str = "main",
26     mode: str = "client",
27     base_url: Optional[str] = None,
28     api_key: Optional[str] = None,
29     github_remote_url: Optional[str] = None,
30     github_token: Optional[str] = None,
31     **kwargs: Dict[str, Any]
32 ) -> None:
33     """Run the WorkflowEngine with the given configuration."""
34     # Load environment variables
35     load_dotenv()
36     
37     # Use current directory if no project_dir specified
38     if project_dir is None:
39         project_dir = os.getcwd()
40     
41     # 处理统一的模型配置
42     if model is not None:
43         core_model = model
44         data_model = model
45     
46     # 如果未指定data_model，则默认与core_model相同
47     if data_model is None:
48         data_model = core_model
49     
50     # 处理统一的温度配置
51     if temperature is not None:
52         core_temperature = temperature
53         data_temperature = temperature
54     
55     # Create config with provided parameters
56     config = WorkflowEngineConfig(
57         project_dir=project_dir, issue_id=issue_id, 
58         core_model=core_model, data_model=data_model,
59         core_template=core_temperature, data_template=data_temperature,
60         max_retry=max_retry, default_branch=default_branch, mode=mode, 
61         base_url=base_url, api_key=api_key, github_remote_url=github_remote_url,
62         github_token=github_token
63     )
64     
65     # Run the workflow engine
66     engine = WorkflowEngine(config)
67     response = engine.process_requirement(requirement)
68     
69     return response
70
```




```
File: examples/example_workflow.py
1 """
2 这个示例展示如何使用WorkflowEngine处理用户需求，自动决策是代码生成还是对话流程
3 """
4 import logging
5 import os
6 
7 from dotenv import load_dotenv
8 
9 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
10 from core.log_config import setup_logging
11 
12 
13 def main():
14     setup_logging(log_level=logging.DEBUG)
15     # 加载环境变量
16     load_dotenv()
17     
18     # 创建工作目录
19     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
20     issue_id = 3
21     
22     # 创建工作流引擎配置
23     config = WorkflowEngineConfig(
24         project_dir=project_dir,
25         issue_id=issue_id,
26         core_model="coder-model",
27         data_model="gpt-4o",
28         core_template=1,
29         data_template=0.7,
30         default_branch="dev"
31     )
32     
33     # 初始化工作流引擎
34     workflow_engine = WorkflowEngine(config)
35 
36     requirement = """
37     写一个初始化file-memory的客户端，不提供logManager只能通过gitManager的方式初始化
38     """
39     
40     # 处理代码修改需求
41     workflow_engine.process_requirement(requirement)
42 
43 if __name__ == "__main__":
44     main()
45
```




```
File: examples/example_code_generate.py
1 import logging
2 import os
3 
4 from dotenv import load_dotenv
5 
6 from core.ai import AIConfig
7 from core.code_engineer import CodeEngineerConfig, CodeEngineer
8 from core.diff import Diff
9 from core.file_memory import FileMemory, FileMemoryConfig
10 from core.file_selector import FileSelector
11 from core.git_manager import GitManager, GitConfig
12 from core.log_config import setup_logging
13 from core.log_manager import LogManager, LogConfig
14 from core.prompt_generator import PromptGenerator, PromptData
15 from core.version_manager import VersionManager
16 
17 
18 def main():
19     setup_logging(log_level=logging.DEBUG)
20     # 加载环境变量
21     load_dotenv()
22     
23     # 创建工作目录
24     project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "../."))
25 
26     issue_id = 3
27     
28     # 初始化日志管理器
29     log_config = LogConfig(project_dir=project_dir, issue_id=issue_id)
30     log_manager = LogManager(config=log_config)
31     current_round = log_manager.get_current_round()
32 
33     
34     # 初始化Git管理器
35     git_config = GitConfig(
36         repo_path=project_dir
37     )
38     git_manager = GitManager(config=git_config)
39     
40     # 初始化AI助手
41     ai_config = AIConfig(
42         model_name="coder-model",
43         temperature=1
44     )
45     
46     # 初始化版本管理器
47     version_manager = VersionManager(issue_id=issue_id, log_manager=log_manager, git_manager=git_manager, ai_config=ai_config)
48 
49     current_requirement = '''
50     将 example_chat_process.py 和 example_code_generate.py的流程整合到 workflow_engine.py 中，目前两个代码文件都是写代码和回复用户的完整流程。
51     使用DecisionEnvironment来决策选择何种模式。
52     '''
53     requirement, history = version_manager.ensure_version_and_generate_context(current_requirement)
54 
55     if current_round > 1:
56         file_memory = FileMemory(config=FileMemoryConfig(git_manager=git_manager, ai_config=ai_config, project_dir=project_dir))
57         file_memory.update_file_details()
58 
59     selector = FileSelector(
60         project_dir,
61         issue_id,
62         ai_config=ai_config,
63     )
64 
65     files = selector.select_files_for_requirement(requirement)
66 
67     descriptions = FileMemory.get_selected_file_descriptions(project_dir, files)
68 
69     data = PromptData(requirement=requirement, project_dir=project_dir, steps = history, files=files, file_desc=descriptions)
70     user_prompt = PromptGenerator.generatePrompt(data)
71     config = CodeEngineerConfig(project_dir=project_dir, ai_config=ai_config)
72 
73     engineer = CodeEngineer(config, LogManager(LogConfig(project_dir=project_dir, issue_id=issue_id)), Diff(AIConfig(temperature=0.1,
74                                                                                                               model_name="gpt-4o")))
75     engineer.process_prompt(prompt=user_prompt)
76 
77 
78 if __name__ == "__main__":
79     main()
80
```




```
File: core/workflow_engine.py
1 import os
2 import shutil
3 import tempfile
4 import uuid
5 from dataclasses import dataclass
6 from typing import Optional
7 
8 from core.ai import AIConfig
9 from core.chat_processor import ChatProcessor, ChatProcessorConfig
10 from core.code_engineer import CodeEngineer, CodeEngineerConfig
11 from core.decision import DecisionProcess
12 from core.diff import Diff
13 from core.file_memory import FileMemory, FileMemoryConfig
14 from core.file_selector import FileSelector
15 from core.git_manager import GitManager, GitConfig
16 from core.log_config import get_logger
17 from core.log_manager import LogManager, LogConfig
18 from core.prompt_generator import PromptGenerator, PromptData
19 from core.version_manager import VersionManager
20 
21 logger = get_logger(__name__)
22 
23 @dataclass
24 class WorkflowEngineConfig:
25     project_dir: str
26     issue_id:int
27     core_model:str = "gpt-4o"
28     data_model:str = "gpt-4o"
29     core_template: float = 0.7
30     data_template: float = 0.7
31     max_retry: int = 3,
32     default_branch: str = "main"
33     mode: str = "client" # ["client", "bot"] bot模式下，每次进行工作时，会hard reset到issues的最新分支上
34     base_url: Optional[str] = None
35     api_key: Optional[str] = None
36     github_remote_url: Optional[str] =None
37     github_token: Optional[str] = None
38 
39 
40 class WorkflowEngine:
41     CODE_TIMES = 0
42     CHAT_TIMES = 0
43     """
44     工作流引擎，协调版本管理、日志管理和AI交互
45     """
46     def __init__(self, config: WorkflowEngineConfig):
47         """
48         初始化工作流引擎
49         
50         Args:
51             config: 工作流配置
52         """
53         self.CODE_TIMES = 0
54         self.CHAT_TIMES = 0
55         # 存储原始配置
56         self.original_config = config
57         
58         # 根据模式设置工作目录
59         if config.mode == "bot":
60             # 创建临时目录作为工作区
61             self.temp_dir = os.path.join(
62                 tempfile.gettempdir(), 
63                 f"bella-bot-{config.issue_id}-{str(uuid.uuid4())[:8]}"
64             )
65             os.makedirs(self.temp_dir, exist_ok=True)
66             # 更新配置以使用临时目录
67             self.config = WorkflowEngineConfig(
68                 project_dir=self.temp_dir,
69                 **{k: v for k, v in vars(config).items() if k != 'project_dir'}
70             )
71             logger.info(f"Bot模式：创建临时工作目录 {self.temp_dir}")
72         else:
73             # 客户端模式直接使用指定的目录
74             self.config = config
75             self.temp_dir = None
76 
77         self.project_dir = os.path.abspath(self.config.project_dir)
78         # 创建AI配置
79         self.core_ai_config = AIConfig(
80             model_name=config.core_model,
81             temperature=config.core_template,
82             base_url=config.base_url,
83             api_key=config.api_key
84         )
85         
86         self.data_ai_config = AIConfig(
87             model_name=config.data_model,
88             temperature=config.data_template,
89             base_url=config.base_url,
90             api_key=config.api_key
91         )
92         
93         # 创建Git配置
94         self.git_config = GitConfig(
95             repo_path=self.project_dir,
96             remote_url=config.github_remote_url or os.getenv("GIT_REMOTE"),
97             auth_token=config.github_token or os.getenv("GITHUB_TOKEN"),
98             default_branch=config.default_branch
99         )
100         
101         # 创建日志配置
102         self.log_config = LogConfig(
103             project_dir=self.project_dir,
104             issue_id=config.issue_id,
105             mode=config.mode
106         )
107         
108         # 初始化管理器
109         self.git_manager = GitManager(config=self.git_config)
110         self.log_manager = LogManager(config=self.log_config)
111         
112         # 初始化文件记忆管理，传入log_manager
113         self.file_memory = FileMemory(
114             config=FileMemoryConfig(
115                 git_manager=self.git_manager,
116                 ai_config=self.core_ai_config,
117                 project_dir=self.project_dir,
118                 log_manager=self.log_manager
119             )
120         )
121         self.version_manager = VersionManager(
122             issue_id=config.issue_id,
123             ai_config=self.core_ai_config,
124             log_manager=self.log_manager,
125             git_manager=self.git_manager,
126             file_memory=self.file_memory
127         )
128         self.file_selector = FileSelector(
129             self.project_dir,
130             self.config.issue_id,
131             ai_config=self.core_ai_config
132         )
133 
134         # 初始化代码工程师
135         self.code_engineer_config = CodeEngineerConfig(
136             project_dir=self.project_dir,
137             ai_config=self.core_ai_config
138         )
139         self.engineer = CodeEngineer(
140             self.code_engineer_config,
141             self.log_manager,
142             Diff(self.data_ai_config)
143         )
144         
145         # 初始化聊天处理器
146         self.chat_processor = ChatProcessor(
147             ai_config=self.core_ai_config,
148             log_manager=self.log_manager,
149             config=ChatProcessorConfig(system_prompt="你是一个项目助手，负责回答关于代码库的问题。下面会给出用户的问题以及相关的项目文件信息。")
150         )
151         
152         # 初始化决策环境
153         self.decision_env = DecisionProcess(
154             ai_config=self.core_ai_config,
155             version_manager=self.version_manager
156         )
157     
158     def process_requirement(self, user_requirement: str) -> Optional[str]:
159         """
160         处理用户需求
161         
162         Args:
163             user_requirement: 用户需求
164 
165         Returns:
166             str: 处理结果的响应文本
167         """
168         try:
169             # 初始化环境
170             self._setup_environment()
171             
172             response = self._process_requirement_internal(user_requirement)
173             
174             # 如果是bot模式，在结束时清理临时目录
175             if self.config.mode == "bot":
176                 self._cleanup_environment()
177             
178             return response
179         except Exception as e:
180             logger.error(f"处理需求时发生错误: {str(e)}")
181             raise
182 
183     def _setup_environment(self) -> None:
184         """
185         根据模式设置工作环境
186         """
187         if self.config.mode == "bot":
188             try:
189                 # 重置到issue对应的分支
190                 self.git_manager.reset_to_issue_branch(self.config.issue_id)
191                 logger.info(f"成功初始化Bot模式环境，工作目录: {self.temp_dir}")
192             except Exception as e:
193                 logger.error(f"初始化Bot模式环境失败: {str(e)}")
194                 self._cleanup_environment()
195                 raise
196         current_round = self.log_manager.get_current_round()
197 
198         # 如果轮次大于1，增量更新上一轮修改的文件详细信息
199         if self.file_memory and current_round > 1:
200             self.file_memory.update_file_details()
201             logger.info("已更新文件详细信息")
202         
203     def _cleanup_environment(self) -> None:
204         """
205         清理工作环境，删除临时目录
206         """
207         if self.config.mode == "bot" and self.temp_dir and os.path.exists(self.temp_dir):
208             try:
209                 # 关闭git仓库连接
210                 if hasattr(self, 'git_manager') and self.git_manager:
211                     self.git_manager.delete_local_repository()
212                 
213                 # 删除临时目录
214                 shutil.rmtree(self.temp_dir, ignore_errors=True)
215                 logger.info(f"已清理临时工作目录: {self.temp_dir}")
216             except Exception as e:
217                 logger.warning(f"清理临时目录时出错: {str(e)}")
218                 # 即使清理失败也不抛出异常，让主流程继续
219 
220     def _process_requirement_internal(self, user_requirement: str) -> Optional[str]:
221         """
222         内部处理需求的方法
223         
224         Args:
225             user_requirement: 用户需求
226             
227         Returns:
228             str: 处理结果
229         """
230         # 先通过决策环境分析需求类型
231         decision_result = self.decision_env.analyze_requirement(user_requirement)
232         
233         logger.info(f"决策结果: 是否需要修改代码={decision_result.needs_code_modification}, "
234                     f"理由={decision_result.reasoning}")
235         
236         if decision_result.needs_code_modification:
237             # 执行代码修改流程
238             response = self._run_code_generation_workflow(user_requirement)
239         else: 
240             # 执行对话流程
241             response = self._run_chat_workflow(user_requirement)
242         
243         # 如果是Bot模式且有GitHub配置，自动回复到issue
244         if self.config.mode == "bot":
245             try:
246                 self.version_manager.finalize_changes(mode=self.config.mode, comment_text=response)
247                 logger.info(f"更改已经推送到远端，并添加了Issue评论")
248             except Exception as e:
249                 logger.error(f"添加Issue评论时出错: {str(e)}")
250                 
251         return response
252     
253     def _run_code_generation_workflow(self, user_requirement: str) -> Optional[str]:
254         """
255         执行代码生成流程，基于example_code_generate.py的逻辑
256         
257         Args:
258             user_requirement: 用户需求
259             
260         Returns:
261             str: 处理结果
262         """
263         logger.info("开始执行代码生成流程")
264 
265         # 确定当前版本
266         requirement, history = self.version_manager.ensure_version_and_generate_context(user_requirement)
267 
268         # 生成提示词
269         user_prompt = self._get_user_prompt(requirement, history)
270 
271         # 根据提示词修改代码
272         success, response = self.engineer.process_prompt(prompt=user_prompt)
273 
274         # 提交更改
275         if success:
276             return response
277         else:
278             self.CODE_TIMES += 1
279             if self.CODE_TIMES >= self.config.max_retry:
280                 logger.error("code workflow超过最大重试次数")
281                 return self._run_chat_workflow(user_requirement)
282             else:
283                 return self._run_code_generation_workflow(user_requirement)
284     
285     def _run_chat_workflow(self, user_requirement: str) -> Optional[str]:
286         """
287         执行聊天流程，基于example_chat_process.py的逻辑
288         
289         Args:
290             user_requirement: 用户需求
291             
292         Returns:
293             str: 处理结果
294         """
295         logger.info("开始执行聊天回复流程")
296 
297         history = self.version_manager.get_formatted_history()
298 
299         # 生成提示词
300         user_prompt = self._get_user_prompt(user_requirement, history)
301         
302         # 处理聊天请求
303         response = self.chat_processor.process_chat(user_prompt)
304 
305         if(response):
306             return response
307         else:
308             self.CHAT_TIMES += 1
309             if self.CHAT_TIMES >= self.config.max_retry:
310                 logger.error("chat workflow超过最大重试次数")
311                 return None
312             else:
313                 return self._run_chat_workflow(user_requirement)
314 
315     def _get_user_prompt(self, requirement: str, history: str) -> str:
316         # 选择文件
317         files = self.file_selector.select_files_for_requirement(requirement)
318         descriptions = FileMemory.get_selected_file_descriptions(self.project_dir, files)
319 
320         # 准备提示词数据
321         data = PromptData(
322             requirement=requirement,
323             project_dir=self.project_dir,
324             steps=history,
325             files=files,
326             file_desc=descriptions
327         )
328 
329         # 生成提示词
330         return PromptGenerator.generatePrompt(data)
331
```




```
File: client/terminal.py
1 """
2 Terminal entrypoint for the WorkflowEngine.
3 Provides functionality to run the engine from terminal with command-line arguments.
4 """
5 import logging
6 import os
7 import sys
8 from dotenv import load_dotenv
9 
10 from core.workflow_engine import WorkflowEngine, WorkflowEngineConfig
11 from client.cli import parse_args, get_requirement_text, build_config_from_args
12 from core.log_config import setup_logging
13 
14 
15 def run_workflow_from_terminal() -> str:
16     """
17     Main entry point for running the workflow engine from terminal.
18     Parses command line arguments and runs the workflow engine.
19     """
20     # Load environment variables from .env file if present
21     load_dotenv()
22     
23     # Parse command line arguments
24     args = parse_args()
25     
26     # Get requirement text
27     requirement = get_requirement_text(args)
28     if not requirement:
29         sys.exit(1)
30     
31     # Build config from arguments
32     config_params = build_config_from_args(args)
33     
34     # Try to get API key from environment if not provided as argument
35     if "api_key" not in config_params and os.environ.get("OPENAI_API_KEY"):
36         config_params["api_key"] = os.environ.get("OPENAI_API_KEY")
37     
38     # Create the workflow engine config
39     config = WorkflowEngineConfig(**config_params)
40     
41     # Initialize and run the workflow engine
42     engine = WorkflowEngine(config)
43     response = engine.process_requirement(requirement)
44     
45     # Print the response to the terminal if available
46     if response:
47         print(f"\nResponse:\n{response}")
48     
49     return response if response else ""
50 
51 
52 if __name__ == "__main__":
53     setup_logging(log_level=logging.INFO)
54     response = run_workflow_from_terminal()
55 
56
```




```
File: client/__init__.py
1 """Client package for running the WorkflowEngine from the terminal."""
```




# 用户需求


    写一个初始化file-memory的客户端，不提供logManager只能通过gitManager的方式初始化
    